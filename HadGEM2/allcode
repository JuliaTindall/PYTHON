::::::::::::::
assess_spinup_temperature.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    assess_spinup_temperature.py
#PURPOSE
#    This program will plot timeseries of:
#          ocean temperature
#          SST
#          SAT
#    to assess spinup
#
# it uses data provided by based on IDLPRGS/plotall_temptimeseries.pro
#
# search for 'main program' to find end of functions
# Julia 28/08/2019



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid



def plotdata(filename,titlename,plotno,valmin,valmax):
    """ plots the data in a file
    requires the filename, the title of the plot
    where on the page we want the plot to go
    """
    
    
    f = open(filename, "r")
    line = f.readline()
    expt=-1
    first = 'y'
    allindex = []
    alldata = []
    alltitle = []
    

    while line:
        # test for titleline if 1st character not space use this
    
        if line[0:3] != '   ':
            expt = expt + 1
            alltitle.append(line)
        
            if first == 'n':
                allindex.append(index_list)
                alldata.append(data_list)
            
            index_list=[]
            data_list=[]
            first = 'n'
        else:
            index, data = line.split()
        
            index_list.append(np.int(index))
            data_list.append(np.float(data))
 
        
        line = f.readline()

    f.close()

    allindex.append(index_list)
    alldata.append(data_list)
            
    index_list=[]
    data_list=[]

    print(alltitle)

    ax = plt.subplot(2,2,plotno)
    colors=['black','blue','red']
    for i in range(0,len(allindex)):
        ax.plot(allindex[i],alldata[i],label=alltitle[i],color=colors[i])
    
   
    ax.set_ylabel('deg C')
    ax.set_xlabel('year')
    ax.set_ylim(valmin,valmax)
    ax.set_xlim(0,550)
    ax.set_title(titlename)
        
    ax.legend()
    


################################
# main program

fig=plt.figure(figsize=(8,8))

#hADgem
filename = '/nfs/hera1/earjcti/IDLPLOTS/HadGEM/plotall_temptimeseries.txt'
titlename = 'a) HadGEM total ocean temperature'
plotdata(filename,titlename,1,-0.1,1.0)


# HadCm3
filename = '/nfs/hera1/earjcti/IDLPLOTS/HadGEM/plotall_temptimeseries_HadCM3.txt'
titlename = 'b) HadCM3 total ocean temperature'
plotdata(filename,titlename,2,-0.1,1.0)

# HadGEM level 1
filename = '/nfs/hera1/earjcti/IDLPLOTS/HadGEM/plotall_temptimeseries_lev1.txt'
titlename = 'c) HadGEM sea surface temperature'
plotdata(filename,titlename,3,-0.5,0.5)

# HadGEM SAT
filename = '/nfs/hera1/earjcti/IDLPLOTS/HadGEM/plotall_SATtimeseries.txt'
titlename = 'd) HadGEM SAT'
plotdata(filename,titlename,4,-1.0,1.0)



fig.tight_layout()
#plt.show()
fileout='/home/earjcti/PYTHON/PLOTS/HadGEM2/temperature_trends.eps'
plt.savefig(fileout)
plt.close()


####

::::::::::::::
diff_ancil_files.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""

This program will difference some of the ancil files
between the preindustrial and the pliocene experiments

This is to show the changes we have made between the paper.
Created on Fri Dec 20 10:33:08 2019

@author: earjcti
"""

import iris
import numpy as np
import matplotlib.pyplot as plt
import iris.plot as iplt
import iris.quickplot as qplt

import sys


def get_data(filename, fieldreq):
    """

    Parameters
    ----------
    filename : name of the file (start dump containing the data
    fieldreq : which field we want to get

    Returns
    -------
    an iris cube containing the required data

    """
    
    if fieldreq == 'orog':
        cubefull = iris.load_cube(filename, 'OROGRAPHY (/STRAT LOWER BC)')
        cube = cubefull.collapsed(['surface','t'],iris.analysis.MEAN)
   
    if fieldreq == 'ice' and MODEL == 'HadCM3':
        cubefull = iris.load(filename, 'FRACTIONS OF SURFACE TYPES')
        cubeice = cubefull[4]
        
        cube = cubeice.collapsed(['surface','t'],iris.analysis.MEAN)
        
    if fieldreq == 'ice' and MODEL == 'HadGEM2':
        cubefull = iris.load_cube(filename, 'FRACTIONS OF SURFACE TYPES')
        cube_ice = cubefull.extract(iris.Constraint(pseudo=9))
        cube = cube_ice.collapsed(['t'],iris.analysis.MEAN)
    
        #qplt.contourf(cube)
        #plt.show(0)
        #sys.exit(0)
    
    
    return cube

###########################################################################

FIELD = 'ice'   # field can be orog or ice
MODEL = 'HadCM3' # model can be HadGEM2 or HadCM3
OUTSTART = '/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ancil/'



if MODEL == 'HadGEM2':
    FILENAME_PLIO = ('/nfs/hera1/earjcti/um/HadGEM_data' +  
                   '/xkvjg/netcdf/xkvjga@dan10c1.nc')
    FILENAME_PI = ('/nfs/hera1/earjcti/um/HadGEM_data' +  
                   '/xkvje/netcdf/xkvjea@dao00c1.nc')
    
if MODEL == 'HadCM3':
    FILENAME_PLIO = ('/nfs/hera1/earjcti/um/' +  
                   '/xibol/netcdf/xibola@daz00c1.nc')
    FILENAME_PI = ('/nfs/hera1/earjcti/um/' +  
                   '/xiboi/netcdf/xiboia@dat45c1.nc')

plio_cube = get_data(FILENAME_PLIO, FIELD)
pi_cube = get_data(FILENAME_PI, FIELD)

cube_anom = (plio_cube - pi_cube) 
if FIELD == 'orog':
    V = np.arange(-2000, 2100, 100)
if FIELD == 'ice':
    V = np.arange(-1.0, 1.1, 0.1)
cs = iplt.contourf(cube_anom, V, cmap='bwr', extend='both')
plt.gca().coastlines()
cbar = plt.colorbar(cs, orientation='horizontal')

if FIELD == 'orog' and MODEL == 'HadGEM2':
    plt.title('a) HadGEM2: mPWP-PI orography', loc='left')
    cbar.set_label('m')
    plt.savefig(OUTSTART + 'HadGEM2_orog_anom.pdf')
if FIELD == 'orog' and MODEL == 'HadCM3':
    plt.title('b) HadCM3: mPWP-PI orography', loc='left')
    cbar.set_label('m')
    plt.savefig(OUTSTART + 'HadCM3_orog_anom.pdf')
if FIELD == 'ice' and MODEL == 'HadGEM2':
    plt.title('c) HadGEM2: mPWP-PI ice fraction', loc='left')
    cbar.set_label('fraction')
    plt.savefig(OUTSTART + 'HadGEM2_ice_anom.pdf')
if FIELD == 'ice' and MODEL == 'HadCM3':
    plt.title('d) HadCM3: mPWP-PI ice fraction', loc='left')
    cbar.set_label('fraction')
    plt.savefig(OUTSTART + 'HadCM3_ice_anom.pdf')

plt.close()
#HadGEM2
#xkvjg pliocene (ancil_jct/HadGEM/3ma)
#                   HadGEM_Pliocene_orog
#                   HadGEM_pliocene_vegfrac
#xkvje preindustrial
#                   
#HG2 filename
#/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/xkvjga@dan10c1.nc
#'OROGRAPHY (/STRAT LOWER BC)'
#'FRACTIONS OF SURFACE TYPES' level 9
#...xkfje/netcdf/xkvjea@dao00c1::::::::::::::
ITCZ_diagnostics.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program will find the ITCZ in the North Pacific using the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia April 2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=170.0,urcrnrlon=260.0,llcrnrlat=-5.0,urcrnrlat=30.0,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold):
#  to find the ITCZ we find precipitation in a box  2S-21N 180W-110 W.
#  we actually use 5S to check we find it all
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

    # decompose grid to 180W-110W (180E-250E) 2S-21N

    nlon=0
    nlat=0
    lat_first=0
    lon_first=0

    for i in range (0,len(lon)):
        if 180 <= lon[i] <= 250:
            nlon=nlon+1
            if lon_first==0:
                lon_first=i


    for j in range (0,len(lat)):
        if -5.0 <= lat[j] <= 21:
            nlat=nlat+1
            if lat_first==0:
                lat_first=j


    print(lat_first,lon_first)
    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    for i in range(0,len(lon)):
        if 180<= lon[i] < 250:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(len(lat)-1,0,-1):
              if -5.0 <= lat[j] <= 21:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]

    

    

    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_index=np.zeros(len(AOI_lon),dtype=int)
    lower_bound_index=np.zeros(len(AOI_lon),dtype=int)
    most_intense_precip_index=np.zeros(len(AOI_lon),dtype=int)

    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        for j in range(len(AOI_lat)-1,0,-1):
            if AOI_precip[j,i] >= threshold: # check greater then threshold
                count_lons=count_lons+1
                if count_lons > max_count_lons[i]: # set up maximum
                    max_count_lons[i]=count_lons
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
          

        upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1
        #print(AOI_lon[i],i,upper_bound_index[i],lower_bound_index[i],max_count_lons[i])
        #print(AOI_lat[upper_bound_index[i]],AOI_lat[lower_bound_index[i]])
        #for j in range(0,len(AOI_lat)):
        #          print(AOI_lat[j],AOI_precip[j,i])
        #sys.exit()

    #area of interest check 

    titlename=exptname+' '+monthname
    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b')

    
    plt.plot(AOI_lon,AOI_lat[upper_bound_index],color='orange',linewidth=3)
    plt.plot(AOI_lon,AOI_lat[lower_bound_index],color='red',linewidth=3)
    plt.plot(AOI_lon,AOI_lat[most_intense_precip_index],color='white',linewidth=3)

    # overplot lower and upper bounds
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/map_'+exptname+'_'+monthname+'.eps'
    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
        weightamt=0.
        for j in range(lower_bound_index[i],upper_bound_index[i]+1):
            mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
            weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
            total_AOI_precip[i]=(total_AOI_precip[i]+
               AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
        mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

    print('total',total_AOI_precip)
   
    retdata=[AOI_lon,AOI_lat[most_intense_precip_index],AOI_lat[upper_bound_index],AOI_lat[lower_bound_index],max_AOI_precip,mean_AOI_precip,total_AOI_precip]


    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']


threshold=np.zeros(12,dtype=float)
threshold[0]=4.
threshold[1]=4.
threshold[2]=4.
threshold[3]=4.
threshold[4]=6.
threshold[5]=6.
threshold[6]=6.
threshold[7]=6.
threshold[8]=6.
threshold[9]=6.
threshold[10]=6.
threshold[11]=6.

# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i])
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # location of rainfall arrays
        max_intensity_lat_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_lat_plio=np.zeros((12,len(AOI_lon)))
        upper_bound_pi=np.zeros((12,len(AOI_lon)))
        upper_bound_plio=np.zeros((12,len(AOI_lon)))
        lower_bound_pi=np.zeros((12,len(AOI_lon)))
        lower_bound_plio=np.zeros((12,len(AOI_lon)))
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_lat_pi[i,:]=ITCZ_data[1]
    upper_bound_pi[i,:]=ITCZ_data[2]
    lower_bound_pi[i,:]=ITCZ_data[3]
    max_intensity_amt_pi[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[6]

   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i])
    max_intensity_lat_plio[i,:]=ITCZ_data[1]
    upper_bound_plio[i,:]=ITCZ_data[2]
    lower_bound_plio[i,:]=ITCZ_data[3]
    max_intensity_amt_plio[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[6]


# plot the maximum intensity latitude for each longitude for pliocene
# and preindustrial for each month

for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,max_intensity_lat_pi[i,:],label='pi')
   plt.plot(AOI_lon,max_intensity_lat_plio[i,:],label='plio')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/max_intensity.eps'
plt.savefig(fileout)
plt.close()


# plot upper range and lower range.
for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,upper_bound_pi[i,:],label='pi_upper')
   plt.plot(AOI_lon,lower_bound_pi[i,:],label='pi_lower')
   plt.plot(AOI_lon,upper_bound_plio[i,:],label='plio_upper')
   plt.plot(AOI_lon,lower_bound_plio[i,:],label='plio_lower')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)
    
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/bound_range.eps'
plt.savefig(fileout)
plt.close()

# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.mean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.mean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.mean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.mean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.mean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.mean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.mean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.mean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.mean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.mean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.sum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.sum(total_itcz_precip_amt_pi[mon,:])

plt.subplot(2,2,1)  
plt.plot(mean_loc_max_intensity_plio,label='plio')
plt.plot(mean_loc_max_intensity_pi,label='pi')
plt.title('lat maximum ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,2)  
plt.plot(mean_loc_upper_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi,label='pi')
plt.title('north lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,4)  
plt.plot(mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_lower_bound_pi,label='pi')
plt.title('south lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()

plt.subplot(2,2,3)  
plt.plot(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='pi')
plt.title('width of ITCZ')
plt.xlabel('month number')
plt.ylabel('degrees')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/avg_loc_by_month.eps'
plt.savefig(fileout)
plt.close()


# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.

plt.subplot(2,2,1)  
plt.plot(mean_amt_max_intensity_plio,label='plio')
plt.plot(mean_amt_max_intensity_pi,label='pi')
plt.title('rain amt at max ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 2. mean amount of rain in mm/day

plt.subplot(2,2,2)  
plt.plot(mean_amt_itcz_plio,label='plio')
plt.plot(mean_amt_itcz_pi,label='pi')
plt.title('mean itcz precip')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 3. total amount of rain in kg

plt.subplot(2,2,3)  
plt.plot(total_amt_itcz_plio/1.0E12,label='plio')
plt.plot(total_amt_itcz_pi/1.0E12,label='pi')
plt.title('total itcz precip')
plt.xlabel('month number')
plt.ylabel('kg (x 10^12)')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/rain_amt_by_month.eps'
plt.savefig(fileout)
plt.close()

sys.exit()
####

::::::::::::::
ITCZ_diagnostics_regional_noSPCZ.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program will find the ITCZ in a given region based on the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia August 2018
#
# Notes This program is like ITCZ_diagnostics_regional.  However it differs in 
# the sense that it will ensure the SPCZ is not picked up in the Pacific.


import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind,lonmin,lonmax,latmin,latmax):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

    map=Basemap(llcrnrlon=lonmin,urcrnrlon=lonmax,llcrnrlat=latmin,urcrnrlat=latmax,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()
    
    # set up for drawing gridlines
    if lonmax-lonmin <= 60:
        londiff=10
    else:
        londiff=30
     
   
    if latmax-latmin <= 60:
        latdiff=10
    else:
        latdiff=30

    parallels=np.arange(-90,90,latdiff)
    meridians=np.arange(-180,360,londiff)

   
    map.drawparallels(parallels,labels=[False,True,False,False])
    map.drawmeridians(meridians,labels=[False,False,False,True])

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold,land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname):
   
#  to find the ITCZ we find precipitation in the given region.
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December


  # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    #lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

   
   # shift grid as appropriate

    if lonmin < 0:
        # shift data
        avg_precip,lon=shiftgrid(180.,avg_precip,lon,start=False)
        lsm,lsmlon=shiftgrid(180.,lsm,lsmlon,start=False)


    # mask out land or ocean as appropriate.


    if land_ocean_ind == 'l':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * lsm
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,180,-90,90)

            plt.show()
            sys.exit()

    if land_ocean_ind == 'o':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * np.abs(lsm-1.0)
            #plt.figure()
            #plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.figure()
            #plotdata(lsm,99,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.show()
            #sys.exit()
        
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,0,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plotdata(lsm,1,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plt.show()
            sys.exit()
        
    # decompose grid to given region


   
    nlon=0
    nlat=0
    lat_first=-99
    lon_first=-99

    for i in range (0,len(lon)):
        if lonmin <= lon[i] <= lonmax:
            nlon=nlon+1
            if lon_first==-99:
                lon_first=i


    for j in range (0,len(lat)):
        if latmin <= lat[j] <= latmax:
            nlat=nlat+1
            if lat_first==-99:
                lat_first=j


    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    
    #julia julia julia


    for i in range(0,len(lon)):
        if lonmin<= lon[i] <= lonmax:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(len(lat)-1,0,-1):
              if latmin <= lat[j] <= latmax:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]


     #area of interest check 

    #titlename='first check'
    #plt.figure()
    #plotdata(avg_precip,99,lon,lat,'globe',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)
    #plt.figure()
    #print(lon)
    #print(AOI_lon)
    #plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b',0,360,-90,90)
    #plt.show()
    #sys.exit()
  
    
              
    
    
    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_index=np.zeros(len(AOI_lon),dtype=int)
    lower_bound_index=np.zeros(len(AOI_lon),dtype=int)
    most_intense_precip_index=np.zeros(len(AOI_lon),dtype=int)

   
   
    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        jmax=len(AOI_lat)-1
        jmin=0
        # check it is not picking up mid latitude storm tracks in pacific
        # or atlantic by reducing range to -20 20 ignore for south america
        if ((AOI_lon[i] > 180. or AOI_lon[i] < 0) and (regionname != 'SouthAmerica')):
                jmax=(np.abs(AOI_lat-20.)).argmin()
                jmin=(np.abs(AOI_lat+20.)).argmin()
        # process
        for j in range(jmax,jmin,-1):
            if AOI_precip[j,i] >= threshold: # check greater then threshold
                count_lons=count_lons+1
                if count_lons > max_count_lons[i]: # set up maximum
                    max_count_lons[i]=count_lons
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
     

         
        
        #################################################
        # if lower bound index is massively different from previous 
        # one see if we can make them line up better by narrowing range
        # in which we look for ITCZ
        if i > 0:
            if ((np.abs(lower_bound_index[i]-lower_bound_index[i-1]) >  10)
            and (lower_bound_index[i-1] != 0)):
               # print('new code',i)
                count_lons=0
                max_val=0
                second_max_lons=0
                minrange=max(0,lower_bound_index[i-1]-10)
                maxrange=min(lower_bound_index[i-1]+10,len(AOI_lat)-1)
                for j in range(maxrange,minrange,-1):
                    if AOI_precip[j,i] >= threshold: # check  threshold
                       count_lons=count_lons+1
                       if count_lons > second_max_lons: # set up maximum
                          second_max_lons=count_lons
                          lower_bound_index[i]=j
                          max_count_lons[i]=count_lons     
                    else:
                        count_lons=0
                #print('lower',i,lower_bound_index[i])
         
     
        #############################################                           
        # set up upper bound
        upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1
        if max_count_lons[i]==0:
            upper_bound_index[i]=lower_bound_index[i]
    

        #########################################################
        # check it has not picking up SPCZ in pacific by finding northern
        # branch

        upper_bound_index_temp=upper_bound_index
        if ((AOI_lon[i] > 150. and AOI_lon[i] < 270.) and (regionname != 'SPCZ')):
           if AOI_lat[upper_bound_index_temp[i]] < 0:
               count_lons=0
               max_val=0
               second_max_lons=0
               # use upper bound index found as the lower range for search
               # this means we will find the best ITCZ that is north of
               # the current position
               minrange=upper_bound_index[i]
               maxrange=(np.abs(AOI_lat-30.)).argmin() # set to 30deg
             
               for j in range(maxrange,minrange,-1):
                    if AOI_precip[j,i] >= threshold: # check  threshold
                       count_lons=count_lons+1
                       if count_lons > second_max_lons: # set up maximum
                          second_max_lons=count_lons
                          lower_bound_index[i]=j
                          max_count_lons[i]=count_lons 
                         
         
                    else:
                        count_lons=0
              
        
            
        # check that most intense precipitation is between upperbound
        # and lower bound
        if ((most_intense_precip_index[i] < lower_bound_index[i]) or
            (most_intense_precip_index[i] > upper_bound_index[i])):
            max_val=0
            for j in range(lower_bound_index[i],upper_bound_index[i]+1):
                if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                    max_val=AOI_precip[j,i]
                    
                    most_intense_precip_index[i]=j
         
    #area of interest check 

    plt.figure()
    titlename=exptname+' '+monthname
    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b',lonmin-5,lonmax+5,latmin-5,latmax+5)


  
    
    # get rid of places where ITCZ is not defined 
    AOI_lat_max_intens=AOI_lat[most_intense_precip_index]
    AOI_lat_upper=AOI_lat[upper_bound_index]
    AOI_lat_lower=AOI_lat[lower_bound_index]

    for i in range(0,len(AOI_lat_max_intens)):
        if AOI_lat_upper[i]==AOI_lat_lower[i] and AOI_lat_upper[i]==latmin:
            AOI_lat_max_intens[i]=np.nan
            AOI_lat_upper[i]=np.nan
            AOI_lat_lower[i]=np.nan
         
    # overplot lower and upper bounds
  

  
    plt.plot(AOI_lon,AOI_lat_upper,color='orange',linewidth=3)
    plt.plot(AOI_lon,AOI_lat_lower,color='red',linewidth=3,linestyle='dashed')
    plt.plot(AOI_lon,AOI_lat_max_intens,color='white',linewidth=3,linestyle='dotted')
  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/map_'+exptname+'_'+monthname+'.eps'

    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
        weightamt=0.
        for j in range(lower_bound_index[i],upper_bound_index[i]+1):
            mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
            weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
            total_AOI_precip[i]=(total_AOI_precip[i]+
               AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
        mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

   
  
  
    retdata=[AOI_lon,AOI_lat_max_intens,AOI_lat_upper,AOI_lat_lower,max_AOI_precip,mean_AOI_precip,total_AOI_precip]


    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
#monthnames=['dc']

threshold=np.zeros(12,dtype=float)
#threshold[0]=4.
#threshold[1]=4.
#threshold[2]=4.
#threshold[3]=4.
#threshold[4]=6.
#threshold[5]=6.
#threshold[6]=6.
#threshold[7]=6.
#threshold[8]=6.
#threshold[9]=6.
#threshold[10]=6.
#threshold[11]=6.
threshold[:]=4.

# set up atlantic ocean region
#regionname='AtlanticOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=20
#lonmin=-60
#lonmax=20



# set up indian ocean region
#regionname='IndianOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=30
#lonmax=120

# set up indian ocean region
#regionname='IndianOceanLand'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=60
#lonmax=90
#threshold[:]=1.

# set up global region
regionname='Globe'
land_ocean_ind='b'  # l land, o ocean, b both
latmin=-30
latmax=45
lonmin=0.
lonmax=358.125
threshold[:]=4.

# set up Africa land region
#regionname='Africa'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30
#latmax=35
#lonmin=-20.
#lonmax=45
#threshold[:]=2

# set up central america land region
#regionname='CentralAmerica'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-25.
#latmax=25.
#lonmin=-120.
#lonmax=-80.
#threshold[:]=4

# set up East Atlantic land region
#regionname='EastAtlantic'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-25.
#latmax=25.
#lonmin=-120.
#lonmax=-80.
#threshold[:]=4

# set up indian region
#regionname='Indian'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=10.
#latmax=30.
#lonmin=70
#lonmax=110
#threshold[:]=0


# set up east asian
#regionname='EastAsia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=0.
#latmax=50.
#lonmin=60
#lonmax=150
#threshold[:]=2

# set up Indonesia
#regionname='Indonesia'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-12.
#latmax=10.
#lonmin=110
#lonmax=150
#threshold[:]=0

# set up  Indonesia land
#regionname='IndonesiaLand'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-10.
#latmax=0.
#lonmin=130
#lonmax=150
#threshold[:]=0

# set up Australia land
#regionname='Australia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30.
#latmax=-12.
#lonmin=110
#lonmax=160
#threshold[:]=1

# set up South America land
#regionname='SouthAmerica'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-20.
#latmax=15.
#lonmin=-80.
#lonmax=-30.
#threshold[:]=4


# set up western Pacific
#regionname='WesternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=150.
#lonmax=210.
#threshold[:]=4

# set up Eastern Pacific
#regionname='EasternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=-120.
#lonmax=-90
#threshold[:]=4

# set up Eastern Pacific extended region for looking at central America
#regionname='EastPacificExt'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-10.
#latmax=30.
#lonmin=-120.
#lonmax=-60
#threshold[:]=4


# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # location of rainfall arrays
        max_intensity_lat_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_lat_plio=np.zeros((12,len(AOI_lon)))
        upper_bound_pi=np.zeros((12,len(AOI_lon)))
        upper_bound_plio=np.zeros((12,len(AOI_lon)))
        lower_bound_pi=np.zeros((12,len(AOI_lon)))
        lower_bound_plio=np.zeros((12,len(AOI_lon)))
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_lat_pi[i,:]=ITCZ_data[1]
    upper_bound_pi[i,:]=ITCZ_data[2]
    lower_bound_pi[i,:]=ITCZ_data[3]
    max_intensity_amt_pi[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[6]

   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
   
    max_intensity_lat_plio[i,:]=ITCZ_data[1]
    upper_bound_plio[i,:]=ITCZ_data[2]
    lower_bound_plio[i,:]=ITCZ_data[3]
    max_intensity_amt_plio[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[6]


# plot the maximum intensity latitude for each longitude for pliocene
# and preindustrial for each month

for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,max_intensity_lat_pi[i,:],label='pi')
   plt.plot(AOI_lon,max_intensity_lat_plio[i,:],label='plio')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/max_intensity.eps'
plt.savefig(fileout)
plt.close()


# plot upper range and lower range.
for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,upper_bound_pi[i,:],label='pi_upper')
   plt.plot(AOI_lon,lower_bound_pi[i,:],label='pi_lower')
   plt.plot(AOI_lon,upper_bound_plio[i,:],label='plio_upper')
   plt.plot(AOI_lon,lower_bound_plio[i,:],label='plio_lower')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)
    
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/bound_range.eps'
plt.savefig(fileout)
plt.close()

# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.nanmean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.nanmean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.nanmean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.nanmean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.nanmean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.nanmean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.nanmean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.nanmean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.nanmean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.nanmean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.sum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.sum(total_itcz_precip_amt_pi[mon,:])

#####################################
# plot latitude of maximum intensity

fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('latitude maximum ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_max_intensity_plio-mean_loc_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_ylim([-2.,2.])
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymin=np.min((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_max_intensity_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of northern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Northern boundary of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_upper_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymin=np.min((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymin2=np.min((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_upper_bound_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of southern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Southern boundary of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_lower_bound_plio-mean_loc_lower_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymin=np.min((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymin2=np.min((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_lower_bound_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot width of ITCZ


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('average width of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio)-(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi),label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')



# set axis limits
ax2a.set_xlim([1.,12.])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/width_by_month.eps'
plt.savefig(fileout)
plt.close()

###############################################################
# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('rain amount at max ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('mm/day',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_max_intensity_plio-mean_amt_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r')

# set axis limits
ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_max_intensity_plio,mean_amt_max_intensity_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/rainfall_max_intensity_by_month.eps'
plt.savefig(fileout)
plt.close()

#######################################
# 2. mean amount of rain in mm/day
# not sure about plotting this does it mean anything


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('mean ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('mm/day',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_itcz_plio-mean_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r')

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_itcz_plio,mean_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/mean_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
plt.close()

# 3. total amount of rain in kg



fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,total_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,total_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('total ITCZ rainfall in '+regionname)
ax1a.set_xlabel('month number')
ax1a.set_ylabel('kg',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,total_amt_itcz_plio-total_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('kg',color='r')

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((total_amt_itcz_plio,total_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/total_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
plt.close()


sys.exit()
####

::::::::::::::
ITCZ_diagnostics_regional_old.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program will find the ITCZ in a given region based on the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia August 2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind,lonmin,lonmax,latmin,latmax):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

    map=Basemap(llcrnrlon=lonmin,urcrnrlon=lonmax,llcrnrlat=latmin,urcrnrlat=latmax,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()
    
    # set up for drawing gridlines
    if lonmax-lonmin <= 60:
        londiff=10
    else:
        londiff=30
     
   
    if latmax-latmin <= 60:
        latdiff=10
    else:
        latdiff=30

    parallels=np.arange(-90,90,latdiff)
    meridians=np.arange(-180,360,londiff)

   
    map.drawparallels(parallels,labels=[False,True,False,False])
    map.drawmeridians(meridians,labels=[False,False,False,True])

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    if uselog=='nb':  # use bluescale
                        cmapuse='Blues'
                    else:
                        cmapuse='rainbow'
                    cs = map.contourf(x,y,plotdata,V,cmap=cmapuse,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold,land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname):
   
#  to find the ITCZ we find precipitation in the given region.
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December


  # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    #lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

   
   # shift grid as appropriate

    if lonmin < 0:
        # shift data
        avg_precip,lon=shiftgrid(180.,avg_precip,lon,start=False)
        lsm,lsmlon=shiftgrid(180.,lsm,lsmlon,start=False)


    # mask out land or ocean as appropriate.


    if land_ocean_ind == 'l':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * lsm
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,180,-90,90)

            plt.show()
            sys.exit()

    if land_ocean_ind == 'o':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * np.abs(lsm-1.0)
            #plt.figure()
            #plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.figure()
            #plotdata(lsm,99,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.show()
            #sys.exit()
        
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,0,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plotdata(lsm,1,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plt.show()
            sys.exit()
        
    # decompose grid to given region


   
    nlon=0
    nlat=0
    lat_first=-99
    lon_first=-99

    for i in range (0,len(lon)):
        if lonmin <= lon[i] <= lonmax:
            nlon=nlon+1
            if lon_first==-99:
                lon_first=i


    for j in range (0,len(lat)):
        if latmin <= lat[j] <= latmax:
            nlat=nlat+1
            if lat_first==-99:
                lat_first=j


    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    
    #julia julia julia


    for i in range(0,len(lon)):
        if lonmin<= lon[i] <= lonmax:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(len(lat)-1,0,-1):
              if latmin <= lat[j] <= latmax:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]


     #area of interest check 

    #titlename='first check'
    #plt.figure()
    #plotdata(avg_precip,99,lon,lat,'globe',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)
    #plt.figure()
    #print(lon)
    #print(AOI_lon)
    #plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b',0,360,-90,90)
    #plt.show()
    #sys.exit()
  
    
              
    
    
    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_index=np.zeros(len(AOI_lon),dtype=int)
    lower_bound_index=np.zeros(len(AOI_lon),dtype=int)
    most_intense_precip_index=np.zeros(len(AOI_lon),dtype=int)

   
    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        jmax=len(AOI_lat)-1
        jmin=0
        # check it is not picking up mid latitude storm tracks in pacific
        # or atlantic by reducing range to -20 20 ignore for south america
        if ((AOI_lon[i] > 180. or AOI_lon[i] < 0) and (regionname != 'SouthAmerica')):
                jmax=(np.abs(AOI_lat-20.)).argmin()
                jmin=(np.abs(AOI_lat+20.)).argmin()
        # process
        for j in range(jmax,jmin,-1):
            if AOI_precip[j,i] >= threshold: # check greater then threshold
                count_lons=count_lons+1
                if count_lons > max_count_lons[i]: # set up maximum
                    max_count_lons[i]=count_lons
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
         

        # if lower bound index is massively different from previous 
        # one see if we can make them line up better by narrowing range
        # in which we look for ITCZ
        if i > 0:
            if ((np.abs(lower_bound_index[i]-lower_bound_index[i-1]) >  10)
            and (lower_bound_index[i-1] != 0)):
               # print('new code',i)
                count_lons=0
                max_val=0
                second_max_lons=0
                minrange=max(0,lower_bound_index[i-1]-10)
                maxrange=min(lower_bound_index[i-1]+10,len(AOI_lat)-1)
                for j in range(maxrange,minrange,-1):
                    if AOI_precip[j,i] >= threshold: # check  threshold
                       count_lons=count_lons+1
                       if count_lons > second_max_lons: # set up maximum
                          second_max_lons=count_lons
                          lower_bound_index[i]=j
                          max_count_lons[i]=count_lons     
                    else:
                        count_lons=0
                #print('lower',i,lower_bound_index[i])
         
                                  
        # set up upper bound
        upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1
        if max_count_lons[i]==0:
            upper_bound_index[i]=lower_bound_index[i]
    
            
        # check that most intense precipitation is between upperbound
        # and lower bound
        if ((most_intense_precip_index[i] < lower_bound_index[i]) or
            (most_intense_precip_index[i] > upper_bound_index[i])):
            max_val=0
            for j in range(lower_bound_index[i],upper_bound_index[i]+1):
                if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                    max_val=AOI_precip[j,i]
                    most_intense_precip_index[i]=j
         
        
     
       
    #area of interest check 

    plt.figure()
    titlename=exptname+' '+monthname
    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'nb','mm/day','b',lonmin-5,lonmax+5,latmin-5,latmax+5)


  
    
    # get rid of places where ITCZ is not defined 
    AOI_lat_max_intens=AOI_lat[most_intense_precip_index]
    AOI_lat_upper=AOI_lat[upper_bound_index]
    AOI_lat_lower=AOI_lat[lower_bound_index]

    for i in range(0,len(AOI_lat_max_intens)):
        if AOI_lat_upper[i]==AOI_lat_lower[i] and AOI_lat_upper[i]==latmin:
            AOI_lat_max_intens[i]=np.nan
            AOI_lat_upper[i]=np.nan
            AOI_lat_lower[i]=np.nan
         
    # overplot lower and upper bounds
  

  
    plt.plot(AOI_lon,AOI_lat_upper,color='orange',linewidth=3)
    plt.plot(AOI_lon,AOI_lat_lower,color='red',linewidth=3,linestyle='dashed')
    plt.plot(AOI_lon,AOI_lat_max_intens,color='white',linewidth=3,linestyle='dotted')
  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/map_'+exptname+'_'+monthname+'.eps'

    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
        weightamt=0.
        for j in range(lower_bound_index[i],upper_bound_index[i]+1):
            mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
            weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
            total_AOI_precip[i]=(total_AOI_precip[i]+
               AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
        mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

   
  
  
    retdata=[AOI_lon,AOI_lat_max_intens,AOI_lat_upper,AOI_lat_lower,max_AOI_precip,mean_AOI_precip,total_AOI_precip]


    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']

threshold=np.zeros(12,dtype=float)
#threshold[0]=4.
#threshold[1]=4.
#threshold[2]=4.
#threshold[3]=4.
#threshold[4]=6.
#threshold[5]=6.
#threshold[6]=6.
#threshold[7]=6.
#threshold[8]=6.
#threshold[9]=6.
#threshold[10]=6.
#threshold[11]=6.
threshold[:]=4.

# set up atlantic ocean region
#regionname='AtlanticOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=20
#lonmin=-60
#lonmax=20



# set up indian ocean region
#regionname='IndianOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=30
#lonmax=120

# set up indian ocean region
#regionname='IndianOceanLand'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=60
#lonmax=90
#threshold[:]=1.

# set up global region
regionname='Globe'
land_ocean_ind='b'  # l land, o ocean, b both
latmin=-30
latmax=45
lonmin=0.
lonmax=358.125
threshold[:]=4.

# set up Africa land region
#regionname='Africa'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30
#latmax=35
#lonmin=-20.
#lonmax=45
#threshold[:]=2

# set up central america land region
#regionname='CentralAmerica'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-25.
#latmax=25.
#lonmin=-120.
#lonmax=-80.
#threshold[:]=4

# set up East Atlantic land region
#regionname='EastAtlantic'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-25.
#latmax=25.
#lonmin=-120.
#lonmax=-80.
#threshold[:]=4

# set up indian region
#regionname='Indian'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=10.
#latmax=30.
#lonmin=70
#lonmax=110
#threshold[:]=0


# set up east asian
#regionname='EastAsia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=0.
#latmax=50.
#lonmin=60
#lonmax=150
#threshold[:]=2

# set up Indonesia
#regionname='Indonesia'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-12.
#latmax=10.
#lonmin=110
#lonmax=150
#threshold[:]=0

# set up  Indonesia land
#regionname='IndonesiaLand'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-10.
#latmax=0.
#lonmin=130
#lonmax=150
#threshold[:]=0

# set up Australia land
#regionname='Australia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30.
#latmax=-12.
#lonmin=110
#lonmax=160
#threshold[:]=1

# set up South America land
#regionname='SouthAmerica'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-20.
#latmax=15.
#lonmin=-80.
#lonmax=-30.
#threshold[:]=4


# set up western Pacific
#regionname='WesternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=150.
#lonmax=210.
#threshold[:]=4

# set up Eastern Pacific
#regionname='EasternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=-120.
#lonmax=-90
#threshold[:]=4

# set up Eastern Pacific extended region for looking at central America
#regionname='EastPacificExt'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-10.
#latmax=30.
#lonmin=-120.
#lonmax=-60
#threshold[:]=4


# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # location of rainfall arrays
        max_intensity_lat_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_lat_plio=np.zeros((12,len(AOI_lon)))
        upper_bound_pi=np.zeros((12,len(AOI_lon)))
        upper_bound_plio=np.zeros((12,len(AOI_lon)))
        lower_bound_pi=np.zeros((12,len(AOI_lon)))
        lower_bound_plio=np.zeros((12,len(AOI_lon)))
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_lat_pi[i,:]=ITCZ_data[1]
    upper_bound_pi[i,:]=ITCZ_data[2]
    lower_bound_pi[i,:]=ITCZ_data[3]
    max_intensity_amt_pi[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[6]

   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
   
    max_intensity_lat_plio[i,:]=ITCZ_data[1]
    upper_bound_plio[i,:]=ITCZ_data[2]
    lower_bound_plio[i,:]=ITCZ_data[3]
    max_intensity_amt_plio[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[6]


# plot the maximum intensity latitude for each longitude for pliocene
# and preindustrial for each month

for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,max_intensity_lat_pi[i,:],label='pi')
   plt.plot(AOI_lon,max_intensity_lat_plio[i,:],label='plio')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/max_intensity.eps'
plt.savefig(fileout)
plt.close()


# plot upper range and lower range.
for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,upper_bound_pi[i,:],label='pi_upper')
   plt.plot(AOI_lon,lower_bound_pi[i,:],label='pi_lower')
   plt.plot(AOI_lon,upper_bound_plio[i,:],label='plio_upper')
   plt.plot(AOI_lon,lower_bound_plio[i,:],label='plio_lower')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)
    
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/bound_range.eps'
plt.savefig(fileout)
plt.close()

# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.nanmean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.nanmean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.nanmean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.nanmean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.nanmean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.nanmean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.nanmean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.nanmean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.nanmean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.nanmean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.sum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.sum(total_itcz_precip_amt_pi[mon,:])

#####################################
# plot latitude of maximum intensity

fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('latitude maximum ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_max_intensity_plio-mean_loc_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_ylim([-2.,2.])
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymin=np.min((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_max_intensity_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of northern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Northern boundary of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_upper_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymin=np.min((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymin2=np.min((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_upper_bound_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of southern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Southern boundary of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_lower_bound_plio-mean_loc_lower_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymin=np.min((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymin2=np.min((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_lower_bound_by_month.eps'
plt.savefig(fileout)
plt.close()


#####################################
# plot width of ITCZ


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('average width of ITCZ')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('latitude',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio)-(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi),label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r')



# set axis limits
ax2a.set_xlim([1.,12.])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/width_by_month.eps'
plt.savefig(fileout)
plt.close()

###############################################################
# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('rain amount at max ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('mm/day',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_max_intensity_plio-mean_amt_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r')

# set axis limits
ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_max_intensity_plio,mean_amt_max_intensity_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/rainfall_max_intensity_by_month.eps'
plt.savefig(fileout)
plt.close()

#######################################
# 2. mean amount of rain in mm/day
# not sure about plotting this does it mean anything


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('mean ITCZ intensity')
ax1a.set_xlabel('month number')
ax1a.set_ylabel('mm/day',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_itcz_plio-mean_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r')

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_itcz_plio,mean_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/mean_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
plt.close()

# 3. total amount of rain in kg



fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,total_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,total_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('total ITCZ rainfall in '+regionname)
ax1a.set_xlabel('month number')
ax1a.set_ylabel('kg',color='blue')
ax2a=ax1a.twinx()
ax2a.plot(xvals,total_amt_itcz_plio-total_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('kg',color='r')

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((total_amt_itcz_plio,total_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue')
ax2a.tick_params(axis='y',colors='r')
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/total_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
plt.close()


sys.exit()
####

::::::::::::::
ITCZ_diagnostics_regional.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program will find the ITCZ in a given region based on the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia August 2018
#
# Notes This program is like ITCZ_diagnostics_regional.  However it allows
# the ITCZ to be discontinuous.

import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind,lonmin,lonmax,latmin,latmax):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

    map=Basemap(llcrnrlon=lonmin,urcrnrlon=lonmax,llcrnrlat=latmin,urcrnrlat=latmax,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()
    
    # set up for drawing gridlines
    if lonmax-lonmin <= 60:
        londiff=10
    else:
        londiff=30
     
   
    if latmax-latmin <= 60:
        latdiff=10
    else:
        latdiff=30

    parallels=np.arange(-90,90,latdiff)
    meridians=np.arange(-180,360,londiff)

   
    map.drawparallels(parallels,labels=[False,True,False,False])
    map.drawmeridians(meridians,labels=[False,False,False,True])


    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    if uselog=='nb':  # use bluescale
                        cmapuse='Blues'
                    else:
                        cmapuse='rainbow'
                    cs = map.contourf(x,y,plotdata,V,cmap=cmapuse,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold,land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname):
   
#  to find the ITCZ we find precipitation in the given region.
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December


  # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    #lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

   
   # shift grid as appropriate

    if lonmin < 0:
        # shift data
        avg_precip,lon=shiftgrid(180.,avg_precip,lon,start=False)
        lsm,lsmlon=shiftgrid(180.,lsm,lsmlon,start=False)


    # mask out land or ocean as appropriate.


    if land_ocean_ind == 'l':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * lsm
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,180,-90,90)

            plt.show()
            sys.exit()

    if land_ocean_ind == 'o':
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            avg_precip=avg_precip * np.abs(lsm-1.0)
            #plt.figure()
            #plotdata(avg_precip,99,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.figure()
            #plotdata(lsm,99,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            #plt.show()
            #sys.exit()
        
        else:
            print('error lon/lat of land sea mask dont match')
            plotdata(avg_precip,0,lon,lat,'precip in region',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plotdata(lsm,1,lsmlon,lsmlat,'lsm',0.0,1.0,0.5,0,'n','mm/day','b',-180,360,-90,90)

            plt.show()
            sys.exit()
        
    # decompose grid to given region


   
    nlon=0
    nlat=0
    lat_first=-99
    lon_first=-99

    for i in range (0,len(lon)):
        if lonmin <= lon[i] <= lonmax:
            nlon=nlon+1
            if lon_first==-99:
                lon_first=i


    for j in range (0,len(lat)):
        if latmin <= lat[j] <= latmax:
            nlat=nlat+1
            if lat_first==-99:
                lat_first=j


    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    
  

    for i in range(0,len(lon)):
        if lonmin<= lon[i] <= lonmax:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(len(lat)-1,0,-1):
              if latmin <= lat[j] <= latmax:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]


     #area of interest check 

    #titlename='first check'
    #plt.figure()
    #plotdata(avg_precip,99,lon,lat,'globe',0.0,10.0,0.5,0,'n','mm/day','b',-180,360,-90,90)
    #plt.figure()
    #print(lon)
    #print(AOI_lon)
    #plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b',0,360,-90,90)
    #plt.show()
    #sys.exit()
  
    
              
    
    
    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    #for j in range(0,len(AOI_lat)):
    #    print('ju0',AOI_lat[j],AOI_precip[j,58])

    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_index=np.zeros(len(AOI_lon),dtype=int)
    lower_bound_index=np.zeros(len(AOI_lon),dtype=int)
    most_intense_precip_index=np.zeros(len(AOI_lon),dtype=int)

   
    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        jmax=len(AOI_lat)-1
        jmin=0
        # check it is not picking up mid latitude storm tracks in pacific
        # or atlantic by reducing range to -20 20 ignore for south america
        if ((AOI_lon[i] > 180. or AOI_lon[i] < 0) and (regionname != 'SouthAmerica')):
                jmax=(np.abs(AOI_lat-20.)).argmin()
                jmin=(np.abs(AOI_lat+20.)).argmin()
        # process
        for j in range(jmax,jmin,-1):
            # set up j-1 and j+1 for checking values either side
            jmin1=j-1
            jpl1=j+1
            if jmin1 < 0:
                jmin1=0
            if jpl1 > len(AOI_lat)-1:
                jpl1=len(AOI_lat)-1
            # check precipitation greater than threshold but include if there
            # is only a single latitude blip
            if (AOI_precip[j,i] >= threshold or 
                (AOI_precip[jmin1,i] > threshold and 
                 AOI_precip[jpl1,i] > threshold)): 
                count_lons=count_lons+1
                # if the number of longitude is greater than the previous 
                # maximum then this is the new ITCZ.  However we are 
                # constraining the
                # lower bound latitude to be less than 20N
                if (count_lons > max_count_lons[i]
                   and AOI_lat[j] < 20.):
                    max_count_lons[i]=count_lons
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
     

         
         
     
        #############################################                           
        # set up upper bound
        upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1
        if max_count_lons[i]==0:
            upper_bound_index[i]=lower_bound_index[i]
    


    print('j1',upper_bound_index[1],lower_bound_index[1])
     

    ################################################
    #  HERE WE HAVE LOTS OF CHECKS TO MAKE SURE THAT THE
    #  MPWP AND THE PI ARE COMPARIABLE

    #################################################
    # September-January make sure that the northern branch
    # of the ITCZ in the western Pacific is included at the
    # upper bound (ie don't have ITCZ jumping between NH and SH)
    # this may mean it is not totally continuous in latitude
    imin=(np.abs(AOI_lon-150.)).argmin()
    imax=(np.abs(AOI_lon-230.)).argmin()
    if monthname in ['ot','nv','dc','ja','my','jn','sp']:
        for i in range(imin,imax):
            if AOI_lat[upper_bound_index[i]] < 0: # in southern hemisphere
                # set to previous one.  This will be in NH.
                upper_bound_index[i]=upper_bound_index[i-1]
                # if new upper bound index has precipitation
                # greater than threshold see if you can expand northwards
                if AOI_precip[upper_bound_index[i],i] >= threshold:
                    jmin=upper_bound_index[i]
                    jmax=len(AOI_lat)
                    for j in range(jmin,jmax):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move northwards
                        else:
                            break # no longer try and move northwards
                # if new upper bound index has precipitation that is less
                # then the threshold then you will have to move it
                # southwards
                if AOI_precip[upper_bound_index[i],i] < threshold:
                    jmax=upper_bound_index[i]
                    jmin=0
                    for j in range(jmax,jmin,-1):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move southwards
                            break
  
 
    #################################################
    # July-November  make sure that the SPCZ is included in the
    # lower branch to make consistencies between the two climates
    # however use a threshold of 6mm/day on the SPCZ
    # (ie don't have ITCZ lower bound jumping between NH and SH)
    # this may mean it is not totally continuous in latitude
    imin=(np.abs(AOI_lon-150.)).argmin()
    imax=(np.abs(AOI_lon-230.)).argmin()
    if monthname in ['jl','ag','sp','ot','nv']:
        for i in range(imin,imax):
            if AOI_lat[lower_bound_index[i]] > 0: # in nothern hemisphere
                # set to previous one.  This will be in SH.
                lower_bound_index[i]=lower_bound_index[i-1]
                # if new lower bound index has precipitation
                # greater than 6mmday see if you can expand southwards
                if AOI_precip[lower_bound_index[i],i] >= 6:
                    jmax=lower_bound_index[i]
                    jmin=0
                    for j in range(jmax,jmin,-1):
                        if AOI_precip[j,i] >= 6:
                            lower_bound_index[i]=j # move southwards
                        else:
                            break # no longer try and move northwards
                # if new lower bound index has precipitation that is less
                # then the threshold then you will have to move it
                # northwards
                if AOI_precip[lower_bound_index[i],i] < 6:
                    jmin=lower_bound_index[i]
                    jmax=len(AOI_lat)
                    for j in range(jmin,jmax):
                        if AOI_precip[j,i] >= 6:
                            lower_bound_index[i]=j # move northwards
                            break

    #################################################
    # January-Feb make sure that the northern branch
    # of the ITCZ in the mid Atlantic is included at the
    # upper bound (ie don't have ITCZ jumping between NH and SH)
    # this may mean it is not totally continuous in latitude
    imin=(np.abs(AOI_lon+35.)).argmin() # for -35, - -10
    imax=(np.abs(AOI_lon+10.)).argmin()
    if imin == imax:   # then use 325-350
        imin=(np.abs(AOI_lon-325.)).argmin() # for -35, - -10
        imax=(np.abs(AOI_lon-350.)).argmin()
  
    if monthname in ['ja','fb']:
        for i in range(imin,imax):
            if AOI_lat[upper_bound_index[i]] < 0: # in southern hemisphere
                # set to previous one.  This will be in NH.
                upper_bound_index[i]=upper_bound_index[i-1]
                # if new upper bound index has precipitation
                # greater than threshold see if you can expand northwards
                if AOI_precip[upper_bound_index[i],i] >= threshold:
                    jmin=upper_bound_index[i]
                    jmax=len(AOI_lat)
                    for j in range(jmin,jmax):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move northwards
                        else:
                            break # no longer try and move northwards
                # if new upper bound index has precipitation that is less
                # then the threshold then you will have to move it
                # southwards
                if AOI_precip[upper_bound_index[i],i] < threshold:
                    jmax=upper_bound_index[i]
                    jmin=0
                    for j in range(jmax,jmin,-1):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move southwards
                            break
  
             

    ##################################################
    #  correct a very small (=< 4 gridboxes of longitude) discontinuity
    #  in the upper bound

    for i in range(1,len(AOI_lon)-4):
        # if large distance between this and previous
        upper_bound_difference=np.abs(upper_bound_index[i]-upper_bound_index[i-1])
        if  upper_bound_difference> 6 and upper_bound_index[i-1] != 0:
            
            # if later the upper bound returns to previous position
            # then find a better location for the upper bound index
            diff_plus1=(np.abs(upper_bound_index[i+1]-upper_bound_index[i-1]))
            diff_plus2=(np.abs(upper_bound_index[i+2]-upper_bound_index[i-1]))
            diff_plus3=(np.abs(upper_bound_index[i+3]-upper_bound_index[i-1]))
            diff_plus4=(np.abs(upper_bound_index[i+4]-upper_bound_index[i-1]))
            if  (diff_plus1 < upper_bound_difference / 2
            or diff_plus2  < upper_bound_difference / 2
            or diff_plus3  < upper_bound_difference / 2
            or diff_plus4  < upper_bound_difference / 2):
                # initially set to same as previous
                upper_bound_index[i]=upper_bound_index[i-1]
                # if new upper bound index has precipitation
                # greater than threshold see if you can expand northwards
                if AOI_precip[upper_bound_index[i],i] >= threshold:
                    jmin=upper_bound_index[i]
                    jmax=len(AOI_lat)
                    for j in range(jmin,jmax):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move northwards
                        else:
                            break # no longer try and move northwards
                # if new upper bound index has precipitation that is less
                # then the threshold then you will have to move it
                # southwards
                if AOI_precip[upper_bound_index[i],i] < threshold:
                    jmax=upper_bound_index[i]
                    jmin=0
                    for j in range(jmax,jmin,-1):
                        if AOI_precip[j,i] >= threshold:
                            upper_bound_index[i]=j # move southwards
                            break
                   

    ##################################################
    #  correct a very small (=< 4 gridboxes of longitude) discontinuity
    #  in the lower bound

    for i in range(1,len(AOI_lon)-4):
        # if large distance between this and previous
        lower_bound_difference=np.abs(lower_bound_index[i]-lower_bound_index[i-1])
        if  lower_bound_difference> 6:
            
            # if later the lower bound returns to previous position
            # then find a better location for the lower bound index
            diff_plus1=(np.abs(lower_bound_index[i+1]-lower_bound_index[i-1]))
            diff_plus2=(np.abs(lower_bound_index[i+2]-lower_bound_index[i-1]))
            diff_plus3=(np.abs(lower_bound_index[i+3]-lower_bound_index[i-1]))
            diff_plus4=(np.abs(lower_bound_index[i+4]-lower_bound_index[i-1]))
            if  (diff_plus1 < lower_bound_difference / 2
            or diff_plus2  < lower_bound_difference / 2
            or diff_plus3  < lower_bound_difference / 2
            or diff_plus4  < lower_bound_difference / 2):
                # initially set to same as previous
                lower_bound_index[i]=lower_bound_index[i-1]
                # if new lower bound index has precipitation
                # greater than threshold see if you can expand southwards
                if AOI_precip[lower_bound_index[i],i] >= threshold:
                    jmax=lower_bound_index[i]
                    jmin=0
                    for j in range(jmax,jmin):
                        if AOI_precip[j,i] >= threshold:
                            lower_bound_index[i]=j # move southwards
                        else:
                            break # no longer try and move southwards
                # if new lower bound index has precipitation that is less
                # then the threshold then you will have to move it
                # northwards
                if AOI_precip[lower_bound_index[i],i] < threshold:
                    jmin=lower_bound_index[i]
                    jmax=len(AOI_lat)
                    for j in range(jmin,jmax):
                        if AOI_precip[j,i] >= threshold:
                            lower_bound_index[i]=j # move northwards
                            break
                   

    #####################################################
    # check that most intense precipitation is between upperbound
    # and lower bound
    for i in range(0,len(AOI_lon)):
        if ((most_intense_precip_index[i] < lower_bound_index[i]) or
            (most_intense_precip_index[i] > upper_bound_index[i])):
            max_val=0
            for j in range(lower_bound_index[i],upper_bound_index[i]+1):
                if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                    max_val=AOI_precip[j,i]
                    
                    most_intense_precip_index[i]=j
         
    #area of interest check 

    plt.figure()
    titlename=exptname+' '+monthname
   
    if exptname == 'xkvje':
        titlename='PI: '+monthname
    if exptname == 'xkvjg':
        titlename='mPWP: '+monthname

    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'nb','mm/day','b',lonmin-5,lonmax+5,latmin-5,latmax+5)

   
   
    
    #for i in range(0,len(AOI_lon)):
    #    print('ju2',i,AOI_lon[i],AOI_lat[lower_bound_index[i]],AOI_lat[upper_bound_index[i]])
    #sys.exit()
      
    # get rid of places where ITCZ is not defined 
    AOI_lat_max_intens=AOI_lat[most_intense_precip_index]
    AOI_lat_upper=AOI_lat[upper_bound_index]
    AOI_lat_lower=AOI_lat[lower_bound_index]

    for i in range(0,len(AOI_lat_max_intens)):
        if AOI_lat_upper[i]==AOI_lat_lower[i] and AOI_lat_upper[i]==latmin:
            AOI_lat_max_intens[i]=np.nan
            AOI_lat_upper[i]=np.nan
            AOI_lat_lower[i]=np.nan
         
    # overplot lower and upper bounds
  
    
    plt.plot(AOI_lon,AOI_lat_upper,color='orange',linewidth=3)
    plt.plot(AOI_lon,AOI_lat_lower,color='red',linewidth=3,linestyle='dashed')
    plt.plot(AOI_lon,AOI_lat_max_intens,color='white',linewidth=3,linestyle='dotted')
  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/map_'+exptname+'_'+monthname+'.eps'

    plt.savefig(fileout)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/map_'+exptname+'_'+monthname+'.tiff'

    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
        weightamt=0.
        for j in range(lower_bound_index[i],upper_bound_index[i]+1):
            mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
            weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
            total_AOI_precip[i]=(total_AOI_precip[i]+
               AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
        mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

   
  
  
    retdata=[AOI_lon,AOI_lat_max_intens,AOI_lat_upper,AOI_lat_lower,max_AOI_precip,mean_AOI_precip,total_AOI_precip]


    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
#monthnames=['ja']

threshold=np.zeros(12,dtype=float)
#threshold[0]=4.
#threshold[1]=4.
#threshold[2]=4.
#threshold[3]=4.
#threshold[4]=6.
#threshold[5]=6.
#threshold[6]=6.
#threshold[7]=6.
#threshold[8]=6.
#threshold[9]=6.
#threshold[10]=6.
#threshold[11]=6.
threshold[:]=4.

# set up atlantic ocean region
#regionname='AtlanticOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=20
#lonmin=-60
#lonmax=20



# set up indian ocean region
#regionname='IndianOcean'
#land_ocean_ind='o'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=30
#lonmax=120

# set up indian ocean region
#regionname='IndianOceanLand'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-20
#latmax=30
#lonmin=60
#lonmax=90
#threshold[:]=4.

# set up global region
#regionname='Globe'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30
#latmax=45
#lonmin=0.
#lonmax=358.125
#threshold[:]=4.

# set up Africa land region
#regionname='Africa'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30
#latmax=35
#lonmin=-20.
#lonmax=45
#threshold[:]=2

# set up central america land region
regionname='CentralAmerica'
land_ocean_ind='l'  # l land, o ocean, b both
latmin=-25.
latmax=25.
lonmin=-120.
lonmax=-80.
threshold[:]=0

# set up East Atlantic land region
#regionname='EastAtlantic'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-25.
#latmax=25.
#lonmin=-120.
#lonmax=-80.
#threshold[:]=4

# set up indian region
#regionname='Indian'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=10.
#latmax=30.
#lonmin=70
#lonmax=110
#threshold[:]=0


# set up east asian
#regionname='EastAsia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=0.
#latmax=50.
#lonmin=60
#lonmax=150
#threshold[:]=2

# set up Indonesia
#regionname='Indonesia'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-12.
#latmax=10.
#lonmin=110
#lonmax=150
#threshold[:]=0

# set up  Indonesia land
#regionname='IndonesiaLand'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-10.
#latmax=0.
#lonmin=130
#lonmax=150
#threshold[:]=0

# set up Australia land
#regionname='Australia'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-30.
#latmax=-12.
#lonmin=110
#lonmax=160
#threshold[:]=1

# set up South America land
#regionname='SouthAmerica'
#land_ocean_ind='l'  # l land, o ocean, b both
#latmin=-20.
#latmax=15.
#lonmin=-80.
#lonmax=-30.
#threshold[:]=4


# set up western Pacific
#regionname='WesternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=150.
#lonmax=200.
#threshold[:]=4

# set up Eastern Pacific
#regionname='EasternPacific'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-30.
#latmax=30.
#lonmin=-120.
#lonmax=-90
#threshold[:]=4

# set up Eastern Pacific extended region for looking at central America
#regionname='EastPacificExt'
#land_ocean_ind='b'  # l land, o ocean, b both
#latmin=-10.
#latmax=30.
#lonmin=-120.
#lonmax=-60
#threshold[:]=4


# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # location of rainfall arrays
        max_intensity_lat_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_lat_plio=np.zeros((12,len(AOI_lon)))
        upper_bound_pi=np.zeros((12,len(AOI_lon)))
        upper_bound_plio=np.zeros((12,len(AOI_lon)))
        lower_bound_pi=np.zeros((12,len(AOI_lon)))
        lower_bound_plio=np.zeros((12,len(AOI_lon)))
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_lat_pi[i,:]=ITCZ_data[1]
    upper_bound_pi[i,:]=ITCZ_data[2]
    lower_bound_pi[i,:]=ITCZ_data[3]
    max_intensity_amt_pi[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[6]

   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i],land_ocean_ind,latmin,latmax,lonmin,lonmax,regionname)
   
    max_intensity_lat_plio[i,:]=ITCZ_data[1]
    upper_bound_plio[i,:]=ITCZ_data[2]
    lower_bound_plio[i,:]=ITCZ_data[3]
    max_intensity_amt_plio[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[6]


# plot the maximum intensity latitude for each longitude for pliocene
# and preindustrial for each month

for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,max_intensity_lat_pi[i,:],label='pi')
   plt.plot(AOI_lon,max_intensity_lat_plio[i,:],label='plio')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/max_intensity.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/max_intensity.tiff'
plt.savefig(fileout)
plt.close()


# plot upper range and lower range.
for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,upper_bound_pi[i,:],label='pi_upper')
   plt.plot(AOI_lon,lower_bound_pi[i,:],label='pi_lower')
   plt.plot(AOI_lon,upper_bound_plio[i,:],label='plio_upper')
   plt.plot(AOI_lon,lower_bound_plio[i,:],label='plio_lower')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)
    
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/bound_range.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/bound_range.tiff'
plt.savefig(fileout)
plt.close()

# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.nanmean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.nanmean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.nanmean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.nanmean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.nanmean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.nanmean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.nanmean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.nanmean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.nanmean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.nanmean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.sum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.sum(total_itcz_precip_amt_pi[mon,:])

#####################################
# plot latitude of maximum intensity

fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('latitude maximum ITCZ intensity',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('latitude',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_max_intensity_plio-mean_loc_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r',fontsize=15)

# make sure both x and y axis are symetrical about zero
ax2a.set_ylim([-2.,2.])
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymin=np.min((mean_loc_max_intensity_plio,mean_loc_max_intensity_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_max_intensity_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_max_intensity_by_month.tiff'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of northern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Northern boundary of ITCZ',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('latitude',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_upper_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r',fontsize=15)

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymin=np.min((mean_loc_upper_bound_plio,mean_loc_upper_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymin2=np.min((mean_loc_upper_bound_plio-mean_loc_upper_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_upper_bound_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_upper_bound_by_month.tiff'
plt.savefig(fileout)
plt.close()


#####################################
# plot latitude of southern limit


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('Southern boundary of ITCZ',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('latitude',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_loc_lower_bound_plio-mean_loc_lower_bound_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='black',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r',fontsize=15)

# make sure both x and y axis are symetrical about zero
ax2a.set_xlim([1.,12.])

ymax=np.max((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymin=np.min((mean_loc_lower_bound_plio,mean_loc_lower_bound_pi))
ymax=np.max((ymax,np.abs(ymin)))
ymax=np.ceil(ymax)
ymin=ymax * (-1.0)

ymax2=np.max((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymin2=np.min((mean_loc_lower_bound_plio-mean_loc_lower_bound_pi))
ymax2=np.max((ymax2,np.abs(ymin2)))
ymax2=np.ceil(ymax2)
ymin2=ymax2 * (-1.0)
ax1a.set_ylim([ymin,ymax])
ax2a.set_ylim([ymin2,ymax2])
ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')


# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_lower_bound_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/loc_lower_bound_by_month.tiff'
plt.savefig(fileout)
plt.close()


#####################################
# plot median ITCZ position (halfway between northern boundary and southern boundary


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,(mean_loc_upper_bound_plio+mean_loc_lower_bound_plio)/2.0,label='mPWP',color='blue')
ax1a.plot(xvals,(mean_loc_upper_bound_pi+mean_loc_lower_bound_pi)/2.0,label='PI',color='blue',linestyle='dashed')
plt.title('latitude of ITCZ centre',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('latitude',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,(((mean_loc_upper_bound_plio+mean_loc_lower_bound_plio)/2.0)-(mean_loc_upper_bound_pi+mean_loc_lower_bound_pi)/2.0),label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r',fontsize=15)



# set axis limits
ax2a.set_xlim([1.,12.])

ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
if regionname == 'AtlanticOcean':
    location=3
else:
    location=4
ax2a.legend(lines1+lines2,labels1+labels2,loc=location,fontsize=15,framealpha=0.0)

plt.tight_layout()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/median_loc_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/median_loc_by_month.tiff'
plt.savefig(fileout)
plt.close()

#####################################
# plot width of ITCZ


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='PI',color='blue',linestyle='dashed')
plt.title('average width of ITCZ',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('latitude',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio)-(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi),label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('latitude difference',color='r',fontsize=15)



# set axis limits
ax2a.set_xlim([1.,12.])

ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
if regionname == 'AtlanticOcean':
    location=3
else:
    location=4
ax2a.legend(lines1+lines2,labels1+labels2,loc=location,fontsize=15,framealpha=0.0)

plt.tight_layout()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/width_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/width_by_month.tiff'
plt.savefig(fileout)
plt.close()

###############################################################
# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_max_intensity_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_max_intensity_pi,label='PI',color='blue',linestyle='dashed')
plt.title('rain amount at max ITCZ intensity',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('mm/day',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_max_intensity_plio-mean_amt_max_intensity_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r',fontsize=15)

# set axis limits
ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_max_intensity_plio,mean_amt_max_intensity_pi))])

ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/rainfall_max_intensity_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/rainfall_max_intensity_by_month.tiff'
plt.savefig(fileout)
plt.close()

#######################################
# 2. mean amount of rain in mm/day
# not sure about plotting this does it mean anything


fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,mean_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,mean_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('mean ITCZ intensity',fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('mm/day',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,mean_amt_itcz_plio-mean_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('mm/day',color='r',fontsize=15)

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((mean_amt_itcz_plio,mean_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/mean_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/mean_rainfall_ITCZ_by_month.tiff'
plt.savefig(fileout)
plt.close()

# 3. total amount of rain in kg



fig, ax1a =plt.subplots()  
xvals=np.arange(1,13,1,dtype=int)
ax1a.plot(xvals,total_amt_itcz_plio,label='mPWP',color='blue')
ax1a.plot(xvals,total_amt_itcz_pi,label='PI',color='blue',linestyle='dashed')
plt.title('total ITCZ rainfall in '+regionname,fontsize=20)
ax1a.set_xlabel('month number',fontsize=15)
ax1a.set_ylabel('kg',color='blue',fontsize=15)
ax2a=ax1a.twinx()
ax2a.plot(xvals,total_amt_itcz_plio-total_amt_itcz_pi,label='mPWP-PI',color='r')
ax2a.plot([0,12],[0,0],color='red',linestyle='dotted') # line at equator
ax2a.set_ylabel('kg',color='r',fontsize=15)

# set axis limits

ax2a.set_xlim([1.,12.])
ax1a.set_ylim([0.,np.max((total_amt_itcz_plio,total_amt_itcz_pi))])

ax1a.tick_params(axis='y',colors='blue',labelsize=15)
ax2a.tick_params(axis='y',colors='r',labelsize=15)
ax1a.tick_params(axis='x',labelsize=15)
ax1a.spines['left'].set_color('blue')
ax2a.spines['right'].set_color('r')



# ask matplot lib for the plotted objects and their labels
lines1,labels1=ax1a.get_legend_handles_labels()
lines2,labels2=ax2a.get_legend_handles_labels()
ax2a.legend(lines1+lines2,labels1+labels2,loc=4,fontsize=15,framealpha=0.0)

plt.tight_layout()
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/total_rainfall_ITCZ_by_month.eps'
plt.savefig(fileout)
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/'+regionname+'/total_rainfall_ITCZ_by_month.tiff'
plt.savefig(fileout)
plt.close()


sys.exit()
####

::::::::::::::
ITCZ_southern_branch_diagnostics_old.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program is based on ITCZ_diagnostics.py (described below)
#    However it will try and find the southern branch so instead of using 
#    2S-21N we will use 30S-2N
#    have also changed threshold to 6 for all months
#
#    ORIGINAL description
#    This program will find the ITCZ in the North Pacific using the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia May 2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=170.0,urcrnrlon=260.0,llcrnrlat=-30.0,urcrnrlat=5.0,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold):
#  to find the ITCZ we find precipitation in a box  2N-21S 180W-110 W.
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

    # decompose grid to 180W-110W (180E-250E) 2S-21N

    nlon=0
    nlat=0
    lat_first=0
    lon_first=0

    for i in range (0,len(lon)):
        if 180 <= lon[i] <= 250:
            nlon=nlon+1
            if lon_first==0:
                lon_first=i


    for j in range (0,len(lat)):
        if -30.0 <= lat[j] <= 2:
            nlat=nlat+1
            if lat_first==0:
                lat_first=j


    print(lat_first,lon_first)
    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    for i in range(0,len(lon)):
        if 180<= lon[i] < 250:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(0,len(lat)):
              if -30.0 <= lat[j] <= 2:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]

    

    

    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_index=np.zeros(len(AOI_lon),dtype=int)
    lower_bound_index=np.zeros(len(AOI_lon),dtype=int)
    most_intense_precip_index=np.zeros(len(AOI_lon),dtype=int)

    upper_bound_index[:]=np.nan
    lower_bound_index[:]=np.nan
    most_intense_precip_index[:]=np.nan


    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        for j in range(len(AOI_lat)-1,0,-1):
            if AOI_precip[j,i] >= threshold: # check greater then threshold
                count_lons=count_lons+1
                if count_lons > max_count_lons[i]: # set up maximum
                    max_count_lons[i]=count_lons
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
          
        if max_count_lons[i]==0:
            lower_bound_index[i]=-9999
            upper_bound_index[i]=-9999
            most_intense_precip_index[i]=-9999
        else:
            upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1
        #print(AOI_lon[i],i,upper_bound_index[i],lower_bound_index[i],max_count_lons[i])
        #print(AOI_lat[upper_bound_index[i]],AOI_lat[lower_bound_index[i]])
        #for j in range(0,len(AOI_lat)):
        #          print(AOI_lat[j],AOI_precip[j,i])
        #sys.exit()

    #area of interest check 

    titlename=exptname+' '+monthname
    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b')


    # overplot location of itcz but must reduce arrays to account for
    # missing data
    nredu=sum(float(num) >=0 for num in lower_bound_index)
    print('nredu',nredu)
    AOI_lon_redu=np.zeros(nredu,dtype=int)
    upper_bound_index_redu=np.zeros(nredu,dtype=int)
    lower_bound_index_redu=np.zeros(nredu,dtype=int)
    most_intense_precip_index_redu=np.zeros(nredu,dtype=int)
    
    count=0
    for i in range(0,len(AOI_lon)):
        if upper_bound_index[i]>=0:
            AOI_lon_redu[count]=AOI_lon[i]
            upper_bound_index_redu[count]=upper_bound_index[i]
            lower_bound_index_redu[count]=lower_bound_index[i]
            most_intense_precip_index_redu[count]=most_intense_precip_index[i]
            count=count+1
    
    print('upper',upper_bound_index_redu)
    print('lower',lower_bound_index_redu)
    print('upper full',upper_bound_index)
    print('lower full',lower_bound_index)
    plt.plot(AOI_lon_redu,AOI_lat[upper_bound_index_redu],color='orange',linewidth=3)
    plt.plot(AOI_lon_redu,AOI_lat[lower_bound_index_redu],color='red',linewidth=3)
    plt.plot(AOI_lon_redu,AOI_lat[most_intense_precip_index_redu],color='white',linewidth=3)

    # overplot lower and upper bounds
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/map_south_'+exptname+'_'+monthname+'.eps'
    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        if most_intense_precip_index[i]>=0:
            max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
            weightamt=0.
            for j in range(lower_bound_index[i],upper_bound_index[i]+1):
                mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
                weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
                total_AOI_precip[i]=(total_AOI_precip[i]+
                  AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
            mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

   
    retdata=[AOI_lon,max_AOI_precip,mean_AOI_precip,total_AOI_precip]
    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']


threshold=np.zeros(12,dtype=float)
threshold[0]=4.
threshold[1]=4.
threshold[2]=4.
threshold[3]=4.
threshold[4]=6.
threshold[5]=6.
threshold[6]=6.
threshold[7]=6.
threshold[8]=6.
threshold[9]=6.
threshold[10]=6.
threshold[11]=6.
threshold[:]=6  # have changed threshold to 6

# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i])
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_amt_pi[i,:]=ITCZ_data[1]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[2]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[3]

   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i])
    max_intensity_amt_plio[i,:]=ITCZ_data[1]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[2]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[3]



# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.mean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.mean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.mean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.mean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.mean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.mean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.mean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.mean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.mean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.mean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.sum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.sum(total_itcz_precip_amt_pi[mon,:])

plt.subplot(2,2,1)  
plt.plot(mean_loc_max_intensity_plio,label='plio')
plt.plot(mean_loc_max_intensity_pi,label='pi')
plt.title('lat maximum ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,2)  
plt.plot(mean_loc_upper_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi,label='pi')
plt.title('north lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,4)  
plt.plot(mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_lower_bound_pi,label='pi')
plt.title('south lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()

plt.subplot(2,2,3)  
plt.plot(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='pi')
plt.title('width of ITCZ')
plt.xlabel('month number')
plt.ylabel('degrees')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/avg_loc_by_month_south.eps'
plt.savefig(fileout)
plt.close()


# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.

plt.subplot(2,2,1)  
plt.plot(mean_amt_max_intensity_plio,label='plio')
plt.plot(mean_amt_max_intensity_pi,label='pi')
plt.title('rain amt at max ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 2. mean amount of rain in mm/day

plt.subplot(2,2,2)  
plt.plot(mean_amt_itcz_plio,label='plio')
plt.plot(mean_amt_itcz_pi,label='pi')
plt.title('mean itcz precip')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 3. total amount of rain in kg

plt.subplot(2,2,3)  
plt.plot(total_amt_itcz_plio/1.0E12,label='plio')
plt.plot(total_amt_itcz_pi/1.0E12,label='pi')
plt.title('total itcz precip')
plt.xlabel('month number')
plt.ylabel('kg (x 10^12)')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/rain_amt_by_month_south.eps'
plt.savefig(fileout)
plt.close()


sys.exit()
####

::::::::::::::
ITCZ_southern_branch_diagnostics.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    ITCZ diagnostics
#PURPOSESS
#    This program is based on ITCZ_diagnostics.py (described below)
#    However it will try and find the southern branch so instead of using 
#    2S-21N we will use 25S-2N
#    have also changed threshold to 6 for all months
#
#    ORIGINAL description
#    This program will find the ITCZ in the North Pacific using the 
#    Stanfield et al 2015 definition.  It will find the centerline width 
#    and intensity and plot these by season for the Pliocene and the PI.
#
# search for 'main program' to find end of functions
# Julia May 2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,land_ocn_ind):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:        plt.subplot(2,2,fileno+1)


    if land_ocn_ind == 'l':
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=170.0,urcrnrlon=260.0,llcrnrlat=-30.0,urcrnrlat=5.0,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if land_ocn_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata

def find_ITCZ(exptname,extra,monthname,threshold):
#  to find the ITCZ we find precipitation in a box  2N-21S 180W-110 W.
#  we then find the longest continuous stretch of precipitation above a certain
#  threshold for each longitude.  The monthly thresholds are 4mm/day from 
#  January to April and 6mm/day from May-December

   # read in data from multiple files and calculate average precipitation
   # in mm/day

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname+'a@pd'+extra+'[5-9]?'+monthname+'_precip.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    avg_precip=np.mean(aprecip,axis=0)
    avg_precip=avg_precip * 60. * 60. * 24. 

    # decompose grid to 180W-110W (180E-250E) 2S-21N

    nlon=0
    nlat=0
    lat_first=0
    lon_first=0

    for i in range (0,len(lon)):
        if 180 <= lon[i] <= 250:
            nlon=nlon+1
            if lon_first==0:
                lon_first=i


    for j in range (0,len(lat)):
        if -25.0 <= lat[j] <= 2:
            nlat=nlat+1
            if lat_first==0:
                lat_first=j


    print(lat_first,lon_first)
    AOI_precip=np.zeros((nlat,nlon))
    AOI_lon=np.zeros(nlon)
    AOI_lat=np.zeros(nlat)


    for i in range(0,len(lon)):
        if 180<= lon[i] < 250:
          AOI_lon[i-lon_first]=lon[i]
          for j in range(0,len(lat)):
              if -25.0 <= lat[j] <= 2:
                  if i==lon_first:
                      AOI_lat[j-lat_first]=lat[j]
                  AOI_precip[j-lat_first,i-lon_first]=avg_precip[j,i]

    

    

    # for each longitude find the longest continuous band of precipitation 
    # above the threshold


    max_count_lons=np.zeros(len(AOI_lon),dtype=int)
    upper_bound_latitude=np.empty(len(AOI_lon),dtype=float)
    lower_bound_latitude=np.empty(len(AOI_lon),dtype=float)
    upper_bound_index=np.empty(len(AOI_lon),dtype=int)
    lower_bound_index=np.empty(len(AOI_lon),dtype=int)
    most_intense_precip_latitude=np.empty(len(AOI_lon),dtype=float)
    most_intense_precip_index=np.empty(len(AOI_lon),dtype=int)

    upper_bound_latitude[:]=np.nan
    lower_bound_latitude[:]=np.nan
    most_intense_precip_latitude[:]=np.nan

    latres=AOI_lat[1]-AOI_lat[0]
    for i in range(0,len(AOI_lon)):
        count_lons=0
        max_val=0
        for j in range(len(AOI_lat)-1,0,-1):
            if AOI_precip[j,i] >= threshold: # check greater then threshold
                count_lons=count_lons+1
                if count_lons > max_count_lons[i]: # set up maximum
                    max_count_lons[i]=count_lons
                    lower_bound_latitude[i]=AOI_lat[j]
                    lower_bound_index[i]=j
                    if AOI_precip[j,i] > max_val: # find most intense precip
                                                  #in north itcz
                        max_val=AOI_precip[j,i]
                        most_intense_precip_latitude[i]=AOI_lat[j]
                        most_intense_precip_index[i]=j
         
            else:
                count_lons=0
          
        upper_bound_latitude[i]=lower_bound_latitude[i]+(
            (max_count_lons[i]-1)*latres)
        upper_bound_index[i]=lower_bound_index[i]+max_count_lons[i]-1

        #print(AOI_lon[i],i,upper_bound_latitude[i],lower_bound_latitude[i],max_count_lons[i],most_intense_precip_latitude[i])
        #for j in range(0,len(AOI_lat)):
        #          print(AOI_lat[j],AOI_precip[j,i])
        #sys.exit()

    #area of interest check 

    titlename=exptname+' '+monthname
    plotdata(AOI_precip,99,AOI_lon,AOI_lat,titlename,0.0,10.0,0.5,0,'n','mm/day','b')


    plt.plot(AOI_lon,upper_bound_latitude,color='orange',linewidth=3)
    plt.plot(AOI_lon,lower_bound_latitude,color='red',linewidth=3)
    plt.plot(AOI_lon,most_intense_precip_latitude,color='white',linewidth=3)

    # overplot lower and upper bounds
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/map_south_'+exptname+'_'+monthname+'.eps'
    plt.savefig(fileout)
    plt.close()


    lon_res=AOI_lon[1]-AOI_lon[0]
    lat_res=AOI_lat[1]-AOI_lat[0]
   
    max_AOI_precip=np.zeros(len(AOI_lon))
    mean_AOI_precip=np.zeros(len(AOI_lon)) # in mm/day (kg/m2/day)
    total_AOI_precip=np.zeros(len(AOI_lon)) # in kg/day (so we need to multiply by area of gridbox)
    for i in range(0,len(AOI_lon)):
        if most_intense_precip_latitude[i]>=-90:  # hopefully false for nan
            max_AOI_precip[i]=AOI_precip[most_intense_precip_index[i],i]
            weightamt=0.
            for j in range(lower_bound_index[i],upper_bound_index[i]+1):
                mean_AOI_precip[i]=(mean_AOI_precip[i]+
                      AOI_precip[j,i]*np.cos(np.radians(AOI_lat[j])))
                weightamt=weightamt + np.cos(np.radians(AOI_lat[j]))
                total_AOI_precip[i]=(total_AOI_precip[i]+
                  AOI_precip[j,i]*111000.*lon_res*np.cos(np.radians(AOI_lat[j]))
                              *111000.*lat_res)
            
            mean_AOI_precip[i]=mean_AOI_precip[i] / weightamt

   
    retdata=[AOI_lon,most_intense_precip_latitude,upper_bound_latitude,lower_bound_latitude,max_AOI_precip,mean_AOI_precip,total_AOI_precip]
    return retdata


#end def find_ITCZ


     


#end def seasmean

################################
# main program

monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']


threshold=np.zeros(12,dtype=float)
threshold[0]=4.
threshold[1]=4.
threshold[2]=4.
threshold[3]=4.
threshold[4]=6.
threshold[5]=6.
threshold[6]=6.
threshold[7]=6.
threshold[8]=6.
threshold[9]=6.
threshold[10]=6.
threshold[11]=6.
threshold[:]=6  # have changed threshold to 6

# get data for all months
for i in range(0,len(monthnames)):
 
    ITCZ_data=find_ITCZ('xkvje','n',monthnames[i],threshold[i])
    if i == 0:
        AOI_lon=ITCZ_data[0]
        # location of rainfall arrays
        max_intensity_lat_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_lat_plio=np.zeros((12,len(AOI_lon)))
        upper_bound_pi=np.zeros((12,len(AOI_lon)))
        upper_bound_plio=np.zeros((12,len(AOI_lon)))
        lower_bound_pi=np.zeros((12,len(AOI_lon)))
        lower_bound_plio=np.zeros((12,len(AOI_lon)))
        # amount of rainfall arrays
        max_intensity_amt_pi=np.zeros((12,len(AOI_lon)))
        max_intensity_amt_plio=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        mean_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_pi=np.zeros((12,len(AOI_lon)))
        total_itcz_precip_amt_plio=np.zeros((12,len(AOI_lon)))
    max_intensity_lat_pi[i,:]=ITCZ_data[1]
    upper_bound_pi[i,:]=ITCZ_data[2]
    lower_bound_pi[i,:]=ITCZ_data[3]
    max_intensity_amt_pi[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_pi[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_pi[i,:]=ITCZ_data[6]

  
   
    ITCZ_data=find_ITCZ('xkvjg','n',monthnames[i],threshold[i])
    max_intensity_lat_plio[i,:]=ITCZ_data[1]
    upper_bound_plio[i,:]=ITCZ_data[2]
    lower_bound_plio[i,:]=ITCZ_data[3]
    max_intensity_amt_plio[i,:]=ITCZ_data[4]
    mean_itcz_precip_amt_plio[i,:]=ITCZ_data[5]
    total_itcz_precip_amt_plio[i,:]=ITCZ_data[6]

# plot the maximum intensity latitude for each longitude for pliocene
# and preindustrial for each month

for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,max_intensity_lat_pi[i,:],label='pi')
   plt.plot(AOI_lon,max_intensity_lat_plio[i,:],label='plio')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/max_intensity_south.eps'
plt.savefig(fileout)
plt.close()


 # plot upper range and lower range.
for i in range(0,len(monthnames)):
   plt.subplot(3,4,i+1)
   plt.plot(AOI_lon,upper_bound_pi[i,:],label='pi_upper')
   plt.plot(AOI_lon,lower_bound_pi[i,:],label='pi_lower')
   plt.plot(AOI_lon,upper_bound_plio[i,:],label='plio_upper')
   plt.plot(AOI_lon,lower_bound_plio[i,:],label='plio_lower')
   if i == len(monthnames)-1:
       plt.legend()
   titlename=monthnames[i]
   plt.title(titlename)
    
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/bound_range_south.eps'
plt.savefig(fileout)
plt.close()
 

# plot some averages over area by month

mean_loc_max_intensity_plio=np.zeros(len(monthnames))
mean_loc_max_intensity_pi=np.zeros(len(monthnames))
mean_loc_upper_bound_plio=np.zeros(len(monthnames))
mean_loc_upper_bound_pi=np.zeros(len(monthnames))
mean_loc_lower_bound_plio=np.zeros(len(monthnames))
mean_loc_lower_bound_pi=np.zeros(len(monthnames))
mean_amt_max_intensity_plio=np.zeros(len(monthnames))
mean_amt_max_intensity_pi=np.zeros(len(monthnames))
mean_amt_itcz_plio=np.zeros(len(monthnames))
mean_amt_itcz_pi=np.zeros(len(monthnames))
total_amt_itcz_plio=np.zeros(len(monthnames))
total_amt_itcz_pi=np.zeros(len(monthnames))
for mon in range(0,len(monthnames)):
    mean_loc_max_intensity_plio[mon]=np.nanmean(max_intensity_lat_plio[mon,:])
    mean_loc_max_intensity_pi[mon]=np.nanmean(max_intensity_lat_pi[mon,:])
    mean_loc_upper_bound_plio[mon]=np.nanmean(upper_bound_plio[mon,:])
    mean_loc_upper_bound_pi[mon]=np.nanmean(upper_bound_pi[mon,:])
    mean_loc_lower_bound_plio[mon]=np.nanmean(lower_bound_plio[mon,:])
    mean_loc_lower_bound_pi[mon]=np.nanmean(lower_bound_pi[mon,:])
    mean_amt_max_intensity_plio[mon]=np.nanmean(max_intensity_amt_plio[mon,:])
    mean_amt_max_intensity_pi[mon]=np.nanmean(max_intensity_amt_pi[mon,:])
    mean_amt_itcz_plio[mon]=np.nanmean(mean_itcz_precip_amt_plio[mon,:])
    mean_amt_itcz_pi[mon]=np.nanmean(mean_itcz_precip_amt_pi[mon,:])
    total_amt_itcz_plio[mon]=np.nansum(total_itcz_precip_amt_plio[mon,:])
    total_amt_itcz_pi[mon]=np.nansum(total_itcz_precip_amt_pi[mon,:])

plt.subplot(2,2,1)  
plt.plot(mean_loc_max_intensity_plio,label='plio')
plt.plot(mean_loc_max_intensity_pi,label='pi')
plt.title('lat maximum ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,2)  
plt.plot(mean_loc_upper_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi,label='pi')
plt.title('north lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()


plt.subplot(2,2,4)  
plt.plot(mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_lower_bound_pi,label='pi')
plt.title('south lat of ITCZ')
plt.xlabel('month number')
plt.ylabel('latitude')
plt.legend()

plt.subplot(2,2,3)  
plt.plot(mean_loc_upper_bound_plio-mean_loc_lower_bound_plio,label='plio')
plt.plot(mean_loc_upper_bound_pi-mean_loc_lower_bound_pi,label='pi')
plt.title('width of ITCZ')
plt.xlabel('month number')
plt.ylabel('degrees')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/avg_loc_by_month_south.eps'
plt.savefig(fileout)
plt.close()


# we will now plot intensity by month.
# 1. average amount of rain at the location of maximum intensity.

plt.subplot(2,2,1)  
plt.plot(mean_amt_max_intensity_plio,label='plio')
plt.plot(mean_amt_max_intensity_pi,label='pi')
plt.title('rain amt at max ITCZ intensity')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 2. mean amount of rain in mm/day

plt.subplot(2,2,2)  
plt.plot(mean_amt_itcz_plio,label='plio')
plt.plot(mean_amt_itcz_pi,label='pi')
plt.title('mean itcz precip')
plt.xlabel('month number')
plt.ylabel('mm/day')
plt.legend()

# 3. total amount of rain in kg

plt.subplot(2,2,3)  
plt.plot(total_amt_itcz_plio/1.0E12,label='plio')
plt.plot(total_amt_itcz_pi/1.0E12,label='pi')
plt.title('total itcz precip')
plt.xlabel('month number')
plt.ylabel('kg (x 10^12)')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/ITCZ/rain_amt_by_month_south.eps'
plt.savefig(fileout)
plt.close()


sys.exit()
####

::::::::::::::
plot_Arctic_Osc.py
::::::::::::::
#all!/usr/bin/env python2.7
#NAME
#    PLOT_Arctic_Osc
#PURPOSE
#    This program will attempt to use principal component analysis to 
#    calculate the arctic oscillation (Northern Annular Mode) and
#    its  associated teleconnections
#
#    It is very strongly based on plot_NAO.py
#
# search for 'main program' to find end of functions
# Julia 6/1/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from  matplotlib.mlab import PCA 
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot AO index on a line graph
#  def fullprint  print full array for debugging
#  get_PC_allmonths   gets principal components and plots them (all data)
#  get_pc_seas  gets principal components for a given season

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(x),np.shape(y),np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

#===============================================================
def plotquiver(udata,vdata,lon,lat,fileno,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver



def indexplot(toplot,fileno,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt):
    plt.subplot(2,2,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    datasize=len(toplot)
    xdata=np.arange(datasize)
    
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='AO index '+expt
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint



#===============================================
def get_PC_allmonths(exptname):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E


    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    full_file_paths =  glob.glob("*a@pd*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    ntimes=nfiles
    if nfiles==0:
        print('there are no files in directory',dirname)
        sys.exit(0)


    # get the information from the files
    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

        mslp=f.variables['p'][:] 
        mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

        lon=lontemp
        mslp,lon = shiftgrid(180.,mslp,lon,start=False)

        ix1=lon
        ix2=(lat >=20) & (lat <=80)
        lats_reg=lat[ix2]
        lons_reg=lat[ix1]
        
        SLPint=mslp[ix2]
        MSLP=SLPint[:,ix1]

        MSLP=np.squeeze(MSLP)
        MSLP=MSLP/100. # convert to millibars
        
        latsize=len(lats_reg)
        lonsize=len(lons_reg)
        

        if count == 0:  # arrays for storing all data
           all_MSLP = np.empty((ntimes,latsize,lonsize)) #storing all data
           month_ss = np.zeros(ntimes)  # month indicator for all_MSLP
           month_MSLP=np.zeros((12,latsize,lonsize)) # for storing average month
           monthcount=np.zeros(12) # no of years for each month
 

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        if count == 0:
            yearstart=year
            monthstart=11 # assumed first month is december.  Will need
                          # to recode if not the case

        time=((year-yearstart)*12)+monthno-monthstart
        all_MSLP[time,:,:]=MSLP
        month_ss[time]=monthno
        month_MSLP[monthno,:,:]=month_MSLP[monthno,:,:]+MSLP
        monthcount[monthno]=monthcount[monthno]+1
        count=count+1


    # get all the averages
 
    # average annual cycle
    month_MSLP=month_MSLP/monthcount[:,np.newaxis,np.newaxis]


    # remove annual average from all_MSLP
    for t in range(0,ntimes):
        subscript=month_ss[t]
        all_MSLP[t,:,:]=all_MSLP[t,:,:]-month_MSLP[subscript,:,:]
    # subtract mean from each point
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))

    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lon_reg,lat_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lons,latsize*lonsize)

    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs))
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)

    #if EOFs[j,0] < 0.0:

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC v2 '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    plt.show()
    


#===============================================
def get_PC_seas(exptname,monthnames,extra,startyear,endyear):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E

    nmonths=len(monthnames)
    seasname=''  # get seasonname by using first letter of each month
    for mon in monthnames:
        seasname=seasname+mon[0]

    if nmonths > 4:
        print('check that you have accurately accounted for winter season overlap')
        sys.exit()

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    for year in range (startyear,endyear+1):
        for monthno in range (0,nmonths):
            yearuse=year
            extrause=extra
            month=monthnames[monthno]
            if month == 'dc' and nmonths > 1:
                yearuse=year-1
            if month == 'nv' and nmonths > 2:
                yearuse=year-1
            if month == 'ot' and nmonths > 3:
                yearuse=year-1
            if month == 'sp' and nmonths > 4:
                yearuse=year-1
            if yearuse >= 100:
                yearuse=yearuse-100
                extrause=chr(ord(extra)+1)

            if yearuse < 0:
                yearuse=yearuse+100
                extrause=chr(ord(extra)-1)

            yearfname=str(yearuse)

            if yearuse < 10:
                yearfname='0'+str(yearuse)

            fname=dirname+exptname+'a@pd'+extrause+yearfname+month+'_mslp.nc'
            print(fname)
            f=Dataset(fname,mode='r')
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

            mslp=f.variables['p'][:] 
            mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp north of 20N

            lon=lontemp
            mslp,lon = shiftgrid(180.,mslp,lon,start=False)

            ix2=(lat >=20)
            ix1=(lon > -1000)  # use all lons
            lats_reg=lat[ix2]
            lons_reg=lon
            
            SLPint=mslp[ix2]
            MSLP=SLPint[:,ix1]
            
            MSLP=np.squeeze(MSLP)
            MSLP=MSLP/100. # convert to millibars
 
            latsize=len(lats_reg)
            lonsize=len(lons_reg)
            
            if year == startyear and monthno == 0:  # arrays to store all data
                all_MSLP = np.zeros((ntimes,latsize,lonsize)) 
                

            all_MSLP[year-startyear,:,:]=all_MSLP[year-startyear,:,:]+MSLP
            # this is the end of the loop over years and months

           
           
    
    all_MSLP=all_MSLP/nmonths
   
    # remove average from MSLP
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    #plotdata(all_MSLP[0,:,:],0,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))


    #plotdata(all_MSLP[0,:,:],1,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')
    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lons_reg,lats_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lats,latsize*lonsize)

    rs_MSLP=np.transpose(rs_MSLP_nt)


    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs)) 
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)
    # check EOF1 has low (negative pressure over Iceland)
    lons,lats 
    ixuse=(lons == -18.75) & (lats == 65.)
    
    if EOFs[ixuse,0] >= 0:
        EOFs[:,0]=EOFs[:,0] * -1.0

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC'+str(i+1)+':'+exptname+'_'+seasname+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

#   write out the AO index to a file
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.txt' 
    f1=open(fileout,'w+')
    f1.write('nino index from PC1 of mslp in North Atlantic region \n')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra  year  AO index\n')
    for year in range (startyear,endyear+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-startyear,0])+'\n')
    f1.close()
        

#=========================================
def get_AO_seas_telecon(exptname,seasname,extra,startyear,endyear,monthnames,latname,lonname,fieldname,fieldlocation,fileext):
# this will plot the teleconnections associated with the AO by taking the
# most exteme 5% of the AO years and plotting the climate anomaly


    # read in the AO index

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.txt' 
    f=open(filein,'r')
    # discard titleline
    textline=f.readline()
    # get number of years from next line
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    c=b[0]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()



    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    AOindex=np.zeros(nyears)
    extremeindex=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and AOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        AOindex[count]=linesplit[2]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowdata=sorted(zip(AOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(AOindex,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)
    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+fieldlocation
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
         
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()

        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1


    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    lowdata=sorted(zip(AOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(AOindex,extraindex,yearindex),reverse=True)[:num_extr]

    # lowest and highest years
    for ex in range(0,2):
        # are we doing highest or lowest
        if ex == 0:
            extremedata=lowdata
        if ex == 1:
            extremedata=uppdata

        for time in range (0,num_extr):
            for monthno in range (0,nmonths):
                singleline=extremedata[time]
                yearuse=int(singleline[2])
                extrause=singleline[1]
                month=monthnames[monthno]
                if month == 'dc' and nmonths > 1:
                    yearuse=yearuse-1
                if month == 'nv' and nmonths > 2:
                    yearuse=yearuse-1
                if month == 'ot' and nmonths > 3:
                    yearuse=yearuse-1
                if month == 'sp' and nmonths > 4:
                    yearuse=yearuse-1
                if yearuse >= 100:
                    yearuse=yearuse-100
                    extrause=chr(ord(extrause)+1)
                                    
                if yearuse < 0:
                    yearuse=yearuse+100
                    extrause=chr(ord(extrause)-1)
                                        
                yearfname=str(yearuse)

                if yearuse < 10:
                    yearfname='0'+str(yearuse)

                fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                f=Dataset(fname,mode='r')
                lat = f.variables[latname][:]
                latsize=len(lat)
                lon = f.variables[lonname][:]
                lonsize=len(lon)
                lontemp=lon

                if len(fieldname) ==1 :
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)

                if len(fieldname) == 2:
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)
                    atemp2=f.variables[fieldname[1]][:]
                    atemp2=np.squeeze(atemp2)
        
                if len(fieldname) > 2:
                    print('you are requesting too many variables')
                    sys.exit()
    

                # set array for storing average
                if monthno == 0 and time == 0:
                    temp_extreme=atemp
                    temp2_extreme=0.
                    if len(fieldname)==2:
                        temp2_extreme=atemp2
                    count=1
                else:
                    temp_extreme=temp_extreme+atemp
                    if len(fieldname)==2:
                        temp2_extreme=temp2_extreme+atemp2
                    count=count+1

        # put temperature data in lower or higher catogry
        if ex == 0:
            temp_low=temp_extreme/count
            temp2_low=temp2_extreme/count
        if ex == 1:
            temp_high=temp_extreme/count
            temp2_high=temp2_extreme/count


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low,lon = shiftgrid(180.,temp_low,lon,start=False)    
    lon=lontemp
    temp_high,lon = shiftgrid(180.,temp_high,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    
    

    if fieldname[0] == 'temp_1':  # temperature data
        titlename=exptname+' low seas temp'
        plotdata(temp_low-273.15,0,lon,lat,titlename,-40.0,40.0,10.0,0,'n','degC')
        plotdata(temp_high-273.15,1,lon,lat,'high seas temp',-40.0,40.0,10.0,0,'n','degC')

        plotdata(temp_low-temp_avg,2,lon,lat,'low seas Tanom',-5.0,6.0,1.0,0,'n','degC')
        plotdata(temp_high-temp_avg,3,lon,lat,'high seas Tanom',-5.0,6.0,1.0,0,'n','degC')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_temp'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotdata(temp_low*60.*60.*24.*30.,0,lon,lat,titlename,-0,275,25,0,'n','mm/month')
        plotdata(temp_high*60.*60.*24.*30.,1,lon,lat,'high seas temp',0,275,25,0,'n','mm/month')

        plotdata((temp_low-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low seas panom',-50,50,15,0,'n','mm/month')
        plotdata((temp_high-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high seas panom',-50,50,10,0,'n','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
        # if precip also do percentage change
        pcent_low=((temp_low-temp_avg)/temp_avg)*100.
        pcent_high=((temp_high-temp_avg)/temp_avg)*100.
        titlename=exptname+' low seas precip anom'
        plotdata(pcent_low,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotdata(pcent_high,1,lon,lat,'high seas Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'p': # mean slp data
        titlename=exptname+' low seas mslp'
        plotdata(temp_low/100.,0,lon,lat,titlename,980,1040,10.0,0,'n','mbar')
        plotdata(temp_high/100.,1,lon,lat,'high seas mslp',980,1040,10.0,0,'n','mbar')

        plotdata((temp_low-temp_avg)/100.,2,lon,lat,'low seas mslp',-5.0,6.0,1.0,0,'n','mbar')
        plotdata((temp_high-temp_avg)/100.,3,lon,lat,'high seas mslp',-5.0,6.0,1.0,0,'n','mbar')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_mslp'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
        

################################
# main program

figureno=0

#==================================
# get annual PC

#get_PC_allmonths('xkvjc')


#=================================
# get seasonal PC
monthnames=['dc','ja','fb','mr']
get_PC_seas('xkvje',monthnames,'n',1,100)
get_PC_seas('xkvjf',monthnames,'n',1,100)
get_PC_seas('xkvjg',monthnames,'n',1,100)



#=====================================
# get seasonal teleconnections

monthnames=['dc','ja','fb','mr']
seasname='djfm'
# note monthnames is the month of the climate variable, seasonnames is the 
# season that the AO index is calculated over

# temperature
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')

# winds
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')


# precipitation
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')

# mslp
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')


sys.exit(0)

####

::::::::::::::
plot_cross_eq_heat_transport.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_cross_eq_heat_transport.py
#PURPOSE
#    This program is wanting to find out more about the movement of the 
#    ITCZ and so initially wants to find out whether the NH is warming more
#    than the southern hemisphere, or vice versa.  It will then look at the 
#    cross equatorial heat transport
#
# search for 'main program' to find end of functions
# Julia 1/11/2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal",)

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

#######################################################
def interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,regionname,lonmin,lonmax):
# this will get the interhemispheric temperature differences by month
# for a given longitudinal range

    #==============
    # get all data

    if HadCM3 == 'y':
        filestart_pi='/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pd'+extra+'[7-9]*'
        filestart_plio='/nfs/hera1/earjcti/um/netcdf/'+mPWP_expt+'_netcdf/'+mPWP_expt+'a@pd'+extra+'[7-9]*'
        fieldname='temp'
        suffix='.nc'
    else:
        filestart_pi='/nfs/hera1/earjcti/um/HadGEM_data/'+pi_expt+'/temp_data/'+pi_expt+'a@pd'+extra+'[7-9]*'
        filestart_plio='/nfs/hera1/earjcti/um/HadGEM_data/'+mPWP_expt+'/temp_data/'+mPWP_expt+'a@pd'+extra+'[7-9]*'
        fieldname='temp_1'
        suffix='_temp.nc'

    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    nmon=len(monthnames)

    for month in range(0,nmon):
        # get preindustrial data (average monthly temperature over globe)
        f=MFDataset(filestart_pi+monthnames[month]+suffix)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables[fieldname][:]
        atemp=np.squeeze(atemp)
        temp_avg=np.mean(atemp,axis=0)
        ny,nx=np.shape(temp_avg)

        # shiftgrid if required
        if lonmin < 0 and lonmax > 0:
            temp_avg,lon=shiftgrid(180.,temp_avg,lon,start=False)

        if month==0:
            # find the number of longitudes
            nx_redu=0
            lonstart=999
            for x in range(0,len(lon)):
                if lon[x] >=lonmin and lon[x] <=lonmax:
                    nx_redu=nx_redu+1
                    if lonstart > 900:
                        lonstart=x
            temp_pi=np.zeros((nmon,ny,nx_redu))
            lonredu=np.zeros(nx_redu)

            
        for x in range(0,nx_redu):
            temp_pi[month,:,x]=temp_avg[:,x+lonstart]
            lonredu[x]=lon[x+lonstart]

        if month == 0:
            print(lonmin,lonmax)
            plotdata(temp_pi[0,:,:],0,lonredu,lat,'region',270,300,5.0,0.0,'n',regionname)
            plt.show()

    
        # get mPWP data (average monthly temperature over globe)
        f=MFDataset(filestart_plio+monthnames[month]+suffix)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables[fieldname][:]
        atemp=np.squeeze(atemp)
        temp_avg=np.mean(atemp,axis=0)
        ny,nx=np.shape(temp_avg)

        # shiftgrid if required
        if lonmin < 0 and lonmax > 0:
            temp_avg,lon=shiftgrid(180.,temp_avg,lon,start=False)

        if month==0:
            temp_plio=np.zeros((nmon,ny,nx_redu))
        for x in range(0,nx_redu):
            temp_plio[month,:,x]=temp_avg[:,x+lonstart]
            lonredu[x]=lon[x+lonstart]
    

    ###########################################################
    # get the average interhemispheric temperature difference

    # create weighting array for the NH and the SH
    nh_weights=np.zeros((ny,nx_redu))
    sh_weights=np.zeros((ny,nx_redu))
   
    for i in range(0,nx_redu):
        nh_weights[:,i]=np.cos(np.deg2rad(lat))
        sh_weights[:,i]=np.cos(np.deg2rad(lat))

    for j in range(0,ny):
        if lat[j] < 0:
            nh_weights[j,:]=0.0
        if lat[j] > 0:
            sh_weights[j,:]=0.0

    nh_plio=np.zeros(nmon)
    nh_pi=np.zeros(nmon)
    sh_plio=np.zeros(nmon)
    sh_pi=np.zeros(nmon)

    for mon in range(0,nmon):
        nh_plio[mon]=np.average(temp_plio[mon,:,:],weights=nh_weights)
        nh_pi[mon]=np.average(temp_pi[mon,:,:],weights=nh_weights)
        sh_plio[mon]=np.average(temp_plio[mon,:,:],weights=sh_weights)
        sh_pi[mon]=np.average(temp_pi[mon,:,:],weights=sh_weights)
                        

    plt.subplot(3,1,1)
    plt.plot(nh_plio,label='nh_plio')
    plt.plot(sh_plio,label='sh_plio')
    plt.plot(nh_pi,label='nh_pi')
    plt.plot(sh_pi,label='sh_pi')
    plt.title(regionname)
    plt.legend()
    
    plt.subplot(3,1,2)
    plt.plot(nh_plio-sh_plio,label='NH-SH plio')
    plt.plot(nh_pi-sh_pi,label='NH-SH pi')
    plt.legend()

    plt.subplot(3,1,3)
    plt.plot((nh_plio-sh_plio)-(nh_pi-sh_pi),label='(pliocene - pi) nh-sh contrast')
    plt.legend()

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/cross_eq_heat_transport/NH-SH_'+mPWP_expt+'_'+regionname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/cross_eq_heat_transport/NH-SH_'+mPWP_expt+'_'+regionname+'.tiff' 
    plt.savefig(fileout, bbox_inches='tight')  
   
    plt.close()
    

    ###########################################################
    # get the average interhemispheric temperature difference
    # for the tropics only

    # create weighting array for the NH and the SH
    nh_weights_tropics=nh_weights
    sh_weights_tropics=sh_weights
   
    for j in range(0,ny):
        if lat[j] < -45:
            sh_weights[j,:]=0.0
        if lat[j] > 45:
            nh_weights[j,:]=0.0


    #plotdata(sh_weights_tropics,0,lon,lat,'weights',0,1,0.1,0.0,'n','weights')
    #plt.show()

    nh_tropics_plio=np.zeros(nmon)
    nh_tropics_pi=np.zeros(nmon)
    sh_tropics_plio=np.zeros(nmon)
    sh_tropics_pi=np.zeros(nmon)

    for mon in range(0,nmon):
        nh_tropics_plio[mon]=np.average(temp_plio[mon,:,:],weights=nh_weights_tropics)
        nh_tropics_pi[mon]=np.average(temp_pi[mon,:,:],weights=nh_weights_tropics)
        sh_tropics_plio[mon]=np.average(temp_plio[mon,:,:],weights=sh_weights_tropics)
        sh_tropics_pi[mon]=np.average(temp_pi[mon,:,:],weights=sh_weights_tropics)
                        

    plt.subplot(3,1,1)
    plt.plot(nh_tropics_plio,label='nh_tropics_plio')
    plt.plot(sh_tropics_plio,label='sh_tropics_plio')
    plt.plot(nh_tropics_pi,label='nh_tropics_pi')
    plt.plot(sh_tropics_pi,label='sh_tropics_pi')
    plt.title(regionname)
    plt.legend()
    
    plt.subplot(3,1,2)
    plt.plot(nh_tropics_plio-sh_tropics_plio,label='NH-SH tropics plio')
    plt.plot(nh_tropics_pi-sh_tropics_pi,label='NH-SH tropicspi')
    plt.legend()

    plt.subplot(3,1,3)
    plt.plot((nh_tropics_plio-sh_tropics_plio)-(nh_tropics_pi-sh_tropics_pi),label='Tropics (pliocene - pi) nh-sh contrast')
    plt.legend()

   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/cross_eq_heat_transport/NH-SH_tropics_'+mPWP_expt+'_'+regionname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/cross_eq_heat_transport/NH-SH_tropics_'+mPWP_expt+'_'+regionname+'.tiff' 
    plt.savefig(fileout, bbox_inches='tight')  
   
    plt.close()
  
#end def interhem_tdiff



#######################################################
def heat_transport(mPWP_expt,pi_expt,extra,HadCM3,regionname,lonmin,lonmax):
# this will get the interhemispheric temperature differences by month
# for a given longitudinal range

  
#end def heat_transport


################################
# main program

# annual mean
figureno=0

HadCM3='n'
mPWP_expt='xkvjg'
pi_expt='xkvje'
extra='n'
#plt.figure(figureno)
#interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,'globe',0,360)
interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,'Atlantic',-60,20)
#interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,'Indian',30,120)
#interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,'W_Pacific',150,200)
#interhem_tdiff(mPWP_expt,pi_expt,extra,HadCM3,'E_Pacific',240,270)

#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_energybal_components.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Thu Aug 29 15:30:44 2019

@author: earjcti

This program will plot the individual components of the energy balance
and how they differ between HadCM3 and HadGEM2.  It will make use of
the files produced by plot_energybal.py
"""

import sys
import numpy as np
import matplotlib.pyplot as plt


def read_data(filename):

    """
    reads all the data from the file into an array
    also reads the titleline into 'names'
    """

    file1 = open(filename, "r")
    line = file1.readline() # titleline
    line = line.rstrip() # remove /n
    names = line.split(',') # all the names are in the titleline

    alldata = []
    line = file1.readline()

    while line:
        linedata = []
        line = line.rstrip()
        vals = line.split(',')
        for val in vals:
            val = np.float(val)
            linedata.append(val)
        alldata.append(linedata)
        line = file1.readline()

    return (names, alldata)

def data_to_arrays(names, data):
    """
    converts the list data that we read in from the file
    into arrays containing the latitudes and the energy balance fields
    """

    lats = np.zeros(len(data))
    fields = np.zeros((len(lats), len(names) - 1))

    for i in range(0, len(lats)):
        lats[i] = data[i][0]
        fields[i, :] = data[i][1:]

    return [lats, fields]

def  plot_energybal_components(names, lats, fields, lats2, fields2,
                               overalltitle, outname):
    """
    this will plot all of the energy balance components
    it requires
    a) the names of the fields in the data arrays
    b) the hadgem latitudes
    c) the hadgem fields
    d) the hadcm3 latitudes
    e) the hadcm3 fields
    """
    titlename = {"Greenhouse gas emissivity" : "GHG Emissivity",
                 "Cloud emissivity" : "Cld Emmissivity",
                 "surfacealbedo" : "Surface Albedo",
                 "clear sky albedo" : "Clear Sky Albdeo",
                 "cloud albedo" : "Cloud Albedo",
                 "heat_transport" : "Heat Transport"
                }

    fig = plt.figure()
    #fig.suptitle(overalltitle, fontsize=12)

    for field in range(0, len(names) - 1):
        ax = fig.add_subplot(2, 3, field + 1)

        print('hglats', np.shape(lats))
        print('hgnemas', names)
        ax.plot(lats, fields[:, field])
        if field + 1 > 3:
            ax.set_xlabel('latitude')
        if (field + 1 == 1) or (field + 1 == 4):
            ax.set_ylabel('deg C')
        ax.set_xlim(-90, 90)

        if len(fields2) > 1:
            ax.plot(lats2, fields2[:, field])

        ax.plot([-90, 90], [0, 0], color='black', linestyle=':')

        ax.title.set_text(titlename.get(names[field + 1]))


    plt.tight_layout()
    #fig.subplots_adjust(top=0.8)

    fileout = (FILESTART + outname + '.eps')
    plt.savefig(fileout, bbox_inches='tight')

    fileout = (FILESTART + outname + '.png')
    plt.savefig(fileout, bbox_inches='tight')


def regrid_data(latold, dataold, latreq):
    """
    regrids the HadGEM data onto a HadCM3 grid
    """

    nlats, nmods = np.shape(dataold)
    regriddata = np.zeros((len(latreq), nmods))

    for i in range(0, nmods):
        regriddata[:, i] = np.interp(latreq, latold, dataold[:, i])


    return regriddata

def main():
    """
    main controller of the program to plot the energy banace components
    """

# get HadGEM data and HadCM3 data
    HG_names, HG_data = read_data(HADGEM_FILE)
    HCM_names, HCM_data = read_data(HADCM3_FILE)

# set up enerby balance components in an array for plotting
    HGlats, HG_fields = data_to_arrays(HG_names, HG_data)
    HCMlats, HCM_fields = data_to_arrays(HCM_names, HCM_data)

# plot all energybalance components

    plot_energybal_components(HG_names, HGlats, HG_fields, HCMlats, HCM_fields,
                              'Warming attributable to each component for HadGEM2 and HadCM3',
                              'EnergyBalanceComponents')

# put HadGEM data on same grid as HadCM3 data
    HG_fields_regrid = regrid_data(HGlats, HG_fields, HCMlats)

# get the data anomaly and plot
    anomaly_fields = HG_fields_regrid - HCM_fields
    plot_energybal_components(HG_names, HCMlats, anomaly_fields, [], [],
                              'HadGEM2 - HadCM3: Warming Attributable to each Component',
                              'EnergyBalanceComponentsAnomaly')


FILESTART='/home/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/'
#FILESTART = ''
HADGEM_FILE = FILESTART + 'RF_energybalxkvjg-xkvje.tex'
HADCM3_FILE = FILESTART + 'RF_energybalxibot-xibos.tex'

main()
::::::::::::::
plot_energybal_orig.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_ENERGYBAL
#PURPOSE
#    This program will plot the energy balance for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 11/1/2018
# Jula 20/10/2018 : ammended to include HadCM3


import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def global_enbal
#  def seasmean


def global_enbal(exptname):

    #==============
    # read in data from  average temperature files produced for Dan

    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw (clear sky flux)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field207.nc')
    sw_up=f.variables['field207'][:]
    sw_up=np.squeeze(sw_up)
 

   # outgoing lw  (toa)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_olr.nc')
    lw_toa=f.variables['olr'][:]
    lw_toa=np.squeeze(lw_toa)
  
    # outgoing lw  (toa clear sky)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_longwave.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # outgoing lw  (surface)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_ilr.nc')
    lw_surf=f.variables['ilr'][:]
    lw_surf=np.squeeze(lw_surf)

    
    # JULIA NOTE  THIS IS MUCH WORSE WHEN SUBTRACTING NET LWDOWN SURF
    lw_surf=lw_surf-net_lwdown_surf # upward lw rad is downlw - net downlw
    
    # ====================================
    # get the global average fields

    grid_alpha=sw_up/sw_down
    grid_epsilon=lw_toa/lw_surf

    # create weighting array
    weightarr=np.zeros(np.shape(atemp))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    meantemp=np.average(atemp,weights=weightarr)
    mean_sw_up=np.average(sw_up,weights=weightarr)
    mean_sw_down=np.average(sw_down,weights=weightarr)
    mean_lw_toa=np.average(lw_toa,weights=weightarr)
    mean_lwcs_toa=np.average(lwcs_toa,weights=weightarr)
    mean_lw_surf=np.average(lw_surf,weights=weightarr)
    mean_alpha=np.average(grid_alpha, weights=weightarr)
    mean_epsilon=np.average(grid_epsilon, weights=weightarr)

    #============================================
    # calculate terms in equation
    So=1367
    sigma=5.67 * (10.0 ** (-8.))

    alpha=mean_sw_up / mean_sw_down
    mean_lw_surf_up=sigma * (meantemp ** 4)

    epsilon=mean_lw_toa / mean_lw_surf # julia using mean lwcs_toa is worse


    print('alphas',alpha,mean_alpha)
    print('epsilon',epsilon,mean_epsilon)

    t4=So / 4.0 * (1.0-alpha) / (epsilon * sigma)
    t=t4 ** (1./4.)

    t4_mean=So / 4.0 * (1.0-mean_alpha) / (mean_epsilon * sigma)
    t_mean=t4_mean ** (1./4.)


    print('globvals',So/4.0,mean_alpha,mean_epsilon,sigma)



    print('    ')
    print(exptname)
    print('=========')
    print('t from formula=',t,' K   ',t-273.15,' degC')
    print('t obs=',meantemp,' K   ',meantemp-273.15,' degC')
    print('t mean=',t_mean,' K   ',t_mean-273.15,' degC')

    # julia note the mean energy balance is not quite right.  I am ignoring it because the latitudinal energy balance seems fine.

#end def global_enbal


def dh_zonal_enbal(exptname):

    #==============
    # read in data from  average temperature files produced for Dan

    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw 
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field201.nc')
    sw_up=f.variables['field201'][:]
    sw_up=np.squeeze(sw_up)
 
    # outgoing sw (clear sky flux)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field207.nc')
    swcs_up=f.variables['field207'][:]
    swcs_up=np.squeeze(swcs_up)
 

   # outgoing lw  (toa)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_olr.nc')
    lw_toa_up=f.variables['olr'][:]
    lw_toa_up=np.squeeze(lw_toa_up)
  
    # outgoing lw  (toa clear sky)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_longwave.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # incoming lw  (surface)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_ilr.nc')
    lw_surf_down=f.variables['ilr'][:]
    lw_surf_down=np.squeeze(lw_surf_down)


    lw_surf_up=lw_surf_down-net_lwdown_surf # upward lw rad is downlw - net downlw


    print(net_lwdown_surf)    
    
    # ====================================
    # get the zonal average fields


    grid_alpha=sw_up/sw_down
    grid_alpha_cs=swcs_up/sw_down
    grid_epsilon=lw_toa_up/(lw_surf_up)
    grid_epsilon_cs=lwcs_toa / lw_surf_up

   
    meantemp=np.average(atemp,axis=1)
    mean_sw_up=np.average(sw_up,axis=1)
    mean_sw_down=np.average(sw_down,axis=1)
    mean_lw_toa_up=np.average(lw_toa_up,axis=1)
    mean_lwcs_toa_up=np.average(lwcs_toa,axis=1)
    mean_lw_surf_down=np.average(lw_surf_down,axis=1)
    mean_net_lwdown_surf=np.average(net_lwdown_surf,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_alpha_cs=np.average(grid_alpha_cs,axis=1)
    mean_epsilon=np.average(grid_epsilon,axis=1)
    mean_epsilon_cs=np.average(grid_epsilon_cs,axis=1)
    mean_lw_surf_up=np.average(lw_surf_up,axis=1)

    plt.subplot(2,1,1)
    plt.plot(lat,mean_alpha,label='mean_alpha')
    plt.plot(lat,mean_alpha_cs,label='mean_alpha_cs')
    plt.legend()
    plt.title('different alphas')



    sigma=5.67 * (10.0 ** (-8.))

    #============================================
    # calculate terms in equation
    H=(-1.0) * ((mean_sw_down - mean_sw_up) -(mean_lw_toa_up))
   
    
    print('means',np.average(mean_sw_down),np.average(mean_sw_up), np.average(mean_net_lwdown_surf),np.average(mean_lw_toa_up))

    t4=((mean_sw_down * (1.0-mean_alpha)) + H) / (mean_epsilon * sigma)
    t=t4 ** (1./4.)

    plt.subplot(2,1,2)
    plt.plot(lat,meantemp-t,label='temperature')
    plt.legend()
    plt.title('temperature difference')
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/dh_temp_anom'+pliop2_expt+'-'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    
    components=[mean_epsilon,mean_epsilon_cs,mean_alpha,mean_alpha_cs,H,t,mean_sw_down,lat]
    return(components)

#end def dh_zonal_enbal


def rf_zonal_enbal(exptname):

    #==============
    # read in data from  average temperature files produced for Dan

    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw 
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field201.nc')
    sw_up=f.variables['field201'][:]
    sw_up=np.squeeze(sw_up)
 
    # surface upwards sw (clear sky flux)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field207_1.nc')
    sw_surf_cs_up=f.variables['field207_1'][:]
    sw_surf_cs_up=np.squeeze(sw_surf_cs_up)
 
    # surface downwards sw (clear sky flux)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field208.nc')
    sw_surf_cs_down=f.variables['field208'][:]
    sw_surf_cs_down=np.squeeze(sw_surf_cs_down)
 
  # outgoing sw (clear sky flux)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field207.nc')
    swcs_up=f.variables['field207'][:]
    swcs_up=np.squeeze(swcs_up)
 

   # outgoing lw  (toa)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_olr.nc')
    lw_toa_up=f.variables['olr'][:]
    lw_toa_up=np.squeeze(lw_toa_up)
  
    # outgoing lw  (toa clear sky)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_longwave.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # incoming lw  (surface)
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_ilr.nc')
    lw_surf_down=f.variables['ilr'][:]
    lw_surf_down=np.squeeze(lw_surf_down)


    # net downward shortwave flux surface
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_solar.nc')
    net_swdown_surf=f.variables['solar'][:]
    net_swdown_surf=np.squeeze(net_swdown_surf)

    # total downward shortwave flux surface
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_field203.nc')
    sw_surf_down=f.variables['field203'][:]
    sw_surf_down=np.squeeze(sw_surf_down)


    # total cloud amount random overlap
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname+'_Annual_Average_a@pd_TotalCloud.nc')
    cloud_frac=f.variables['field30'][:]
    cloud_frac=np.squeeze(cloud_frac)


    lw_surf_up=lw_surf_down-net_lwdown_surf # upward lw rad is downlw - net downlw

    sw_surf_up=sw_surf_down - net_swdown_surf # upwards sw rad at surf


    # topography
    if exptname=='xkvje':
        orog_fname='/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.orog_new.nc'
    if exptname=='xkvjg':
        orog_fname='/nfs/hera2/apps/metadata/ancil/PRISM3_ALT/HadGEM2/HadGEM_pliocene_orog.nc'
    f=Dataset(orog_fname)
    orog=f.variables['ht'][:]
    orog=np.squeeze(orog)


    
    # ====================================
    # get gridded epsilon and alpha



    grid_epsilon=lw_toa_up/(lw_surf_up)
    grid_epsilon_cs=lwcs_toa / lw_surf_up


    # from Taylor 2007 
    # alpha is now surface albedo.  We denote planetary albedo:  A.
    # alpha=(1-c)*alpha_clr + (c*alpha_oc)
    # oc=overcast, clr=clear sky, c=cloud fraction

    grid_A=sw_up/sw_down
    grid_A_clr=swcs_up/sw_down
    grid_alpha_clr=sw_surf_cs_up / sw_surf_cs_down
    grid_alpha=sw_surf_up / sw_surf_down
    grid_alpha_oc=(grid_alpha - ((1-cloud_frac) * grid_alpha_clr)) / cloud_frac


    #===============================
    # get amount scattered (gamma) and 
    # amount not absorbed (mu)  (absorbtion =1-mu)
    # see Taylor 2007 equation 9 for the equations

    grid_mu=(sw_surf_down / sw_down) * (1.0 - grid_alpha) + grid_A
    grid_mu_clr=(sw_surf_cs_down / sw_down) * (1.0 - grid_alpha_clr)+grid_A_clr
    grid_mu_oc=(grid_mu - ((1-cloud_frac) * grid_mu_clr)) / cloud_frac
    grid_mu_cld=grid_mu_oc / grid_mu_clr

    grid_gamma=((grid_mu - (sw_surf_down / sw_down)) /
                (grid_mu - (grid_alpha * (sw_surf_down / sw_down))))
    grid_gamma_clr=((grid_mu_clr - (sw_surf_cs_down / sw_down)) /
                (grid_mu_clr - (grid_alpha_clr * (sw_surf_cs_down / sw_down))))
    grid_gamma_oc=(grid_gamma - ((1-cloud_frac) * grid_gamma_clr)) / cloud_frac
    grid_gamma_cld=1.0 - ((1.0 - grid_gamma_oc)/(1.0 - grid_gamma_clr))
                 

    # note these values of gamma, alpha and mu have been checked against
    # equations 7 and 8 of Taylor 2007.  Therefore if A is correct and
    # qs_hat_down is correct then gamma alpha and mu are also correct.  

  
    #===============================
    # get fields for use in energy balance calculation
 
    meantemp=np.average(atemp,axis=1)
    mean_sw_up=np.average(sw_up,axis=1)
    mean_sw_down=np.average(sw_down,axis=1)
    mean_sw_surf_cs_down=np.average(sw_surf_cs_down,axis=1)
    mean_sw_surf_down=np.average(sw_surf_down,axis=1)
    mean_lw_toa_up=np.average(lw_toa_up,axis=1)
    mean_lwcs_toa_up=np.average(lwcs_toa,axis=1)
    mean_lw_surf_down=np.average(lw_surf_down,axis=1)
    mean_net_lwdown_surf=np.average(net_lwdown_surf,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_alpha_clr=np.average(grid_alpha_clr,axis=1)
    mean_alpha_oc=np.average(grid_alpha_oc,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_epsilon=np.average(grid_epsilon,axis=1)
    mean_epsilon_cs=np.average(grid_epsilon_cs,axis=1)
    mean_lw_surf_up=np.average(lw_surf_up,axis=1)
    mean_cloud=np.average(cloud_frac,axis=1)
    mean_mu=np.average(grid_mu,axis=1)
    mean_mu_clr=np.average(grid_mu_clr,axis=1)
    mean_mu_oc=np.average(grid_mu_oc,axis=1)
    mean_mu_cld=np.average(grid_mu_cld,axis=1)
    mean_gamma=np.average(grid_gamma,axis=1)
    mean_gamma_clr=np.average(grid_gamma_clr,axis=1)
    mean_gamma_oc=np.average(grid_gamma_oc,axis=1)
    mean_gamma_cld=np.average(grid_gamma_cld,axis=1)
    mean_A=np.average(grid_A,axis=1)
    mean_orog=np.average(orog,axis=1)

    #plt.subplot(3,1,1)
    #plt.plot(lat,mean_alpha-0.1,label='mean_alpha-0.1')
    #plt.plot(lat,mean_alpha_clr,label='mean_alpha_clr')
    #plt.plot(lat,mean_alpha_oc,label='mean_alpha_oc')
    #plt.legend()
    #plt.title('different values')

    #plt.subplot(3,1,2)
    #plt.plot(lat,mean_mu,label='mean_mu')
    #plt.plot(lat,mean_mu_clr,label='mean_mu_clr')
    #plt.plot(lat,mean_mu_oc,label='mean_mu_oc')
    #plt.legend()


    #plt.subplot(3,1,3)
    #plt.plot(lat,mean_gamma,label='mean_gamma')
    #plt.plot(lat,mean_gamma_clr,label='mean_gamma_clr')
    #plt.plot(lat,mean_gamma_oc,label='mean_gamma_oc')  
    #plt.legend()

    #plt.show()
   


    sigma=5.67 * (10.0 ** (-8.))

    #============================================
    # calculate terms in equation
    H=(-1.0) * ((mean_sw_down - mean_sw_up) -(mean_lw_toa_up))
   
    

    t4=((mean_sw_down * (1.0-mean_alpha)) + H) / (mean_epsilon * sigma)
    t=t4 ** (1./4.)


    components=[mean_epsilon,mean_epsilon_cs,mean_alpha_clr,mean_alpha_oc,mean_mu_cld,mean_gamma_cld,mean_mu_clr,mean_gamma_clr,mean_cloud,H,meantemp,mean_sw_down,lat,mean_alpha,mean_mu,mean_gamma,mean_mu_oc,mean_gamma_oc,mean_A,mean_orog]
    return(components)

#end def rf_zonal_enbal


##########################
def main_dh_zonal(preind_expt,plio_expt,pliop2_expt,extra):

    components=dh_zonal_enbal(preind_expt)
    emis_pi=components[0]
    emis_pi_cs=components[1]
    alpha_pi=components[2]
    alpha_pi_cs=components[3]
    H_pi=components[4]
    temp_pi=components[5]
    sw_down_pi=components[6]
    lat=components[7]
    
    components=dh_zonal_enbal(pliop2_expt)
    emis_plio=components[0]
    emis_plio_cs=components[1]
    alpha_plio=components[2]
    alpha_plio_cs=components[3]
    H_plio=components[4]
    temp_plio=components[5]
    sw_down_plio=components[6]
    lat=components[7]

    sigma=5.67 * (10.0**-8)

  

    # we are now decomposing but will also find the average value from 55N-90N
    # create weighting array
    weightarr=np.cos(np.deg2rad(lat))
    for i in range(0,len(lat)):
        if lat[i] < 55:
            weightarr[i]=0.

    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
    t_2=t4 ** (1./4.)

    deltaT_gge=t_1-t_2
    #plt.subplot(2,1,1)
    plt.plot(lat,deltaT_gge,label='GHG+ topography')
    print('Arctic T gge',np.average(deltaT_gge,weights=weightarr))


    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
    t_2=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi * sigma)
    t_3=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
    t_4=t4 ** (1./4.)

    deltaT_ce=(t_1-t_2) - (t_3 - t_4)
    print('Arctic T cloud emisivity',np.average(deltaT_ce,weights=weightarr))
    plt.plot(lat,deltaT_ce, label='cloud emissivity')

    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio_cs)) + H_plio) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi)) + H_plio) / (emis_plio * sigma)
    t_3=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi_cs)) + H_plio) / (emis_plio * sigma)
    t_4=t4 ** (1./4.)

    deltaT_ca=(t_1-t_2) - (t_3 - t_4)
    plt.plot(lat,deltaT_ca, label='cloud albedo')
    print('Arctic T cloud albedo',np.average(deltaT_ca,weights=weightarr))



    t4=((sw_down_plio * (1.0-alpha_plio_cs)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi_cs)) + H_plio) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)

    deltaT_csa=t_1-t_2
    plt.plot(lat,deltaT_csa,label='clear sky albedo')
    print('Arctic T clear sky albedo',np.average(deltaT_csa,weights=weightarr))



    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_pi) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)

    deltaT_H=t_1-t_2
    plt.plot(lat,deltaT_H,label='heat transport')
    print('Arctic T Heat transport',np.average(deltaT_H,weights=weightarr))
    plt.legend()

    deltaT=temp_plio-temp_pi
    plt.plot(lat,deltaT,label='actual temperature change')
    print('Arctic T total change',np.average(deltaT,weights=weightarr))
    plt.legend()



    plt.title('Energy balance - Dan Hill')
    plt.xlabel('latitude')
    plt.ylabel('pliocene warming')
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/DH_energybal'+pliop2_expt+'-'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

# end of main part of Dan Hills energy balance



################################
# main program

# annual mean

preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'


#global_enbal(preind_expt)
#global_enbal(pliop2_expt)


# Dan Hills energy balance
#main_dh_zonal(preind_expt,plio_expt,pliop2_expt,extra)
#sys.exit()


# Ran Fengss energy balance


components=rf_zonal_enbal(preind_expt)
emis_pi=components[0]
emis_pi_cs=components[1]
alpha_pi_clr=components[2]
alpha_pi_oc=components[3]
mu_pi_cld=components[4]
gamma_pi_cld=components[5]
mu_pi_clr=components[6]
gamma_pi_clr=components[7]
cloud_pi=components[8]
H_pi=components[9]
temp_pi=components[10]
sw_down_pi=components[11]
lat=components[12]
alpha_pi=components[13]
mu_pi=components[14]
gamma_pi=components[15]
mu_pi_oc=components[16]
gamma_pi_oc=components[17]
pi_A=components[18]
topo_pi=components[19]


components=rf_zonal_enbal(pliop2_expt)
emis_plio=components[0]
emis_plio_cs=components[1]
alpha_plio_clr=components[2]
alpha_plio_oc=components[3]
mu_plio_cld=components[4]
gamma_plio_cld=components[5]
mu_plio_clr=components[6]
gamma_plio_clr=components[7]
cloud_plio=components[8]
H_plio=components[9]
temp_plio=components[10]
sw_down_plio=components[11]
lat=components[12]
alpha_plio=components[13]
mu_plio=components[14]
gamma_plio=components[15]
mu_plio_oc=components[16]
gamma_plio_oc=components[17]
plio_A=components[18]
topo_plio=components[19]


delta_T_topo=(topo_plio-topo_pi) * (-5.5) / 1000.
sigma=5.67 * (10.0**-8)

# print j corresponding to 75deg
for j in range(0,len(lat)):
    if lat[j]==75:
        print(j,lat[j])

#taylor 2007 equation 16 a-c and 7
# note the equation 16a is misleading.  I think it should be
#delta_A_alpha=(1-c)delta_A_alpha_clr + c*delta_A_alpha_oc 

# get the change in albedo due to alpha


# new use mean values
mu=(mu_plio+mu_pi)/2.0
gamma=(gamma_plio+gamma_pi)/2.0
alpha=(alpha_plio+alpha_pi)/2.0
cloud=(cloud_plio+cloud_pi)/2.0

A_alpha_pi_clr=((mu * gamma) + ((mu * alpha_pi_clr * (1.0-gamma)**2.0)/ (1.0 - alpha_pi_clr * gamma)))
A_alpha_plio_clr=((mu * gamma) + ((mu * alpha_plio_clr * (1.0-gamma)**2.0)/ (1.0 - alpha_plio_clr * gamma)))
A_alpha_pi_oc=((mu * gamma) + ((mu * alpha_pi_oc * (1.0-gamma)**2.0)/ (1.0 - alpha_pi_oc * gamma)))
A_alpha_plio_oc=((mu * gamma) + ((mu * alpha_plio_oc * (1.0-gamma)**2.0)/ (1.0 - alpha_plio_oc * gamma)))
A_alpha_diff=(1.0-cloud)*(A_alpha_plio_clr - A_alpha_pi_clr)+cloud*(A_alpha_plio_oc - A_alpha_pi_oc)
A_alpha_plio=(1.0-cloud)*A_alpha_plio_clr + cloud*A_alpha_plio_oc
A_alpha_pi=(1.0-cloud)*A_alpha_pi_clr + cloud*A_alpha_pi_oc
# julia print out at 75N
print('surface alpha at 75',A_alpha_diff[132],A_alpha_plio[132],A_alpha_pi[132])

# get the change in albedo due to clouds eqn 16b


A_cld_pi_gamma=((mu * gamma_pi_cld) + ((mu * alpha * (1.0-gamma_pi_cld)**2.0)/ (1.0 - alpha * gamma_pi_cld)))
A_cld_plio_gamma=((mu * gamma_plio_cld) + ((mu * alpha * (1.0-gamma_plio_cld)**2.0)/ (1.0 - alpha * gamma_plio_cld)))
A_cld_pi_mu=((mu_pi_cld * gamma) + ((mu_pi_cld * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_cld_plio_mu=((mu_plio_cld * gamma) + ((mu_plio_cld * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))

# equation 15 A=(a-c)Aclr + c Aoc

mu_clr=(mu_plio_clr + mu_pi_clr)/2.0
gamma_clr=(gamma_plio_clr + gamma_pi_clr)/2.0
alpha_clr=(alpha_plio_clr + alpha_pi_clr)/2.0
mu_oc=(mu_plio_oc + mu_pi_oc)/2.0
gamma_oc=(gamma_plio_oc + gamma_pi_oc)/2.0
alpha_oc=(alpha_plio_oc + alpha_pi_oc)/2.0

clravg=((mu_clr * gamma_clr) + ((mu_clr * alpha_clr * (1.0-gamma_clr)**2.0)/ (1.0 - alpha_clr * gamma_clr)))
ocavg=((mu_oc * gamma_oc) + ((mu_oc * alpha_oc * (1.0-gamma_oc)**2.0)/ (1.0 - alpha_oc * gamma_oc)))
A_deltaC=((cloud_pi-cloud_plio)*clravg)+((cloud_plio-cloud_pi)*ocavg)


A_cld_diff=A_cld_plio_mu-A_cld_pi_mu + A_cld_plio_gamma-A_cld_pi_gamma + A_deltaC

# julia print out at 75N
print('cloud A at 75',A_cld_diff[132])



# get the change in albedo due to clear skies


A_clr_pi_mu=((mu_pi_clr * gamma) + ((mu_pi_clr * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_clr_plio_mu=((mu_plio_clr * gamma) + ((mu_plio_clr * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_clr_pi_gamma=((mu * gamma_pi_clr) + ((mu * alpha * (1.0-gamma_pi_clr)**2.0)/ (1.0 - alpha * gamma_pi_clr)))
A_clr_plio_gamma=((mu * gamma_plio_clr) + ((mu * alpha * (1.0-gamma_plio_clr)**2.0)/ (1.0 - alpha * gamma_plio_clr)))
A_clr_diff=(A_clr_plio_mu - A_clr_pi_mu)+(A_clr_plio_gamma - A_clr_pi_gamma)
print('clr A at 75',A_clr_diff[132],A_clr_plio_mu[132],A_clr_pi_mu[132],A_clr_plio_gamma[132],A_clr_pi_gamma[132],cloud_pi[132],cloud_plio[132])


# get change in planetary albedo to check budgets

A_diff=plio_A-pi_A


#plt.subplot(2,1,1)
plt.plot(lat,A_alpha_diff,label='A_alpha')
plt.plot(lat,A_cld_diff,label='A_cld')
plt.plot(lat,A_clr_diff,label='A clr diff')
plt.plot(lat,A_diff,label='total planetary Albedo diff')
plt.plot(lat,A_alpha_diff+A_cld_diff+A_clr_diff,label='sum')
plt.legend()
plt.title('plio-pi A components')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_albedo'+pliop2_expt+'-'+preind_expt+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  

plt.close()


#print values at 75N in plot
print('A_alpha_diff',A_alpha_diff[132])
print('A_cld_diff',A_cld_diff[132])
print('A_clr_diff',A_clr_diff[132])
print('A_diff',A_diff[132])
print(' ')



# we are now decomposing but will also find the average value from 55N-90N
# create weighting array
weightarr_Arctic=np.cos(np.deg2rad(lat))
for i in range(0,len(lat)):
    if lat[i] < 55:
        weightarr_Arctic[i]=0.
weightarr=np.cos(np.deg2rad(lat))

t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
t_2=t4 ** (1./4.)

deltaT_gge=t_1-t_2 - delta_T_topo


#plt.subplot(2,1,2)
plt.plot(lat,deltaT_gge,label='Greenhouse gas emissivity')
#plt.plot(lat,delta_T_topo,label='topography')
print('Arctic T gge',np.average(deltaT_gge,weights=weightarr_Arctic))
print('Arctic T topo',np.average(delta_T_topo,weights=weightarr_Arctic))


t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio_cs * sigma)
t_2=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_pi * sigma)
t_3=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_pi_cs * sigma)
t_4=t4 ** (1./4.)

deltaT_ce=(t_1-t_2) - (t_3 - t_4)
print('Arctic T cloud emisivity',np.average(deltaT_ce,weights=weightarr_Arctic))
plt.plot(lat,deltaT_ce, label='cloud emissivity')

# surface albedo

t4=((sw_down_plio * (1.0-A_alpha_plio)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-A_alpha_pi)) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_surfalpha=(t_1-t_2) 
plt.plot(lat,deltaT_surfalpha, label='surface albedo')
print('Arctic T surface albedo',np.average(deltaT_surfalpha,weights=weightarr_Arctic))

# check alternate value for surface (this seems to work fine)
# we did this to check how we had done clear sky and cloud
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_alpha_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_altsurf=t_1-t_2
#plt.plot(lat,deltaT_altsurf,label='alt surface albedo')
print('Arctic T altsurf',np.average(deltaT_altsurf,weights=weightarr_Arctic))


# clear sky albedo

t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_clr_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_csalbedo=t_1-t_2
plt.plot(lat,deltaT_csalbedo,label='clear sky albedo')
print('Arctic T csalbedo',np.average(deltaT_csalbedo,weights=weightarr_Arctic))

#cloud albedo

t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_cld_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_cldalbedo=t_1-t_2
plt.plot(lat,deltaT_cldalbedo,label='cloud albedo')
print('Arctic T cloud albedo',np.average(deltaT_cldalbedo,weights=weightarr_Arctic))



t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_pi) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_H=t_1-t_2
plt.plot(lat,deltaT_H,label='heat transport')
print('Arctic T Heat transport',np.average(deltaT_H,weights=weightarr_Arctic))
plt.legend()

deltaT=temp_plio-temp_pi
#plt.plot(lat,deltaT,label='actual temperature change')
print('Arctic T total change',np.average(deltaT,weights=weightarr_Arctic))


total_components=deltaT_gge+deltaT_ce+deltaT_surfalpha+deltaT_csalbedo+deltaT_cldalbedo+deltaT_H
#plt.plot(lat,total_components,label='total accountable')
plt.legend()


deltaT_cloud=deltaT_ce+deltaT_cldalbedo
for i in range(0,len(lat)):
    print(i,lat[i],deltaT_cloud[i])

print('Mean T gge',np.average(deltaT_gge,weights=weightarr))
print('Mean T topo',np.average(delta_T_topo,weights=weightarr))
print('Mean T cloud emisivity',np.average(deltaT_ce,weights=weightarr))
print('Mean T surface albedo',np.average(deltaT_surfalpha,weights=weightarr))
print('Mean T csalbedo',np.average(deltaT_csalbedo,weights=weightarr))
print('Mean T cloud albedo',np.average(deltaT_cldalbedo,weights=weightarr))
print('Mean T Heat transport',np.average(deltaT_H,weights=weightarr))
print('Mean T total change',np.average(deltaT,weights=weightarr))






print('Mean cloud changes',np.average(deltaT_cloud,weights=weightarr))



mp.pyplot.axhline(y=0,xmin=-90,xmax=90,color='black')
plt.title('Energy Balance')
plt.xlabel('Latitude')
plt.ylabel('Pliocene Warming (deg C)')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_energybal'+pliop2_expt+'-'+preind_expt+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  

plt.close()



sys.exit(0)

####

::::::::::::::
plot_energybal.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_ENERGYBAL
#PURPOSE
#    This program will plot the energy balance for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 11/1/2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def global_enbal
#  def seasmean


def global_enbal(exptname,HadCM3):
    """
    this looks to be a check that the temperature contribution from all the different sources is equal to the modelled temperature
    """

    #==============
    # read in data from  average temperature files produced for Dan

    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/'+exptname+'/database_averages/'+exptname
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname

    print(filestart)

    f=Dataset(filestart+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset(filestart+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw (clear sky flux)
    f=Dataset(filestart+'_Annual_Average_a@pd_field207.nc')
    sw_up=f.variables['field207'][:]
    sw_up=np.squeeze(sw_up)
 

   # outgoing lw  (toa)
    filename='olr'
    f=Dataset(filestart+'_Annual_Average_a@pd_olr.nc')
    lw_toa=f.variables['olr'][:]
    lw_toa=np.squeeze(lw_toa)
  
    # outgoing lw  (toa clear sky)
    f=Dataset(filestart+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    filename='longwave'
    f=Dataset(filestart+'_Annual_Average_a@pd_'+filename+'.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # outgoing lw  (surface)
    filename='ilr'
    f=Dataset(filestart+'_Annual_Average_a@pd_'+filename+'.nc')
    lw_surf=f.variables['ilr'][:]
    lw_surf=np.squeeze(lw_surf)

    
    # JULIA NOTE  THIS IS MUCH WORSE WHEN SUBTRACTING NET LWDOWN SURF
    # lauren - ignore this note it was me trying to figure out which fields
    # were which
    lw_surf=lw_surf-net_lwdown_surf # upward lw rad is downlw - net downlw
    
    # ====================================
    # get the global average fields

    grid_alpha=sw_up/sw_down
    grid_epsilon=lw_toa/lw_surf

    # create weighting array
    weightarr=np.zeros(np.shape(atemp))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    meantemp=np.average(atemp,weights=weightarr)
    mean_sw_up=np.average(sw_up,weights=weightarr)
    mean_sw_down=np.average(sw_down,weights=weightarr)
    mean_lw_toa=np.average(lw_toa,weights=weightarr)
    mean_lwcs_toa=np.average(lwcs_toa,weights=weightarr)
    mean_lw_surf=np.average(lw_surf,weights=weightarr)
    mean_alpha=np.average(grid_alpha, weights=weightarr)
    mean_epsilon=np.average(grid_epsilon, weights=weightarr)

    #============================================
    # calculate terms in equation
    So=1367 # solar constant
    sigma=5.67 * (10.0 ** (-8.))

    alpha=mean_sw_up / mean_sw_down
    mean_lw_surf_up=sigma * (meantemp ** 4)

    epsilon=mean_lw_toa / mean_lw_surf # julia using mean lwcs_toa is worse


    print('alphas',alpha,mean_alpha)
    print('epsilon',epsilon,mean_epsilon)

    t4=So / 4.0 * (1.0-alpha) / (epsilon * sigma)
    t=t4 ** (1./4.)

    t4_mean=So / 4.0 * (1.0-mean_alpha) / (mean_epsilon * sigma)
    t_mean=t4_mean ** (1./4.)


    print('globvals',So/4.0,mean_alpha,mean_epsilon,sigma)



    print('    ')
    print(exptname)
    print('=========')
    print('t from formula=',t,' K   ',t-273.15,' degC')
    print('t obs=',meantemp,' K   ',meantemp-273.15,' degC')
    print('t mean=',t_mean,' K   ',t_mean-273.15,' degC')

    sys.exit(0)
    # julia note the mean energy balance is not quite right.  I am ignoring it because the latitudinal energy balance seems fine.

#end def global_enbal

################################################
def dh_zonal_enbal(exptname,HadCM3):

  
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/'+exptname+'/database_averages/'+exptname
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname


    #==============
    # read in data from  average temperature files produced for Dan

    f=Dataset(filestart+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset(filestart+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw 
    f=Dataset(filestart+'_Annual_Average_a@pd_field201.nc')
    sw_up=f.variables['field201'][:]
    sw_up=np.squeeze(sw_up)
 
    # outgoing sw (clear sky flux)
    f=Dataset(filestart+'_Annual_Average_a@pd_field207.nc')
    swcs_up=f.variables['field207'][:]
    swcs_up=np.squeeze(swcs_up)
 

   # outgoing lw  (toa)
    f=Dataset(filestart+'_Annual_Average_a@pd_olr.nc')
    lw_toa_up=f.variables['olr'][:]
    lw_toa_up=np.squeeze(lw_toa_up)
  
    # outgoing lw  (toa clear sky)
    f=Dataset(filestart+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    f=Dataset(filestart+'_Annual_Average_a@pd_longwave.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # incoming lw  (surface)
    f=Dataset(filestart+'_Annual_Average_a@pd_ilr.nc')
    lw_surf_down=f.variables['ilr'][:]
    lw_surf_down=np.squeeze(lw_surf_down)


    lw_surf_up=lw_surf_down-net_lwdown_surf # upward lw rad is downlw - net downlw


    print(net_lwdown_surf)    
    
    # ====================================
    # get the zonal average fields


    grid_alpha=sw_up/sw_down
    grid_alpha_cs=swcs_up/sw_down
    grid_epsilon=lw_toa_up/(lw_surf_up)
    grid_epsilon_cs=lwcs_toa / lw_surf_up

   
    meantemp=np.average(atemp,axis=1)
    mean_sw_up=np.average(sw_up,axis=1)
    mean_sw_down=np.average(sw_down,axis=1)
    mean_lw_toa_up=np.average(lw_toa_up,axis=1)
    mean_lwcs_toa_up=np.average(lwcs_toa,axis=1)
    mean_lw_surf_down=np.average(lw_surf_down,axis=1)
    mean_net_lwdown_surf=np.average(net_lwdown_surf,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_alpha_cs=np.average(grid_alpha_cs,axis=1)
    mean_epsilon=np.average(grid_epsilon,axis=1)
    mean_epsilon_cs=np.average(grid_epsilon_cs,axis=1)
    mean_lw_surf_up=np.average(lw_surf_up,axis=1)

    plt.subplot(2,1,1)
    plt.plot(lat,mean_alpha,label='mean_alpha')
    plt.plot(lat,mean_alpha_cs,label='mean_alpha_cs')
    plt.legend()
    plt.title('different alphas')



    sigma=5.67 * (10.0 ** (-8.))

    #============================================
    # calculate terms in equation
    H=(-1.0) * ((mean_sw_down - mean_sw_up) -(mean_lw_toa_up))
   
    
    print('means',np.average(mean_sw_down),np.average(mean_sw_up), np.average(mean_net_lwdown_surf),np.average(mean_lw_toa_up))

    t4=((mean_sw_down * (1.0-mean_alpha)) + H) / (mean_epsilon * sigma)
    t=t4 ** (1./4.)

    plt.subplot(2,1,2)
    plt.plot(lat,meantemp-t,label='temperature')
    plt.legend()
    plt.title('temperature difference')
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/dh_temp_anom'+pliop2_expt+'-'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    
    components=[mean_epsilon,mean_epsilon_cs,mean_alpha,mean_alpha_cs,H,t,mean_sw_down,lat]
    return(components)

#end def dh_zonal_enbal


def rf_zonal_enbal(exptname,HadCM3):

    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/'+exptname+'/database_averages/'+exptname
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/database_averages/'+exptname


    #==============
    # read in data from  average temperature files produced for Dan

    f=Dataset(filestart+'_Annual_Average_a@pd_Temperature.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp'][:]
    atemp=np.squeeze(atemp)
    ny,nx=np.shape(atemp)

    # get upward and downward sw radiation
    # incoming sw
    f=Dataset(filestart+'_Annual_Average_a@pd_field200.nc')
    sw_down=f.variables['field200'][:]
    sw_down=np.squeeze(sw_down)

    # outgoing sw 
    f=Dataset(filestart+'_Annual_Average_a@pd_field201.nc')
    sw_up=f.variables['field201'][:]
    sw_up=np.squeeze(sw_up)
 
    # surface upwards sw (clear sky flux)
    f=Dataset(filestart+'_Annual_Average_a@pd_field207_1.nc')
    sw_surf_cs_up=f.variables['field207_1'][:]
    sw_surf_cs_up=np.squeeze(sw_surf_cs_up)
 
    # surface downwards sw (clear sky flux)
    f=Dataset(filestart+'_Annual_Average_a@pd_field208.nc')
    sw_surf_cs_down=f.variables['field208'][:]
    sw_surf_cs_down=np.squeeze(sw_surf_cs_down)
 
  # outgoing sw (clear sky flux)
    f=Dataset(filestart+'_Annual_Average_a@pd_field207.nc')
    swcs_up=f.variables['field207'][:]
    swcs_up=np.squeeze(swcs_up)
 

   # outgoing lw  (toa)
    f=Dataset(filestart+'_Annual_Average_a@pd_olr.nc')
    lw_toa_up=f.variables['olr'][:]
    lw_toa_up=np.squeeze(lw_toa_up)
  
    # outgoing lw  (toa clear sky)
    f=Dataset(filestart+'_Annual_Average_a@pd_csolr.nc')
    lwcs_toa=f.variables['field207'][:]
    lwcs_toa=np.squeeze(lwcs_toa)
    

    # net downward longwave surface
    f=Dataset(filestart+'_Annual_Average_a@pd_longwave.nc')
    net_lwdown_surf=f.variables['longwave'][:]
    net_lwdown_surf=np.squeeze(net_lwdown_surf)

 
    # incoming lw  (surface)
    f=Dataset(filestart+'_Annual_Average_a@pd_ilr.nc')
    lw_surf_down=f.variables['ilr'][:]
    lw_surf_down=np.squeeze(lw_surf_down)


    # net downward shortwave flux surface
    f=Dataset(filestart+'_Annual_Average_a@pd_solar.nc')
    net_swdown_surf=f.variables['solar'][:]
    net_swdown_surf=np.squeeze(net_swdown_surf)

    # total downward shortwave flux surface
    f=Dataset(filestart+'_Annual_Average_a@pd_field203.nc')
    sw_surf_down=f.variables['field203'][:]
    sw_surf_down=np.squeeze(sw_surf_down)


    # total cloud amount random overlap
    f=Dataset(filestart+'_Annual_Average_a@pd_TotalCloud.nc')
    cloud_frac=f.variables['field30'][:]
    cloud_frac=np.squeeze(cloud_frac)


    lw_surf_up=lw_surf_down-net_lwdown_surf # upward lw rad is downlw - net downlw

    sw_surf_up=sw_surf_down - net_swdown_surf # upwards sw rad at surf


    # topography
    if exptname=='xkvje':
        orog_fname='/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.orog_new.nc'
    if exptname=='xkvjg':
        orog_fname='/nfs/hera2/apps/metadata/ancil/PRISM3_ALT/HadGEM2/HadGEM_pliocene_orog.nc'
    if exptname=='xibos':
        orog_fname='/nfs/hera2/apps/metadata/ancil/preind2/qrparm.orog.nc'
    if exptname=='xibot' or exptname=='xoorb' or exptname=='xoorf':
        orog_fname='/nfs/hera2/apps/metadata/ancil/PRISM3_ALT/qrparm.orog.nc'
    f=Dataset(orog_fname)
    orog=f.variables['ht'][:]
    orog=np.squeeze(orog)


    
    # ====================================
    # get gridded epsilon and alpha



    grid_epsilon=lw_toa_up/(lw_surf_up)
    grid_epsilon_cs=lwcs_toa / lw_surf_up


    # from Taylor 2007 
    # alpha is now surface albedo.  We denote planetary albedo:  A.
    # alpha=(1-c)*alpha_clr + (c*alpha_oc)
    # oc=overcast, clr=clear sky, c=cloud fraction

    grid_A=sw_up/sw_down
    grid_A_clr=swcs_up/sw_down
    grid_alpha_clr=sw_surf_cs_up / sw_surf_cs_down
    grid_alpha=sw_surf_up / sw_surf_down
    grid_alpha_oc=(grid_alpha - ((1-cloud_frac) * grid_alpha_clr)) / cloud_frac


    #===============================
    # get amount scattered (gamma) and 
    # amount not absorbed (mu)  (absorbtion =1-mu)
    # see Taylor 2007 equation 9 for the equations

    grid_mu=(sw_surf_down / sw_down) * (1.0 - grid_alpha) + grid_A
    grid_mu_clr=(sw_surf_cs_down / sw_down) * (1.0 - grid_alpha_clr)+grid_A_clr
    grid_mu_oc=(grid_mu - ((1-cloud_frac) * grid_mu_clr)) / cloud_frac
    grid_mu_cld=grid_mu_oc / grid_mu_clr

    grid_gamma=((grid_mu - (sw_surf_down / sw_down)) /
                (grid_mu - (grid_alpha * (sw_surf_down / sw_down))))
    grid_gamma_clr=((grid_mu_clr - (sw_surf_cs_down / sw_down)) /
                (grid_mu_clr - (grid_alpha_clr * (sw_surf_cs_down / sw_down))))
    grid_gamma_oc=(grid_gamma - ((1-cloud_frac) * grid_gamma_clr)) / cloud_frac
    grid_gamma_cld=1.0 - ((1.0 - grid_gamma_oc)/(1.0 - grid_gamma_clr))
                 

    # note these values of gamma, alpha and mu have been checked against
    # equations 7 and 8 of Taylor 2007.  Therefore if A is correct and
    # qs_hat_down is correct then gamma alpha and mu are also correct.  

  
    #===============================
    # get fields for use in energy balance calculation
 
    meantemp=np.average(atemp,axis=1)
    mean_sw_up=np.average(sw_up,axis=1)
    mean_sw_down=np.average(sw_down,axis=1)
    mean_sw_surf_cs_down=np.average(sw_surf_cs_down,axis=1)
    mean_sw_surf_down=np.average(sw_surf_down,axis=1)
    mean_lw_toa_up=np.average(lw_toa_up,axis=1)
    mean_lwcs_toa_up=np.average(lwcs_toa,axis=1)
    mean_lw_surf_down=np.average(lw_surf_down,axis=1)
    mean_net_lwdown_surf=np.average(net_lwdown_surf,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_alpha_clr=np.average(grid_alpha_clr,axis=1)
    mean_alpha_oc=np.average(grid_alpha_oc,axis=1)
    mean_alpha=np.average(grid_alpha,axis=1)
    mean_epsilon=np.average(grid_epsilon,axis=1)
    mean_epsilon_cs=np.average(grid_epsilon_cs,axis=1)
    mean_lw_surf_up=np.average(lw_surf_up,axis=1)
    mean_cloud=np.average(cloud_frac,axis=1)
    mean_mu=np.average(grid_mu,axis=1)
    mean_mu_clr=np.average(grid_mu_clr,axis=1)
    mean_mu_oc=np.average(grid_mu_oc,axis=1)
    mean_mu_cld=np.average(grid_mu_cld,axis=1)
    mean_gamma=np.average(grid_gamma,axis=1)
    mean_gamma_clr=np.average(grid_gamma_clr,axis=1)
    mean_gamma_oc=np.average(grid_gamma_oc,axis=1)
    mean_gamma_cld=np.average(grid_gamma_cld,axis=1)
    mean_A=np.average(grid_A,axis=1)
    mean_orog=np.average(orog,axis=1)

    #plt.subplot(3,1,1)
    #plt.plot(lat,mean_alpha-0.1,label='mean_alpha-0.1')
    #plt.plot(lat,mean_alpha_clr,label='mean_alpha_clr')
    #plt.plot(lat,mean_alpha_oc,label='mean_alpha_oc')
    #plt.legend()
    #plt.title('different values')

    #plt.subplot(3,1,2)
    #plt.plot(lat,mean_mu,label='mean_mu')
    #plt.plot(lat,mean_mu_clr,label='mean_mu_clr')
    #plt.plot(lat,mean_mu_oc,label='mean_mu_oc')
    #plt.legend()


    #plt.subplot(3,1,3)
    #plt.plot(lat,mean_gamma,label='mean_gamma')
    #plt.plot(lat,mean_gamma_clr,label='mean_gamma_clr')
    #plt.plot(lat,mean_gamma_oc,label='mean_gamma_oc')  
    #plt.legend()

    #plt.show()
   


    sigma=5.67 * (10.0 ** (-8.))

    #============================================
    # calculate terms in equation
    H=(-1.0) * ((mean_sw_down - mean_sw_up) -(mean_lw_toa_up))
   
    

    t4=((mean_sw_down * (1.0-mean_alpha)) + H) / (mean_epsilon * sigma)
    t=t4 ** (1./4.)


    components=[mean_epsilon,mean_epsilon_cs,mean_alpha_clr,mean_alpha_oc,mean_mu_cld,mean_gamma_cld,mean_mu_clr,mean_gamma_clr,mean_cloud,H,meantemp,mean_sw_down,lat,mean_alpha,mean_mu,mean_gamma,mean_mu_oc,mean_gamma_oc,mean_A,mean_orog]
    return(components)

#end def rf_zonal_enbal


##########################
def main_dh_zonal(preind_expt,plio_expt,pliop2_expt,extra,HadCM3):
    """
    performs the energy baland calculation as detailed in dan hills paper
    """
    # get all the fields needed for the energy balance
    components=dh_zonal_enbal(preind_expt,HadCM3)
    emis_pi=components[0]
    emis_pi_cs=components[1]
    alpha_pi=components[2]
    alpha_pi_cs=components[3]
    H_pi=components[4]
    temp_pi=components[5]
    sw_down_pi=components[6]
    lat=components[7]
    
    components=dh_zonal_enbal(pliop2_expt,HadCM3)
    emis_plio=components[0]
    emis_plio_cs=components[1]
    alpha_plio=components[2]
    alpha_plio_cs=components[3]
    H_plio=components[4]
    temp_plio=components[5]
    sw_down_plio=components[6]
    lat=components[7]

    sigma=5.67 * (10.0**-8)

  

    # we are now decomposing but will also find the average value from 55N-90N
    # create weighting array
    weightarr=np.cos(np.deg2rad(lat))
    for i in range(0,len(lat)):
        if lat[i] < 55:
            weightarr[i]=0.

    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
    t_2=t4 ** (1./4.)

    deltaT_gge=t_1-t_2
    #plt.subplot(2,1,1)
    plt.plot(lat,deltaT_gge,label='GHG+ topography',color="blue")
    print('Arctic T gge',np.average(deltaT_gge,weights=weightarr))


    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
    t_2=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi * sigma)
    t_3=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
    t_4=t4 ** (1./4.)

    deltaT_ce=(t_1-t_2) - (t_3 - t_4)
    print('Arctic T cloud emisivity',np.average(deltaT_ce,weights=weightarr))
    plt.plot(lat,deltaT_ce, label='cloud emissivity',color="orange")

    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio_cs)) + H_plio) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi)) + H_plio) / (emis_plio * sigma)
    t_3=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi_cs)) + H_plio) / (emis_plio * sigma)
    t_4=t4 ** (1./4.)

    deltaT_ca=(t_1-t_2) - (t_3 - t_4)
    plt.plot(lat,deltaT_ca, label='cloud albedo',color="purple")
    print('Arctic T cloud albedo',np.average(deltaT_ca,weights=weightarr))



    t4=((sw_down_plio * (1.0-alpha_plio_cs)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_pi_cs)) + H_plio) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)

    deltaT_csa=t_1-t_2
    plt.plot(lat,deltaT_csa,label='clear sky albedo',color="chocolate",linestyle="dashdot")
    print('Arctic T clear sky albedo',np.average(deltaT_csa,weights=weightarr))



    t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio * sigma)
    t_1=t4 ** (1./4.)
    t4=((sw_down_plio * (1.0-alpha_plio)) + H_pi) / (emis_plio * sigma)
    t_2=t4 ** (1./4.)

    deltaT_H=t_1-t_2
    plt.plot(lat,deltaT_H,label='heat transport',color="red")
    print('Arctic T Heat transport',np.average(deltaT_H,weights=weightarr))
    plt.legend()

    deltaT=temp_plio-temp_pi
    plt.plot(lat,deltaT,label='actual temperature change')
    print('Arctic T total change',np.average(deltaT,weights=weightarr))
    plt.legend()


    plt.ylim(-6.0,12.0)
    mp.pyplot.axhline(y=0,xmin=-90,xmax=90,color='black')
    if HadCM3 == 'y':
        plt.title('Energy balance HadCM3 - Dan Hill')
    else:
        plt.title('Energy balance HadGEM2- Dan Hill')
        
    plt.xlabel('latitude')
    plt.ylabel('pliocene warming')
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/DH_energybal'+pliop2_expt+'-'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

# end of main part of Dan Hills energy balance



################################
# main program

# annual mean

#preind_expt='xkvje'
#plio_expt='xkvjf'
#pliop2_expt='xkvjg'
#extra='n'
#HadCM3='n'

preind_expt='xibos'
plio_expt='xibot'
pliop2_expt='xibot'
HadCM3='y'
extra=' '


global_enbal(preind_expt,HadCM3)
global_enbal(pliop2_expt,HadCM3)


# Dan Hills energy balance
main_dh_zonal(preind_expt,plio_expt,pliop2_expt,extra,HadCM3)


# Ran Fengss energy balance


components=rf_zonal_enbal(preind_expt,HadCM3)
emis_pi=components[0]
emis_pi_cs=components[1]
alpha_pi_clr=components[2]
alpha_pi_oc=components[3]
mu_pi_cld=components[4]
gamma_pi_cld=components[5]
mu_pi_clr=components[6]
gamma_pi_clr=components[7]
cloud_pi=components[8]
H_pi=components[9]
temp_pi=components[10]
sw_down_pi=components[11]
lat=components[12]
alpha_pi=components[13]
mu_pi=components[14]
gamma_pi=components[15]
mu_pi_oc=components[16]
gamma_pi_oc=components[17]
pi_A=components[18]
topo_pi=components[19]


components=rf_zonal_enbal(pliop2_expt,HadCM3)
emis_plio=components[0]
emis_plio_cs=components[1]
alpha_plio_clr=components[2]
alpha_plio_oc=components[3]
mu_plio_cld=components[4]
gamma_plio_cld=components[5]
mu_plio_clr=components[6]
gamma_plio_clr=components[7]
cloud_plio=components[8]
H_plio=components[9]
temp_plio=components[10]
sw_down_plio=components[11]
lat=components[12]
alpha_plio=components[13]
mu_plio=components[14]
gamma_plio=components[15]
mu_plio_oc=components[16]
gamma_plio_oc=components[17]
plio_A=components[18]
topo_plio=components[19]


delta_T_topo=(topo_plio-topo_pi) * (-5.5) / 1000.
sigma=5.67 * (10.0**-8)

# print j corresponding to 75deg
for j in range(0,len(lat)):
    if lat[j]==75:
        lat75=j
        print(j,lat[j])

#taylor 2007 equation 16 a-c and 7
# note the equation 16a is misleading.  I think it should be
#delta_A_alpha=(1-c)delta_A_alpha_clr + c*delta_A_alpha_oc 

# get the change in albedo due to alpha


# new use mean values
mu=(mu_plio+mu_pi)/2.0
gamma=(gamma_plio+gamma_pi)/2.0
alpha=(alpha_plio+alpha_pi)/2.0
cloud=(cloud_plio+cloud_pi)/2.0

A_alpha_pi_clr=((mu * gamma) + ((mu * alpha_pi_clr * (1.0-gamma)**2.0)/ (1.0 - alpha_pi_clr * gamma)))
A_alpha_plio_clr=((mu * gamma) + ((mu * alpha_plio_clr * (1.0-gamma)**2.0)/ (1.0 - alpha_plio_clr * gamma)))
A_alpha_pi_oc=((mu * gamma) + ((mu * alpha_pi_oc * (1.0-gamma)**2.0)/ (1.0 - alpha_pi_oc * gamma)))
A_alpha_plio_oc=((mu * gamma) + ((mu * alpha_plio_oc * (1.0-gamma)**2.0)/ (1.0 - alpha_plio_oc * gamma)))
A_alpha_diff=(1.0-cloud)*(A_alpha_plio_clr - A_alpha_pi_clr)+cloud*(A_alpha_plio_oc - A_alpha_pi_oc)
A_alpha_plio=(1.0-cloud)*A_alpha_plio_clr + cloud*A_alpha_plio_oc
A_alpha_pi=(1.0-cloud)*A_alpha_pi_clr + cloud*A_alpha_pi_oc
# julia print out at 75N
print('surface alpha at 75',A_alpha_diff[lat75],A_alpha_plio[lat75],A_alpha_pi[lat75])

# get the change in albedo due to clouds eqn 16b


A_cld_pi_gamma=((mu * gamma_pi_cld) + ((mu * alpha * (1.0-gamma_pi_cld)**2.0)/ (1.0 - alpha * gamma_pi_cld)))
A_cld_plio_gamma=((mu * gamma_plio_cld) + ((mu * alpha * (1.0-gamma_plio_cld)**2.0)/ (1.0 - alpha * gamma_plio_cld)))
A_cld_pi_mu=((mu_pi_cld * gamma) + ((mu_pi_cld * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_cld_plio_mu=((mu_plio_cld * gamma) + ((mu_plio_cld * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))

# equation 15 A=(a-c)Aclr + c Aoc

mu_clr=(mu_plio_clr + mu_pi_clr)/2.0
gamma_clr=(gamma_plio_clr + gamma_pi_clr)/2.0
alpha_clr=(alpha_plio_clr + alpha_pi_clr)/2.0
mu_oc=(mu_plio_oc + mu_pi_oc)/2.0
gamma_oc=(gamma_plio_oc + gamma_pi_oc)/2.0
alpha_oc=(alpha_plio_oc + alpha_pi_oc)/2.0

clravg=((mu_clr * gamma_clr) + ((mu_clr * alpha_clr * (1.0-gamma_clr)**2.0)/ (1.0 - alpha_clr * gamma_clr)))
ocavg=((mu_oc * gamma_oc) + ((mu_oc * alpha_oc * (1.0-gamma_oc)**2.0)/ (1.0 - alpha_oc * gamma_oc)))
A_deltaC=((cloud_pi-cloud_plio)*clravg)+((cloud_plio-cloud_pi)*ocavg)


A_cld_diff=A_cld_plio_mu-A_cld_pi_mu + A_cld_plio_gamma-A_cld_pi_gamma + A_deltaC

# julia print out at 75N
print('cloud A at 75',A_cld_diff[lat75])



# get the change in albedo due to clear skies


A_clr_pi_mu=((mu_pi_clr * gamma) + ((mu_pi_clr * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_clr_plio_mu=((mu_plio_clr * gamma) + ((mu_plio_clr * alpha * (1.0-gamma)**2.0)/ (1.0 - alpha * gamma)))
A_clr_pi_gamma=((mu * gamma_pi_clr) + ((mu * alpha * (1.0-gamma_pi_clr)**2.0)/ (1.0 - alpha * gamma_pi_clr)))
A_clr_plio_gamma=((mu * gamma_plio_clr) + ((mu * alpha * (1.0-gamma_plio_clr)**2.0)/ (1.0 - alpha * gamma_plio_clr)))
A_clr_diff=(A_clr_plio_mu - A_clr_pi_mu)+(A_clr_plio_gamma - A_clr_pi_gamma)
print('clr A at 75',A_clr_diff[lat75],A_clr_plio_mu[lat75],A_clr_pi_mu[lat75],A_clr_plio_gamma[lat75],A_clr_pi_gamma[lat75],cloud_pi[lat75],cloud_plio[lat75])


# get change in planetary albedo to check budgets

A_diff=plio_A-pi_A


#plt.subplot(2,1,1)
plt.plot(lat,A_alpha_diff,label='A_alpha')
plt.plot(lat,A_cld_diff,label='A_cld')
plt.plot(lat,A_clr_diff,label='A clr diff')
plt.plot(lat,A_diff,label='total planetary Albedo diff')
plt.plot(lat,A_alpha_diff+A_cld_diff+A_clr_diff,label='sum')
plt.legend()
plt.title('plio-pi A components')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_albedo'+pliop2_expt+'-'+preind_expt+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  

plt.close()


#print values at 75N in plot
print('A_alpha_diff',A_alpha_diff[lat75])
print('A_cld_diff',A_cld_diff[lat75])
print('A_clr_diff',A_clr_diff[lat75])
print('A_diff',A_diff[lat75])
print(' ')



# we are now decomposing but will also find the average value from 55N-90N
# create weighting array
weightarr_Arctic=np.cos(np.deg2rad(lat))
for i in range(0,len(lat)):
    if lat[i] < 55:
        weightarr_Arctic[i]=0.
weightarr=np.cos(np.deg2rad(lat))

t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_plio_cs * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-alpha_plio)) + H_plio) / (emis_pi_cs * sigma)
t_2=t4 ** (1./4.)

deltaT_gge=t_1-t_2 - delta_T_topo


#plt.subplot(2,1,2)
fig=plt.figure()
ax=plt.subplot(111)
ax.plot(lat,deltaT_gge,label='Greenhouse gas emissivity',color="blue")
#plt.plot(lat,delta_T_topo,label='topography')
print('Arctic T gge',np.average(deltaT_gge,weights=weightarr_Arctic))
print('Arctic T topo',np.average(delta_T_topo,weights=weightarr_Arctic))


t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio_cs * sigma)
t_2=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_pi * sigma)
t_3=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_pi_cs * sigma)
t_4=t4 ** (1./4.)

deltaT_ce=(t_1-t_2) - (t_3 - t_4)
print('Arctic T cloud emisivity',np.average(deltaT_ce,weights=weightarr_Arctic))
ax.plot(lat,deltaT_ce, label='cloud emissivity',color="orange")

# surface albedo

t4=((sw_down_plio * (1.0-A_alpha_plio)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-A_alpha_pi)) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_surfalpha=(t_1-t_2) 
ax.plot(lat,deltaT_surfalpha, label='surface albedo',color="chocolate",linestyle='dotted')
print('Arctic T surface albedo',np.average(deltaT_surfalpha,weights=weightarr_Arctic))

# check alternate value for surface (this seems to work fine)
# we did this to check how we had done clear sky and cloud
t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_alpha_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_altsurf=t_1-t_2
#plt.plot(lat,deltaT_altsurf,label='alt surface albedo')
print('Arctic T altsurf',np.average(deltaT_altsurf,weights=weightarr_Arctic))


# clear sky albedo

t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_clr_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_csalbedo=t_1-t_2
ax.plot(lat,deltaT_csalbedo,label='clear sky albedo',color="chocolate",linestyle="dashed")
print('Arctic T csalbedo',np.average(deltaT_csalbedo,weights=weightarr_Arctic))

#cloud albedo

t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-(plio_A-A_cld_diff))) + H_plio) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_cldalbedo=t_1-t_2
ax.plot(lat,deltaT_cldalbedo,label='cloud albedo',color="purple")
print('Arctic T cloud albedo',np.average(deltaT_cldalbedo,weights=weightarr_Arctic))



t4=((sw_down_plio * (1.0-plio_A)) + H_plio) / (emis_plio * sigma)
t_1=t4 ** (1./4.)
t4=((sw_down_plio * (1.0-plio_A)) + H_pi) / (emis_plio * sigma)
t_2=t4 ** (1./4.)

deltaT_H=t_1-t_2
ax.plot(lat,deltaT_H,label='heat transport',color="red")
print('Arctic T Heat transport',np.average(deltaT_H,weights=weightarr_Arctic))

deltaT=temp_plio-temp_pi
#plt.plot(lat,deltaT,label='actual temperature change')
print('Arctic T total change',np.average(deltaT,weights=weightarr_Arctic))


total_components=deltaT_gge+deltaT_ce+deltaT_surfalpha+deltaT_csalbedo+deltaT_cldalbedo+deltaT_H
#plt.plot(lat,total_components,label='total accountable')


deltaT_cloud=deltaT_ce+deltaT_cldalbedo

print('Mean T gge',np.average(deltaT_gge,weights=weightarr))
print('Mean T topo',np.average(delta_T_topo,weights=weightarr))
print('Mean T cloud emisivity',np.average(deltaT_ce,weights=weightarr))
print('Mean T surface albedo',np.average(deltaT_surfalpha,weights=weightarr))
print('Mean T csalbedo',np.average(deltaT_csalbedo,weights=weightarr))
print('Mean T cloud albedo',np.average(deltaT_cldalbedo,weights=weightarr))
print('Mean T Heat transport',np.average(deltaT_H,weights=weightarr))
print('Mean T total change',np.average(deltaT,weights=weightarr))






print('Mean cloud changes',np.average(deltaT_cloud,weights=weightarr))


plt.ylim(-4.0,8.0)
mp.pyplot.axhline(y=0,xmin=-90,xmax=90,color='black')
if HadCM3 == 'y':
    plt.title('d) Energy Balance: HadCM3',loc='left',fontsize=18)
else:
    plt.title('c) Energy Balance: HadGEM2',loc='left',fontsize=18)
plt.xlabel('Latitude',fontsize=15)
degC=u'\N{DEGREE SIGN}'+'C'
plt.ylabel('Pliocene Warming ('+degC+')',fontsize=15)


plt.legend(fontsize=15)
plt.tick_params(axis='both',labelsize=15)
box=ax.get_position()
ax.set_position([box.x0,box.y0+box.height*0.1,box.width,box.height*0.9])
ax.legend(loc='lower center',bbox_to_anchor=(0.5,-0.4),ncol=3)


fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_energybal'+pliop2_expt+'-'+preind_expt+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_energybal'+pliop2_expt+'-'+preind_expt+'.png' 
plt.savefig(fileout, bbox_inches='tight')  

plt.close()

filetext='/home/earjcti/PYTHON/PLOTS/HadGEM2/plot_energybal/RF_energybal'+pliop2_expt+'-'+preind_expt+'.tex'
f= open(filetext,"w+")
f.write('latitude,Greenhouse gas emissivity,Cloud emissivity,surfacealbedo,'+
        'clear sky albedo,cloud albedo,heat_transport \n')
for i in range(0,len(lat)):
    f.write(np.str(lat[i])+','+np.str(deltaT_gge[i])+','+
            np.str(deltaT_ce[i])+','+
            np.str(deltaT_surfalpha[i])+','+
            np.str(deltaT_csalbedo[i])+','+
            np.str(deltaT_cldalbedo[i])+','+np.str(deltaT_H[i])
            +'\n')
f.close()


####

::::::::::::::
plot_MOC.py
::::::::::::::

#!/usr/bin/env python2.7
#NAME
#    PLOT_MOC
#PURPOSE
#    This program will do some plots on the MOC (which were calculated in the 
#    ~earjcti/MOC directory
#
# search for 'main program' to find end of functions
# Julia 14/1/2017



import os
import numpy as np
import scipy as sp
import scipy.signal as sig
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize



#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,V,uselog,cbarname,pcplot):
    lats, depths = np.meshgrid(lat,dep)

    if pcplot == 'avg':
        plt.subplot(1,1,1)
    else:
        if pcplot == 'pc':
            plt.subplot(2,2,fileno+1)
        else:
            plt.subplot(5,2,fileno+1)

    V=np.arange(minval,maxval,valinc)
    if pcplot =='pc':
        cs = plt.contourf(lats,depths,plotdata,V,cmap='RdBu_r',extend='both')
    else:
        cs = plt.contourf(lats,depths,plotdata,V,extend='both')
    plt.gca().invert_yaxis()
    plt.title(titlename)

    if pcplot != 'n' or fileno >9:
        cbar = plt.colorbar(cs,orientation="horizontal")
        cbar.set_label(cbarname,labelpad=-40)



#end def plotdata

def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='at':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(x),np.shape(y),np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotmap


def indexplot(toplot,xdata,fileno,data_sm,xmin,xmax,expt,xlabel,ymin,ymax,titlename):
    plt.subplot(4,2,fileno*2)
    print(fileno)

    plt.xlim([xmin,xmax])
    plt.ylim([ymin,ymax])
    datasize=len(toplot)

    
    # plot data
    plt.plot(xdata,toplot)
    plt.title(titlename)
    plt.xlabel(xlabel)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

##################################################
def plot_avg_moc(expt_name,extra,yearstart,yearend):

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)
        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))

        allAMOC[year-yearstart,:,:]=AMOC
        f.close()

    avgAMOC=np.mean(allAMOC,axis=0)
    print(np.shape(avgAMOC))
    titlename='AMOC avg: '+expt_name
    plotdata(avgAMOC,-99,lat,depth,titlename,-18,20,2.0,0.0,'n','Sv','avg')
        
    plt.tight_layout()
    plt.show()
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_avg.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    
    return(lat,depth,avgAMOC)
    
    
#end def plot_avg_MOC
#======================================================
def amoc_diff(expt_name,cntl_name,AMOC_e,AMOC_c,lat,depth):
# this function will difference two AMOCs
    AMOC_diff=AMOC_e-AMOC_c
    titlename='diff '+expt_name+'  and '+cntl_name
    plotdata(AMOC_diff,-99,lat,depth,titlename,-4,5,1.0,0.0,'n','Sv','avg')
    plt.tight_layout()
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'-'+cntl_name+'_avg.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    
#end def amoc_diff
#==========================================
def plot_all_moc(expt_name,extra,yearstart,yearend,plotallyears):

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)

        if plotallyears == 'y':
            titlename='AMOC yr:'+str(year)
            plotdata(AMOC,figcount,lat,depth,titlename,-30,30,5.0,0.0,'n','Sv')
            if figcount == 9:
                plt.tight_layout()
                plt.show()
                sys.exit()
            figcount=(figcount+1)%10
          
        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))

        allAMOC[year-yearstart,:,:]=AMOC
        f.close()
    

    sys.exit()
    
    
#end def plot_all_MOC
#######################################
# do principal component analysis to find the periods over which the MOC varies
def MOC_PC(expt_name,extra,yearstart,yearend):

# read in data

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend+1):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)

        # mask out region south of equator
        ix1=(lat >=0)
        lats_reg=lat[ix1]
        nlat=len(lats_reg)
        lat=lats_reg
        AMOC=AMOC[:,ix1]
    

        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))
            
        print(yearend-yearstart,year-yearstart,nyears)
        allAMOC[year-yearstart,:,:]=AMOC
        f.close()


    

  
    # remove time average from all AMOC 
    for j in range(0,nlat):
        for i in range(0,ndepth):
            allAMOC[:,i,j]=allAMOC[:,i,j]-np.mean(allAMOC[:,i,j])
    
    # ideally we will need to multiply by a weighting factor to account for the fact that all latitudes have a different number of gridboxes at different sizes


    # reshape and transpose the data to the correct dimension
    print('amoc shape',np.shape(allAMOC),nlat,ndepth,nyears)
    rs_allAMOC_nt=np.reshape(allAMOC,(nyears,nlat*ndepth))
    rs_allAMOC=np.transpose(rs_allAMOC_nt)

    # do a PC analysis using sklearn
    neofs=2
    AMOCpca=sk.PCA(n_components=neofs)
    AMOCpca.fit(rs_allAMOC)
    expl_var=AMOCpca.explained_variance_ratio_
    EOFs=AMOCpca.transform(rs_allAMOC)
    
    # scale so each EOF has unit length
    EOFs=normalize(EOFs,axis=0)

    # get principal components
    PCs=np.mat(rs_allAMOC_nt) * np.mat(EOFs)

    for i in range(0,neofs):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(ndepth,nlat))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc
        
        titlename='PC'+str(i+1)+':'+expt_name+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lat,depth,titlename,-2.0,2.2,0.2,0,'n','Sv','pc')
        
        toplot=PCs[:,i]
        datasize=len(toplot)
        xdata=np.arange(datasize)
        indexplot(toplot,xdata,(2*i)+1,toplot,0,nyears,expt_name,'year',-2.0,2.0,'index')

        # do a spectral analysis on the index
        # to see over which periods it is varying

        print('toplot is',toplot)
        toplot=np.squeeze(toplot)

        Pxx_f, Pxx_den=sig.periodogram(toplot,1.0)
        Pxx_den=np.squeeze(Pxx_den)
        print('PXx',Pxx_f,'size',np.shape(Pxx_f),np.shape(toplot))
        print('pxx2',Pxx_den,'size',np.shape(Pxx_den))
        indexplot(Pxx_den,Pxx_f,(2*i)+2,Pxx_den,0,0.5,expt_name,'cycles per year',0,10,'index power spectrun')
        

    plt.tight_layout()
  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_PCs.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


#  write both indexes out to a file

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_PCs.txt' 
    f1=open(fileout,'w+')
    f1.write('strength of principal components')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra year  PC1    PC2 \n')
    for year in range (yearstart,yearend+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        print(year,yearstart,yearend,np.shape(PCs))
        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-yearstart,0])+';'+str(PCs[year-yearstart,1])+'\n')
    f1.close()
        


# 

#end def annmean

# relate principal components to climate
def PCs_to_climate_telecon(exptname,fieldlocation,fileext,fieldname,seasname,monthnames,lonname,latname):
 
# this will plot the teleconnections associated with the MOC principal 
# components by taking the
# most exteme 5% of the MOC years and plotting the climate anomaly


    # read in the MOC principal components

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+exptname+'_PCs.txt' 
    f=open(filein,'r')
    # get titleline which contains number of years
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    print(b)
    c=b[3]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()

   
    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    PC1index=np.zeros(nyears)
    PC2index=np.zeros(nyears)
    extremePC1=np.zeros(nyears)  # here we mark the 5% most extreme values
    extremePC2=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and NAOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        PC1index[count]=linesplit[2]
        PC2index[count]=linesplit[3]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowPC1=sorted(zip(PC1index,extraindex,yearindex))[:num_extr]
    uppPC1=sorted(zip(PC1index,extraindex,yearindex),reverse=True)[:num_extr]
    lowPC2=sorted(zip(PC2index,extraindex,yearindex))[:num_extr]
    uppPC2=sorted(zip(PC2index,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/'+fieldlocation+'/'
    os.chdir(dirname)

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        print(allfiles)
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()
        f.close()
        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1

                

    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    for ex in range(0,2):     # loop for lowest or highest year
        for npcs in range (0,2):   # we will have to loop over PCS
            if ex == 0:
                if npcs == 0: 
                    extremedata=lowPC1
                if npcs == 1:
                    extremedata=lowPC2
            if ex == 1:
                if npcs == 0:
                    extremedata=uppPC1
                if npcs == 1:
                    extremedata=uppPC2


            for time in range (0,num_extr):
                for monthno in range (0,nmonths):
                    singleline=extremedata[time]
                    yearuse=int(singleline[2])
                    extrause=singleline[1]
                    month=monthnames[monthno]

                    if seasname == 'djf-1' and month == 'dc':
                        yearuse=yearuse-1

                    if seasname == 'djf+1' and month == 'ja':
                        yearuse=yearuse+1

                    if seasname == 'djf+1' and month == 'fb':
                        yearuse=yearuse+1

                    if yearuse >= 100:
                        yearuse=yearuse-100
                        extrause=chr(ord(extrause)+1)
                                    
                    if yearuse < 0:
                        yearuse=yearuse+100
                        extrause=chr(ord(extrause)-1)
                                        
                    yearfname=str(yearuse)

                    if yearuse < 10:
                        yearfname='0'+str(yearuse)
                        

                    fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                    f=Dataset(fname,mode='r')
                    lat = f.variables[latname][:]
                    latsize=len(lat)
                    lon = f.variables[lonname][:]
                    lonsize=len(lon)
                    lontemp=lon

                    if len(fieldname) ==1 :
                        atemp=f.variables[fieldname[0]][:]
                        atemp=np.squeeze(atemp)

                    if len(fieldname) == 2:
                        atemp=f.variables[fieldname[0]][:]
                        atemp=np.squeeze(atemp)
                        atemp2=f.variables[fieldname[1]][:]
                        atemp2=np.squeeze(atemp2)
                        
                    if len(fieldname) > 2:
                        print('you are requesting too many variables')
                        sys.exit()
    

                    # set array for storing average
                    if monthno == 0 and time == 0:
                        temp_extreme=atemp
                        count=1
                        count2=1
                        temp2_extreme=0.
                        if len(fieldname)==2:
                            temp2_extreme=atemp2
                    else:
                        temp_extreme=temp_extreme+atemp
                        count=count+1
                        if len(fieldname)==2:
                            temp2_extreme=temp2_extreme+atemp2
                            count2=count2+1

            # put temperature data in lower or higher catogry
            if ex == 0:
                if npcs == 0: 
                    temp_low_PC1=temp_extreme/count
                    temp2_low_PC1=temp2_extreme/count2
                if npcs == 1: 
                    temp_low_PC2=temp_extreme/count
                    temp2_low_PC2=temp2_extreme/count2
            if ex == 1:
                if npcs == 0: 
                    temp_high_PC1=temp_extreme/count
                    temp2_high_PC1=temp2_extreme/count2
                if npcs == 1: 
                    temp_high_PC2=temp_extreme/count
                    temp2_high_PC2=temp2_extreme/count2


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low_PC1,lon = shiftgrid(180.,temp_low_PC1,lon,start=False)    
    lon=lontemp
    temp_high_PC1,lon = shiftgrid(180.,temp_high_PC1,lon,start=False)    
    lon=lontemp
    temp_low_PC2,lon = shiftgrid(180.,temp_low_PC2,lon,start=False)    
    lon=lontemp
    temp_high_PC2,lon = shiftgrid(180.,temp_high_PC2,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    



    if fieldname[0] == 'temp_1':  # temperature data
        plotmap(temp_low_PC1-temp_avg,0,lon,lat,'low PC1 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_high_PC1-temp_avg,1,lon,lat,'high PC1 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_low_PC2-temp_avg,2,lon,lat,'low PC2 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_high_PC2-temp_avg,3,lon,lat,'high PC2 Tanom',-2.2,2.0,0.2,0,'at','degC')
       

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_tempanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.show()
        plt.close()


        titlename=exptname+' low seas temp'
        plotmap(temp_low_PC1-273.15,0,lon,lat,'low PC1 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_high_PC1-273.15,1,lon,lat,'high PC1 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_low_PC2-273.15,2,lon,lat,'low PC2 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_high_PC2-273.15,3,lon,lat,'high PC2 temp',-40.0,40.0,10.0,0,'n','degC')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_temp'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()

    


      


    if fieldname[0] == 'p':  # mean se level pressure data
        plotmap((temp_low_PC1-temp_avg)/100.,0,lon,lat,'low PC1 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_high_PC1-temp_avg)/100.,1,lon,lat,'high PC1 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_low_PC2-temp_avg)/100.,2,lon,lat,'low PC2 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_high_PC2-temp_avg)/100.,3,lon,lat,'high PC2 mslp anom',-5.,6.,1.,0,'at','hPa')
       

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_mslpanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()

        plotmap(temp_low_PC1/100.,0,lon,lat,'low PC1 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_high_PC1/100.,1,lon,lat,'high PC1 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_low_PC2/100.,2,lon,lat,'low PC2 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_high_PC2/100.,3,lon,lat,'high PC2 mslp',980.,1040.,5,0,'n','hPa')


        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_mslp_'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight') 
        plt.show()
        plt.close()

    


       

    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotmap(temp_low_PC1*60.*60.*24.*30.,0,lon,lat,'low PC1 precip',-0,275,25,0,'n','mm/month')
        plotmap(temp_high_PC1*60.*60.*24.*30.,1,lon,lat,'high PC1 precip',0,275,25,0,'n','mm/month')
        plotmap(temp_low_PC2*60.*60.*24.*30.,2,lon,lat,'low PC2 precip',-0,275,25,0,'n','mm/month')
        plotmap(temp_high_PC2*60.*60.*24.*30.,3,lon,lat,'high PC2 precip',0,275,25,0,'n','mm/month')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()


        plotmap((temp_low_PC1-temp_avg)*60.*60.*24.*30.,0,lon,lat,'low PC1 panom',-30,35,5,0,'a','mm/month')
        plotmap((temp_high_PC1-temp_avg)*60.*60.*24.*30.,1,lon,lat,'high PC1 panom',-30,35,5,0,'a','mm/month')

        plotmap((temp_low_PC2-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low PC2 panom',-30,35,5,0,'a','mm/month')
        plotmap((temp_high_PC2-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high PC2 panom',-30,35,5,0,'a','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precipanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()

        # if precip also do percentage change
        pcent_low_PC1=((temp_low_PC1-temp_avg)/temp_avg)*100.
        pcent_high_PC1=((temp_high_PC1-temp_avg)/temp_avg)*100.
        pcent_low_PC2=((temp_low_PC2-temp_avg)/temp_avg)*100.
        pcent_high_PC2=((temp_high_PC2-temp_avg)/temp_avg)*100.
        titlename=exptname+' low PC1 precip anom'
        plotmap(pcent_low_PC1,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotmap(pcent_high_PC1,1,lon,lat,'high PC1 Precip anomaly',-50,60,5,0,'a','%')
        plotmap(pcent_low_PC2,2,lon,lat,'low PC2 precip anomaly',-50,60,5,0,'a','%')
        plotmap(pcent_high_PC2,3,lon,lat,'high PC2 Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
 
#end def PCs_to_climate

################################
# main program


##################################
# plot average of the MOC

#retdata=plot_avg_moc('xkvje','n',1,99)
#lat=retdata[0]
#depth=retdata[1]
#xkvje_AMOC=retdata[2]

#retdata=plot_avg_moc('xkvjf','n',1,98)
#xkvjf_AMOC=retdata[2]

#retdata=xkvjg_AMOC=plot_avg_moc('xkvjg','n',1,99)
#xkvjg_AMOC=retdata[2]

################################################
# difference of two AMOCs
#amoc_diff('xkvjg','xkvje',xkvjg_AMOC,xkvje_AMOC,lat,depth)
#amoc_diff('xkvjf','xkvje',xkvjf_AMOC,xkvje_AMOC,lat,depth)


##################################################
# plot all years of the MOC

#plt.figure(figureno)
#plotallyears='y'
#plot_all_moc('xkvjg','n',1,99,plotallyears)
#figureno=figureno+1

###########################################################################
# Principal component analysis to determine periods of variability in the MOC

#MOC_PC('xkvje','n',1,98)
#MOC_PC('xkvjg','n',1,98)

#############################################################
# Relate extreme values of PC's to climate


# usage Pcs_to_climate(expt_name',dirname,fileextension,fieldname,monthnames)
PCs_to_climate_telecon('xkvjg','temp_data','_temp.nc',['temp_1'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')

PCs_to_climate_telecon('xkvjg','precip_data','_precip.nc',['precip_1'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')

PCs_to_climate_telecon('xkvjg','mslp_data','_mslp.nc',['p'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')





sys.exit(0)

####

::::::::::::::
plot_NAO.py
::::::::::::::
#all!/usr/bin/env python2.7
#NAME
#    PLOT_NAO
#PURPOSE
#    This program will attempt to use principal component analysis to 
#    calculate the NAO and associated diagnostics
#
# search for 'main program' to find end of functions
# Julia 15/12/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from  matplotlib.mlab import PCA 
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot NAO index on a line graph
#  def fullprint  print full array for debugging
#  get_PC_allmonths   gets principal components and plots them (all data)
#  get_pc_seas  gets principal components for a given season

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(x),np.shape(y),np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

#===============================================================
def plotquiver(udata,vdata,lon,lat,fileno,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver



def indexplot(toplot,fileno,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt):
    plt.subplot(2,2,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    datasize=len(toplot)
    xdata=np.arange(datasize)
    
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='NAO index '+expt
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint



#===============================================
def get_PC_allmonths(exptname):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E


    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    full_file_paths =  glob.glob("*a@pd*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    ntimes=nfiles
    if nfiles==0:
        print('there are no files in directory',dirname)
        sys.exit(0)


    # get the information from the files
    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

        mslp=f.variables['p'][:] 
        mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

        lon=lontemp
        mslp,lon = shiftgrid(180.,mslp,lon,start=False)

        ix1=(lon >=-90) & (lon <=40)
        ix2=(lat >=20) & (lat <=80)
        lats_reg=lat[ix2]
        lons_reg=lon[ix1]
        
        SLPint=mslp[ix2]
        MSLP=SLPint[:,ix1]

        MSLP=np.squeeze(MSLP)
        MSLP=MSLP/100. # convert to millibars
        
        latsize=len(lats_reg)
        lonsize=len(lons_reg)
        

        if count == 0:  # arrays for storing all data
           all_MSLP = np.empty((ntimes,latsize,lonsize)) #storing all data
           month_ss = np.zeros(ntimes)  # month indicator for all_MSLP
           month_MSLP=np.zeros((12,latsize,lonsize)) # for storing average month
           monthcount=np.zeros(12) # no of years for each month
 

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        if count == 0:
            yearstart=year
            monthstart=11 # assumed first month is december.  Will need
                          # to recode if not the case

        time=((year-yearstart)*12)+monthno-monthstart
        all_MSLP[time,:,:]=MSLP
        month_ss[time]=monthno
        month_MSLP[monthno,:,:]=month_MSLP[monthno,:,:]+MSLP
        monthcount[monthno]=monthcount[monthno]+1
        count=count+1


    # get all the averages
 
    # average annual cycle
    month_MSLP=month_MSLP/monthcount[:,np.newaxis,np.newaxis]


    # remove annual average from all_MSLP
    for t in range(0,ntimes):
        subscript=month_ss[t]
        all_MSLP[t,:,:]=all_MSLP[t,:,:]-month_MSLP[subscript,:,:]
    # subtract mean from each point
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))

    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lon_reg,lat_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lons,latsize*lonsize)

    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs))
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)

    #if EOFs[j,0] < 0.0:

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC v2 '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    plt.show()
    


#===============================================
def get_PC_seas(exptname,monthnames,extra,startyear,endyear):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E

    nmonths=len(monthnames)
    seasname=''  # get seasonname by using first letter of each month
    for mon in monthnames:
        seasname=seasname+mon[0]

    if nmonths > 4:
        print('check that you have accurately accounted for winter season overlap')
        sys.exit()

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    for year in range (startyear,endyear+1):
        for monthno in range (0,nmonths):
            yearuse=year
            extrause=extra
            month=monthnames[monthno]
            if month == 'dc' and nmonths > 1:
                yearuse=year-1
            if month == 'nv' and nmonths > 2:
                yearuse=year-1
            if month == 'ot' and nmonths > 3:
                yearuse=year-1
            if month == 'sp' and nmonths > 4:
                yearuse=year-1
            if yearuse >= 100:
                yearuse=yearuse-100
                extrause=chr(ord(extra)+1)

            if yearuse < 0:
                yearuse=yearuse+100
                extrause=chr(ord(extra)-1)

            yearfname=str(yearuse)

            if yearuse < 10:
                yearfname='0'+str(yearuse)

            
            fname=dirname+exptname+'a@pd'+extrause+yearfname+month+'_mslp.nc'
            print(fname)

            f=Dataset(fname,mode='r')
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

            mslp=f.variables['p'][:] 
            mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

            lon=lontemp
            mslp,lon = shiftgrid(180.,mslp,lon,start=False)

            ix1=(lon >=-90) & (lon <=40)
            ix2=(lat >=20) & (lat <=80)
            lats_reg=lat[ix2]
            lons_reg=lon[ix1]
            
            SLPint=mslp[ix2]
            MSLP=SLPint[:,ix1]
            
            MSLP=np.squeeze(MSLP)
            MSLP=MSLP/100. # convert to millibars
 
            latsize=len(lats_reg)
            lonsize=len(lons_reg)
            
            if year == startyear and monthno == 0:  # arrays to store all data
                all_MSLP = np.zeros((ntimes,latsize,lonsize)) 
                

            all_MSLP[year-startyear,:,:]=all_MSLP[year-startyear,:,:]+MSLP
            # this is the end of the loop over years and months

           
           
    
    all_MSLP=all_MSLP/nmonths
   
    # remove average from MSLP
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    #plotdata(all_MSLP[0,:,:],0,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))


    #plotdata(all_MSLP[0,:,:],1,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')
    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lons_reg,lats_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lats,latsize*lonsize)

    rs_MSLP=np.transpose(rs_MSLP_nt)


    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs)) 
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)
    # check EOF1 has low (negative pressure over Iceland)
    lons,lats 
    ixuse=(lons == -18.75) & (lats == 65.)
    
    if EOFs[ixuse,0] >= 0:
        EOFs[:,0]=EOFs[:,0] * -1.0

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC'+str(i+1)+':'+exptname+'_'+seasname+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

#   write out the NAO index to a file
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.txt' 
    f1=open(fileout,'w+')
    f1.write('nino index from PC1 of mslp in North Atlantic region \n')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra  year  NAO index\n')
    for year in range (startyear,endyear+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-startyear,0])+'\n')
    f1.close()
        

#=========================================
def get_NAO_seas_telecon(exptname,seasname,extra,startyear,endyear,monthnames,latname,lonname,fieldname,fieldlocation,fileext):
# this will plot the teleconnections associated with the NAO by taking the
# most exteme 5% of the NAO years and plotting the climate anomaly


    # read in the NAO index

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.txt' 
    f=open(filein,'r')
    # discard titleline
    textline=f.readline()
    # get number of years from next line
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    c=b[0]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()



    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    NAOindex=np.zeros(nyears)
    extremeindex=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and NAOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        NAOindex[count]=linesplit[2]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowdata=sorted(zip(NAOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(NAOindex,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)
    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+fieldlocation
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
         
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()

        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1


    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    lowdata=sorted(zip(NAOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(NAOindex,extraindex,yearindex),reverse=True)[:num_extr]

    # lowest and highest years
    for ex in range(0,2):
        # are we doing highest or lowest
        if ex == 0:
            extremedata=lowdata
        if ex == 1:
            extremedata=uppdata

        for time in range (0,num_extr):
            for monthno in range (0,nmonths):
                singleline=extremedata[time]
                yearuse=int(singleline[2])
                extrause=singleline[1]
                month=monthnames[monthno]
                if month == 'dc' and nmonths > 1:
                    yearuse=yearuse-1
                if month == 'nv' and nmonths > 2:
                    yearuse=yearuse-1
                if month == 'ot' and nmonths > 3:
                    yearuse=yearuse-1
                if month == 'sp' and nmonths > 4:
                    yearuse=yearuse-1
                if yearuse >= 100:
                    yearuse=yearuse-100
                    extrause=chr(ord(extrause)+1)
                                    
                if yearuse < 0:
                    yearuse=yearuse+100
                    extrause=chr(ord(extrause)-1)
                                        
                yearfname=str(yearuse)

                if yearuse < 10:
                    yearfname='0'+str(yearuse)

                fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                print(fname)

                f=Dataset(fname,mode='r')
                lat = f.variables[latname][:]
                latsize=len(lat)
                lon = f.variables[lonname][:]
                lonsize=len(lon)
                lontemp=lon

                if len(fieldname) ==1 :
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)

                if len(fieldname) == 2:
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)
                    atemp2=f.variables[fieldname[1]][:]
                    atemp2=np.squeeze(atemp2)
        
                if len(fieldname) > 2:
                    print('you are requesting too many variables')
                    sys.exit()
    

                # set array for storing average
                if monthno == 0 and time == 0:
                    temp_extreme=atemp
                    temp2_extreme=0.
                    if len(fieldname)==2:
                        temp2_extreme=atemp2
                    count=1
                else:
                    temp_extreme=temp_extreme+atemp
                    if len(fieldname)==2:
                        temp2_extreme=temp2_extreme+atemp2
                    count=count+1

        # put temperature data in lower or higher catogry
        if ex == 0:
            temp_low=temp_extreme/count
            temp2_low=temp2_extreme/count
        if ex == 1:
            temp_high=temp_extreme/count
            temp2_high=temp2_extreme/count


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low,lon = shiftgrid(180.,temp_low,lon,start=False)    
    lon=lontemp
    temp_high,lon = shiftgrid(180.,temp_high,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    
    

    if fieldname[0] == 'temp_1':  # temperature data
        titlename=exptname+' low seas temp'
        plotdata(temp_low-273.15,0,lon,lat,titlename,-40.0,40.0,10.0,0,'n','degC')
        plotdata(temp_high-273.15,1,lon,lat,'high seas temp',-40.0,40.0,10.0,0,'n','degC')

        plotdata(temp_low-temp_avg,2,lon,lat,'low seas Tanom',-5.0,6.0,1.0,0,'n','degC')
        plotdata(temp_high-temp_avg,3,lon,lat,'high seas Tanom',-5.0,6.0,1.0,0,'n','degC')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_temp'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotdata(temp_low*60.*60.*24.*30.,0,lon,lat,titlename,-0,275,25,0,'n','mm/month')
        plotdata(temp_high*60.*60.*24.*30.,1,lon,lat,'high seas temp',0,275,25,0,'n','mm/month')

        plotdata((temp_low-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low seas panom',-50,50,15,0,'n','mm/month')
        plotdata((temp_high-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high seas panom',-50,50,10,0,'n','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
        # if precip also do percentage change
        pcent_low=((temp_low-temp_avg)/temp_avg)*100.
        pcent_high=((temp_high-temp_avg)/temp_avg)*100.
        titlename=exptname+' low seas precip anom'
        plotdata(pcent_low,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotdata(pcent_high,1,lon,lat,'high seas Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'p': # mean slp data
        titlename=exptname+' low seas mslp'
        plotdata(temp_low/100.,0,lon,lat,titlename,980,1040,10.0,0,'n','mbar')
        plotdata(temp_high/100.,1,lon,lat,'high seas mslp',980,1040,10.0,0,'n','mbar')

        plotdata((temp_low-temp_avg)/100.,2,lon,lat,'low seas mslp',-5.0,6.0,1.0,0,'n','mbar')
        plotdata((temp_high-temp_avg)/100.,3,lon,lat,'high seas mslp',-5.0,6.0,1.0,0,'n','mbar')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_mslp'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
        

################################
# main program

figureno=0

#==================================
# get annual PC

#get_PC_allmonths('xkvje')
#get_PC_allmonths('xkvjf')
#get_PC_allmonths('xkvjg')


#=================================
# get seasonal PC
#monthnames=['dc','ja','fb','mr']
monthnames=['jn','jl','ag']
#get_PC_seas('xkvje',monthnames,'n',1,100)
#get_PC_seas('xkvjf',monthnames,'n',1,100)
#get_PC_seas('xkvjg',monthnames,'n',1,100)




#=====================================
# get seasonal teleconnections

monthnames=['jn','jl','ag']
seasname='jja'
# note monthnames is the month of the climate variable, seasonnames is the 
# season that the NAO index is calculated over

# temperature
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')

# winds
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')


# precipitation
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')

# mslp
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')


sys.exit(0)

####

::::::::::::::
plot_NINOindex.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_NINOindex
#PURPOSE
#    This program will plot
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import scipy.signal as sig
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot nino34 index on a line graph
#  def fullprint  print full array for debugging
#  get_NINO34_temperatures gets the NINO34 temperatures and writes to a file
#  plot_NINO34_temperatures   plots NINO34 temperatures from above file

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(3,2,fileno+1)

   # this is good for a ELNINO region
    map=Basemap(llcrnrlon=100.0,urcrnrlon=300.0,llcrnrlat=-20.0,urcrnrlat=20.0,projection='cyl',resolution='c')
   # this is good for the globe
   # map=Basemap(llcrnrlon=0.0,urcrnrlon=360.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ar':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def indexplot(toplot,fileno,nyears,nmonths,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt,control,meanval):
    plt.subplot(4,1,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    xdata=np.arange(nyears*nmonths)
    xdata=xdata / float(nmonths)
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='ONI index '+expt+' based on '+control+' mean is '+np.str(meanval)
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(nyears*nmonths))
    plt.plot(xdata,np.zeros(nyears*nmonths)+0.5)
    plt.plot(xdata,np.zeros(nyears*nmonths)-0.5)
    bar_width=1.0/12.0
    plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 


   
# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint


def get_NINO34_temperatures(exptname):
# this subroutine will get the NINO3.4 temperature and write them to a file

    print('get nino34_temperatures')

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/temp_data/'
    os.chdir(dirname)
    #full_file_paths =  glob.glob(dirname+"*o@pf*")
    full_file_paths =  glob.glob("*o@pf*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    print(nfiles,nyears,nmonths)


    # prepare output files

    fileout='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
    f1=open(fileout,'w+')
    f1.write('nyears='+str(nyears)+' nmonths='+str(nmonths)+'\n')
    f1.write('filename              year   month   NINO3.4 temperature\n')
        

    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=np.shape(lat)
            lon = f.variables['longitude'][:]
            lonsize=np.shape(lon)
        
        count==count+1
        temperature=f.variables['temp'][:] 
       
        temperature=np.squeeze(temperature)
# mask out all data that is not in nino3.4 region (120W-170W, 5N-5S) 

        ix1=(lon >=190) & (lon <=240)
        ix2=(lat <= 5) & (lat >=-5) 
        lats_reg = lat[ix2]
        lons_reg = lon[ix1]
        
        ninoint=temperature[ix2]
     
        ninotemp=ninoint[:,ix1]

        # to check that correct region is found
        #plotdata(ninotemp,0,lons_reg,lats_reg,'test',20,30,1,0,'n','tempdeg')
        #plt.show()


        # calculate average temperature in region
        weights=np.cos(np.radians(lats_reg))
        nino34_zonT=np.average(ninotemp,axis=0,weights=weights)
        nino34_T=np.average(nino34_zonT)
        #print(count,fname,nino34_T)

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        print(fname,year,monthno,nyears,nmonths)
        f1.write(fname+';'+str(year)+';'+str(monthno)+';'+str(nino34_T)+'\n')

    
        
    f1.close()



#===NEW PROG=====================================
def plot_NINO34_temperatures(exptname,controlname,tempanomaly):
# this program will plot the temperatures obtained in get_NINO34_temperatures
# it will look like an el nino index
# if will also see if the index is different if we are using the reference 
# temperatures from a control simulation

    fig=plt.figure()

    # get data from experiment
    filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
    f=open(filein,'r')
    # read file to get number of years and months of data
    firstline=f.readline()
    b=firstline.split() # split into nyears and nmonths title

    c=b[0] # get nyears title
    b1=c.split('=')  # split by removing text before equals sign
    nyears=int(float(b1[1])) # this is nyears

    c=b[1] # get nmonths title
    b1=c.split('=')  # split by removing text before equals sign
    nmonths=int(float(b1[1])) # this is nmonths
    print('nyears',nyears)
    print('nmonths',nmonths)


    # discard second titleline
    secondline=f.readline()


    # read over all the rest of the data in the file, find the startyear and
    # the endyear

    yearmin=1E10
    yearmax=-1E10
    for line in f:
        # extract year month and nino index
        linesplit=line.split(';')
        year=int(float(linesplit[1]))
        if year < yearmin:
            yearmin=year
        if year > yearmax:
            yearmax=year
        
    f.close()

    # make 2 arrays to store data
    
    nyears=yearmax-yearmin+1
    allyears=np.empty(nyears)
    allyears[:]=np.NAN
    nino34index=np.empty((nyears,nmonths))
    nino34index[:,:]=np.NAN
    filelist=np.empty((nyears,nmonths),dtype=object)



    # open the file again, get the NINO3.4 index and add to the arrays
    print('yearminmax',yearmax,yearmin)

    f=open(filein,'r')
    # discard two title lines
    firstline=f.readline()
    firstline=f.readline()
    for line in f:
        # extract year month and nino index
        linesplit=line.split(';')
        year=int(float(linesplit[1]))
        month=int(float(linesplit[2]))
        ninoval=float(linesplit[3])

        allyears[year-yearmin]=year
        nino34index[year-yearmin,month]=ninoval
        filelist[year-yearmin,month]=linesplit[0]

    f.close()


    #####################################################
    # get data from control if appropriate

    if controlname != exptname:
        filein='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/NINODATA/'+controlname+'_NINO3.4_temp.txt'
        f=open(filein,'r')
        # read file to get number of years and months of data
        firstline=f.readline()
        b=firstline.split() # split into nyears and nmonths title

        c=b[0] # get nyears title
        b1=c.split('=')  # split by removing text before equals sign
        nyears_ct=int(float(b1[1])) # this is nyears

        c=b[1] # get nmonths title
        b1=c.split('=')  # split by removing text before equals sign
        nmonths_ct=int(float(b1[1])) # this is nmonths
        print('nyears_ct',nyears_ct)
        print('nmonths__ct',nmonths_ct)


        # discard second titleline
        secondline=f.readline()


        # read over all the rest of the data in the file, find the startyear and
        # the endyear

        yearmin_ct=1E10
        yearmax_ct=-1E10
        for line in f:
            # extract year month and nino index
            linesplit=line.split(';')
            year_ct=int(float(linesplit[1]))
            if year_ct < yearmin_ct:
                yearmin_ct=year_ct
            if year_ct > yearmax_ct:
                yearmax_ct=year_ct
           
                    
        f.close()

        # make 2 arrays to store data

        nyears_ct=yearmax_ct-yearmin_ct+1
        allyears_ct=np.empty(nyears_ct)
        allyears_ct[:]=np.NAN
        nino34index_ct=np.empty((nyears,nmonths))
        nino34index_ct[:,:]=np.NAN
        filelist_ct=np.empty((nyears,nmonths),dtype=object)
        

        
        # open the file again, get the NINO3.4 index and add to the arrays
        
        f=open(filein,'r')
        # discard two title lines
        firstline=f.readline()
        firstline=f.readline()
        for line in f:
            # extract year month and nino index
            linesplit=line.split(';')
            year_ct=int(float(linesplit[1]))
            month_ct=int(float(linesplit[2]))
            ninoval=float(linesplit[3])
            
            allyears_ct[year_ct-yearmin_ct]=year_ct
            nino34index_ct[year_ct-yearmin_ct,month_ct]=ninoval
            filelist_ct[year_ct-yearmin_ct,month_ct]=linesplit[0]
            
        f.close()


    

    # get the average annual cycle and remove
    if exptname == controlname:
        meananncyc=np.nanmean(nino34index,axis=0)
    else:
        # reduce temperature anomaly to account for the 
        # fact that the Pliocene is a warmer climate
        print(tempanomaly)
        meananncyc=np.nanmean(nino34index_ct,axis=0)-tempanomaly

    nino34index=nino34index-meananncyc

   
    toplot=np.reshape(nino34index,nyears*nmonths)
    allfiles=np.reshape(filelist,nyears*nmonths)
    smoothednino34index=[np.mean(toplot[i-1:i+1]) for i in range (0,nyears*nmonths)]


    
    # setup an el nino array and a la nina array
    # condition must be met for 5 months

    elninoarr=np.zeros(nyears*nmonths)
    laninaarr=np.zeros(nyears*nmonths)
    for i in range(1,nyears*nmonths-4):
        if elninoarr[i-1] != 0:    # if previous month is el nino
            if smoothednino34index[i] >= 0.5:
                elninoarr[i]=smoothednino34index[i]
            else:
                elninoarr[i]=0
        else:
            flag='y'
            for i2 in range(i,i+5):
                if smoothednino34index[i] <= 0.5:
                    flag='n'
            if flag == 'y':
                elninoarr[i]=smoothednino34index[i]
            else:
                elninoarr[i]=0
        
        if laninaarr[i-1] != 0:    # if previous month is la nino
            if smoothednino34index[i] <= -0.5:
                laninaarr[i]=smoothednino34index[i]
            else:
                laninaarr[i]=0
        else:
            flag='y'
            for i2 in range(i,i+5):
                if smoothednino34index[i] >= -0.5:
                    flag='n'
            if flag == 'y':
                laninaarr[i]=smoothednino34index[i]
            else:
                laninaarr[i]=0
                
            
    meanval=np.nanmean(smoothednino34index)
    indexplot(toplot,0,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,0,25,exptname,controlname,meanval)
    indexplot(toplot,1,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,25,50,exptname,controlname,meanval)
    indexplot(toplot,2,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,50,75,exptname,controlname,meanval)
    indexplot(toplot,3,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,75,100,exptname,controlname,meanval)

                

    if exptname != controlname:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_'+controlname+'_NINO3.4_ONI.eps'
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_ONI.eps'

        fileout='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_index.txt'
        f1=open(fileout,'w+')
        f1.write('filename  year month  smoothed NINO3.4 temperature    el nino ind   la nina ind\n')

        print(allfiles)

        for i in range(0,nyears*nmonths):
            if allfiles[i]:
                fname=allfiles[i]
                print(fname)
                print(fname[10:12])
                year=int(float(fname[10:12]))
                month=fname[12:14]
                extra=fname[9:10]
                
                choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                       'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                       'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                       'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                       'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                       'z': 35}
            
                century=choices.get(extra,extra) # the second extra is the default v
                # value for if it is not found in
                # the choices list
            
            
                choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                       'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                       'nv': 10, 'dc': 11}
            
                monthno=choices.get(month,-99) # the second extra is the default v
                # value for if it is not found in
                # the choices list
                
                print(century,year)
                year=(century * 100) + year
                print(fname,year,monthno,nyears,nmonths)
                f1.write(fname+';'+str(year)+';'+str(monthno)+';'+str(smoothednino34index[i])+';'+str(elninoarr[i])+';'+str(laninaarr[i])+'\n')


    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()




#end def



#===NEW PROG=====================================
def plot_NINO34_patterns(exptname,fieldreq):
# this program will plot the patterns associated with an el nino


    filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_index.txt'
    f=open(filein,'r')
    # read firstline and discard
    firstline=f.readline()

    arraysetup='n'
    for line in f:
        # extract filename
        linesplit=line.split(';')
        filename=linesplit[0]
        month=int(float(linesplit[2]))
        normval=float(linesplit[3])
        enind=float(linesplit[4])
        lnind=float(linesplit[5])

        # read in data from file
        if fieldreq == 'temp':
            ncdffile='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/temp_data/'+filename
        if fieldreq == 'precip_1':
            ncdffile='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+filename[0:5]+'a@pd'+filename[9:15]+'precip.nc'


        f=Dataset(ncdffile,mode='r')
        f.dimensions
        f.variables

        filetemp = f.variables[fieldreq][:]
        filetemp=np.squeeze(filetemp)
        
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]

        f.close()

        xsize=len(lon)
        ysize=len(lat)
    
        # setup arrays nmonths nlats nlons
        if arraysetup=='n':
            enarr=np.zeros((12,ysize,xsize))
            lnarr=np.zeros((12,ysize,xsize))
            normarr=np.zeros((12,ysize,xsize))
            cten=np.zeros(12,dtype=np.int)
            ctln=np.zeros(12,dtype=np.int)
            ctnm=np.zeros(12,dtype=np.int)
            arraysetup='y'


        if enind != 0.0:
            enarr[month,:,:]=enarr[month,:,:]+filetemp
            cten[month]=cten[month] + 1
        elif lnind != 0.0:
            lnarr[month,:,:]=lnarr[month,:,:]+filetemp
            ctln[month]=ctln[month]+1
        else:
            normarr[month,:,:]=normarr[month,:,:]+filetemp
            ctnm[month]=ctnm[month]+1


   
            
    enarr=enarr/cten[:,np.newaxis, np.newaxis]
    lnarr=lnarr/ctln[:,np.newaxis, np.newaxis]
    normarr=normarr/ctnm[:,np.newaxis, np.newaxis]
        
   
       
    enmean=np.average(enarr,axis=0)
    lnmean=np.average(lnarr,axis=0)
    nmmean=np.average(normarr,axis=0)
    units='degC'
    if fieldreq == 'precip_1': 
        units='mm/month'
        enmean=enmean * 60. *60. * 24. * 30.
        lnmean=lnmean * 60. *60. * 24. * 30.
        nmmean=nmmean * 60. *60. * 24. * 30.


    if fieldreq == 'temp':
        # figures for temperature
        titlename=exptname+'elnino'
        plotdata(enmean,0,lon,lat,titlename,20.,30,1,0,'n',units)
        plotdata(lnmean,1,lon,lat,'lanina',20.,30,1,0,'n',units)
        enanom=enmean-nmmean
        plotdata(enanom,2,lon,lat,'elninoanom',-2.,2.1,0.1,0,'a',units)
        lnanom=lnmean-nmmean
        plotdata(lnanom,3,lon,lat,'lanina anom',-2.,2.1,0.1,0,'a',units)

    if fieldreq =='precip_1':
        # plots for precip
        # figures for temperature
        titlename=exptname+'elnino'
        plotdata(enmean,0,lon,lat,titlename,0.,300,10,0,'n',units)
        plotdata(lnmean,1,lon,lat,'lanina',0.,300,10,0,'n',units)
        enanom=enmean-nmmean
        plotdata(enanom,2,lon,lat,'elninoanom',-100.,110,10,0,'ar',units)
        lnanom=lnmean-nmmean
        plotdata(lnanom,3,lon,lat,'lanina anom',-100.,110,10.0,0,'ar',units)



    # get average temperature across pacific
    ix1=(lon >=100) & (lon <=300)
    ix2=(lat <= 20) & (lat >=-20) 
    lats_reg = lat[ix2]
    lons_reg = lon[ix1]
        
    avg_pac=nmmean[ix2]
    avg_pac=avg_pac[:,ix1]
        
    print(np.shape(avg_pac))
    for i in range(0,len(lons_reg)):
        for j in range(0,len(lats_reg)):
            if avg_pac[j,i] == 0:  # land point
                avg_pac[j,i]=float('NaN')
    
    WPminEP=np.nanmean(avg_pac[:,0:len(lons_reg)/2.0])- \
        np.nanmean(avg_pac[:,len(lons_reg)/2.0:len(lons_reg)])

    print('avg pac',avg_pac)
    
    print('mean is',np.nanmean(avg_pac),WPminEP)

    if fieldreq =='temp':
        titlename='normal W-E is:'+np.str(WPminEP)
        plotdata(nmmean-np.nanmean(avg_pac),4,lon,lat,titlename,-4.,4,0.1,0,'a','degC')





    # print out the average anomaly associated with elnino

    avg_enanom=enanom[ix2]
    avg_enanom=avg_enanom[:,ix1]
    avg_lnanom=lnanom[ix2]
    avg_lnanom=avg_lnanom[:,ix1]
   
    for i in range(0,len(lons_reg)):
        for j in range(0,len(lats_reg)):
            if avg_enanom[j,i] == 0 and avg_lnanom[j,i]==0:  # land point
                 avg_enanom[j,i]=float('NaN')
                 avg_lnanom[j,i]=float('NaN')
                 
    print('mean elnino signature',np.nanmean(avg_enanom))
    print('mean lanina signature',np.nanmean(avg_lnanom))
    print('mean absolute value elnino signature',np.nanmean(np.absolute(avg_enanom)))
    print('mean absolute value lanina signature',np.nanmean(np.absolute(avg_lnanom)))





    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_patterns_'+fieldreq+'.eps'

    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


    retdata=[enanom,lnanom,lon,lat]
    return retdata


#end def



#===NEW PROG=====================================
def plot_NINO34_freqspectra(exptnames):
# this program will plot the freqquency spectra of the NINO3.4 temperature


    nexpts=len(exptnames)

    allninotemp=[]
    allmonth=[]
    monthtemp=np.zeros(12)
    monthcount=np.zeros(12)
    titlename='power spectral density'



    for exptname in exptnames:

        filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
        f=open(filein,'r')
    # read first two lines and discard
        firstline=f.readline()
        firstline=f.readline()
        for line in f:
            # extract filename
            linesplit=line.split(';')
            filename=linesplit[0]
            month=int(float(linesplit[2]))
            nino34temp=float(linesplit[3])
            allninotemp.append(float(nino34temp))
            # stuff for removing average annual cycle
            allmonth.append(month)
            monthtemp[month]=monthtemp[month]+nino34temp
            monthcount[month]=monthcount[month]+1

        f.close()
        titlename=exptname+' '+titlename


    monthtemp=monthtemp/monthcount

 

    # remove annual cycle
    allninotemp=allninotemp-monthtemp[allmonth]

    titlename=titlename+' variance is ','%.2f' %np.var(allninotemp)


    # do a spectral analysis on the index
    Pxx_f, Pxx_den=sig.periodogram(allninotemp,1.0)
   
    Pxx_f=Pxx_f * 12. #  convert to cycles per year from cycles per month

    plt.subplot(2,1,1)
    nmonths=len(allninotemp)
    xarray=(np.arange(0,nmonths,1))/12.
    print('shapes')
    print(np.shape(xarray))
    print(np.shape(allninotemp))
    plt.plot(xarray,allninotemp) # raw data with restricted
    plt.title('NINO3.4 temp anomaly')
    plt.xlabel('year')
    plt.ylabel('nino3.4 temp')
    axes=plt.gca()
    axes.set_xlim([0,nmonths/12])
   


    plt.subplot(2,1,2)
    plt.plot(1.0/Pxx_f,Pxx_den) # plotting with period on y axis
    plt.title(titlename)
    axes=plt.gca()
    axes.set_xlim([0.5,150])
    axes.set_xscale('log')
    axes.set_xticks([1,2,5,10,20,40,80,160])
    axes.get_xaxis().set_major_formatter(mp.ticker.ScalarFormatter())
    plt.xlabel('period (years)')



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_freqspectra.eps'

    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


    
   




#end def



################################
# main program

figureno=0
###############################
#get_NINO34_temperatures('xkvje')
#get_NINO34_temperatures('xkvjf')
#get_NINO34_temperatures('xkvjg')

##############################################
# get patterns associated with el nino for a chosen field
tempdata=plot_NINO34_patterns('xkvje','temp')
temp_enanom_pi=tempdata[0]
temp_lnanom_pi=tempdata[1]
lon=tempdata[2]
lat=tempdata[3]

tempdata=plot_NINO34_patterns('xkvjf','temp')
temp_enanom_plio=tempdata[0]
temp_lnanom_plio=tempdata[1]

tempdata=plot_NINO34_patterns('xkvjg','temp')
temp_enanom_pliop2=tempdata[0]
temp_lnanom_pliop2=tempdata[1]


# plot absolute change in temperature
plotdata(temp_enanom_pliop2-temp_enanom_pi,0,lon,lat,'diff in elnino temp (pliop2 and pi)',-1.,1.1,0.1,0,'ar','degC')
plotdata(temp_enanom_plio-temp_enanom_pi,1,lon,lat,'diff in elnino temp (plio and pi)',-1.,1.1,0.1,0,'ar','degC')
plotdata(temp_lnanom_pliop2-temp_lnanom_pi,2,lon,lat,'diff in lanina temp (pliop2 and pi)',-1.,1.1,0.1,0,'ar','degC')
plotdata(temp_lnanom_pliop2-temp_lnanom_pi,3,lon,lat,'diff in lanina temp (plio and pi)',-1.,1.1,0.1,0,'ar','degC')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/xkvjg-xkvje_temp_patterns.eps'

plt.savefig(fileout, bbox_inches='tight')  
plt.close()



precipdata=plot_NINO34_patterns('xkvje','precip_1')
# extract fields for anomalies
precip_enanom_pi=precipdata[0]
precip_lnanom_pi=precipdata[1]
lon=precipdata[2]
lat=precipdata[3]

precipdata=plot_NINO34_patterns('xkvjf','precip_1')
precip_enanom_plio=precipdata[0]
precip_lnanom_plio=precipdata[1]

precipdata=plot_NINO34_patterns('xkvjg','precip_1')
precip_enanom_pliop2=precipdata[0]
precip_lnanom_pliop2=precipdata[1]

# plot absolute change in precipitation
plotdata(precip_enanom_pliop2-precip_enanom_pi,0,lon,lat,'diff in elnino precip (pliop2 and pi)',-100.,110,10.0,0,'ar','mm/month')
plotdata(precip_enanom_plio-precip_enanom_pi,1,lon,lat,'diff in elnino precip (plio and pi)',-100.,110,10.0,0,'ar','mm/month')
plotdata(precip_lnanom_pliop2-precip_lnanom_pi,2,lon,lat,'diff in lanina precip (pliop2 and pi)',-100.,110,10.0,0,'ar','mm/month')
plotdata(precip_lnanom_pliop2-precip_lnanom_pi,3,lon,lat,'diff in lanina precip (plio and pi)',-100.,110,10.0,0,'ar','mm/month')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/xkvjg-xkvje_precip_patterns.eps'

plt.savefig(fileout, bbox_inches='tight')  
plt.close()

# we can't do percentage change because the negative numbers make the plot really confusing






#########################################
#plot_NINO34_temperatures('xkvje')
# the temperature anomaly needs to be obtained from plot_NINO34_patterns

#tempanomaly=avg_pac_temp_PI-avg_pac_temp_plio # for normalising control index
#print(tempanomaly)
#plot_NINO34_temperatures('xkvjf','xkvje',tempanomaly)
#tempanomaly=avg_pac_temp_PI-avg_pac_temp_pliop2 # for normalising control index
#plot_NINO34_temperatures('xkvjg','xkvje',tempanomaly)


###########################
# plot freqency spectra to see what freqency of NINO
#plot_NINO34_freqspectra(['xkvja','xkvje'])
#plot_NINO34_freqspectra(['xkvjb','xkvjf'])
#plot_NINO34_freqspectra(['xkvjc','xkvjg'])


sys.exit(0)

####

::::::::::::::
plot_ocean_heat_transport.py
::::::::::::::
 #!/usr/bin/env python2.7
#NAME
#    PLOT_OCEAN HEAT TRANSPORT
#PURPOSE
#    This program will do all the plots to do with ocean heat transport
#   
#    We want to see how much heat the THC transported in the pliocene and if 
#    if this is different from the modern
# search for 'main program' to find end of functions
# Julia 19/1/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)


   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata
#####################################
def plot_lat_dep(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,cbarname):
    lats, deps  = np.meshgrid(lat,dep)

    V=np.arange(minval,maxval,valinc)
    
    cs = plt.contourf(lats,deps,plotdata,V,extend="both",cmap='RdBu_r')
    plt.gca().invert_yaxis()

    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata

#  to check if a character is numeric
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

#============================
def Atlantic_heat_transport(expt_name):



#  get data from files

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pg2/'+expt_name+'o@pg*.nc')
    lat = f.variables['latitude_1'][:]
    lon = f.variables['longitude_1'][:]
    dep = f.variables['depth_1'][:]
    Vvel=f.variables['field704'][:]
    PotT=f.variables['temp'][:]
    Vvel=np.squeeze(Vvel)
    PotT=np.squeeze(PotT)
    f.close()

    ntimes,ndep,nlat,nlon=np.shape(Vvel)
    
    # calculate T(j)-T(j+1)  which is notthwards anomaly
    
    PotT_diff=np.zeros((ntimes,ndep,nlat,nlon))
    for j in range(0,nlat):
        PotT_diff[:,:,j,:]=PotT[:,:,j,:]-PotT[:,:,j+1,:] 

   
    vT=Vvel * PotT_diff
    mean_VT=np.mean(vT,axis=0)
    meanPotT_diff=np.mean(PotT_diff,axis=0)

  

   

#  get mask of Oceans
    filemask='/nfs/see-fs-02_users/earjcti/MOC/merid/basin_hadgom_216'
    f1=open(filemask,'r')
    # discard 3 title lines
    textline=f1.readline()
    textline=f1.readline()
    textline=f1.readline()
    # next line is details from basin
    nrows=nlat+1  # because it's on T grid not V grid
    Indian_d=np.zeros((nrows,4))
    Pacific_d=np.zeros((nrows,4))
    Atlantic_d=np.zeros((nrows,4))
    Combined_d=np.zeros((nrows,4))
    for line in f1:
        linesplit=line.split()  # split line by space
        if is_number(linesplit[0]):
            rowno=int(linesplit[0])
            Indian_d[rowno-1,:]=int(linesplit[1]),int(linesplit[2]),\
                int(linesplit[3]),int(linesplit[4])
            Pacific_d[rowno-1,:]=int(linesplit[5]),int(linesplit[6]),\
                int(linesplit[7]),int(linesplit[8])
            Atlantic_d[rowno-1,:]=int(linesplit[9]),int(linesplit[10]),\
                int(linesplit[11]),int(linesplit[12])
            Combined_d[rowno-1,:]=int(linesplit[13]),int(linesplit[14]),\
                int(linesplit[15]),int(linesplit[16])

    f1.close()

    # make some attempt to convert to V grid
    Atlantic_V=np.zeros((nlat,4))
    for j in range(0,nlat):
        Atlantic_V[j,:]=(Atlantic_d[j,:]+Atlantic_d[j+1,:])/2.0


    Atlantic_mask=np.ones((nlat,nlon),dtype=bool)
    for j in range(0,nlat):
        Atlantic_mask[j,Atlantic_V[j,0]:Atlantic_V[j,1]]=0
        Atlantic_mask[j,Atlantic_V[j,2]:Atlantic_V[j,3]]=0



    # get mean heat transport over Atlantic
    Atlantic_VT=np.ma.masked_array(mean_VT,mask=np.tile(Atlantic_mask,(mean_VT.shape[0],1)))


    Atlantic_VT=Atlantic_VT / 100. # convert from K cm/s to K m/s


    lontemp=lon
    PotT_diff,lon = shiftgrid(180.,PotT_diff,lon,start=False)
    lon=lontemp
    mean_VT,lon = shiftgrid(180.,mean_VT,lon,start=False)
    lon=lontemp
    Atlantic_VT, lon = shiftgrid(180.,Atlantic_VT,lon,start=False)
    lon=lontemp
    meanPotT_diff, lon = shiftgrid(180.,meanPotT_diff,lon,start=False)


    #plotmap(meanPotT_diff[0,:,:],0,lon,lat,'theta diff',-2,2,0.1,0.0,'n','degC')
    #plotmap(mean_VT[0,:,:],1,lon,lat,'meanvt',-2,2,0.1,0.0,'n','degC')
    #plt.show()
    
 
    #plotmap(Atlantic_VT[0,:,:],2,lon,lat,'atl_vt0',-2,2,0.1,0.0,'n','degC')
    #plotmap(Atlantic_VT[30,:,:],3,lon,lat,'atlvt30',-2,2,0.1,0.0,'n','degC')
    #plt.show()


    # we have extracted the data we want.  Now have a go at
    # calculating surfact heat transport.
    # (This is Cp * integral [(dens * VT)]dx


    dens=1029 # in reality this will change depending on temperature and 
              # saltiness  but mean value is 1029kg/m3
    cp = 3985      # This is seawater heat capacity 3985 J /kg / K

    Atl_qsurf=np.zeros((ndep,nlat))

    for k in range(0,ndep):
        for j in range(0,nlat):
            dx=(lon[1]-lon[0]) * 111000. * np.cos(np.radians(lat[j]))
            Atl_weight=Atlantic_VT[k,j,:]*cp*dens*dx
            Atl_qsurf[k,j]=np.sum(Atl_weight)
            if k == 0 and lat[j] < 5. and lat[j]> -5.:
                print(Atlantic_VT[k,j,:])
                print('pott',meanPotT_diff[k,j,:])
                print('vvel',np.mean(Vvel[:,k,j,:],axis=0))
                print(dx)
                sys.exit()

    # units of Atl_qsurf[j] are currently J/s/m.  This is because we have 
    # not accounted for depth.  To find the total heat transport we would 
    # multiply by the depth of the layer which would give the results in Watts

    dep_lay=np.zeros(ndep)
    dep_lay[0]=dep[0] * 2.0
    dep_lay[ndep-1]=dep[ndep-1] -dep[ndep-2]
    for k in range(1,ndep-1):
        dep_lay[k]=(dep[k+1]-dep[k-1])/2.0
   
   
    Atl_qsurf=Atl_qsurf / 10**15  # give results in petawatts
    Atl_qsurf=Atl_qsurf * dep_lay[:,None]
    print('shape',np.shape(Atl_qsurf))


    titlename='Atlantic Heat transport: '+expt_name
    plot_lat_dep(Atl_qsurf,0,lat,dep,titlename,-1.5,1.5,0.1,'Petawatts')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/'+expt_name+'_Atl_lat_depth.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    return(lat,dep,Atl_qsurf)
    

#end def Atlantic_salinity_depth_plot
#end def annmean

#========================================
def lat_heat_transport(expt_name1,expt_OHT1,expt_name2,expt_OHT2,lat,dep):
# this subroutine will do a plot of ocean heat transport integrated over all the ocean 

    print('in lat heat transport')
    allOHT1=np.nansum(expt_OHT1,axis=0)
    plt.plot(lat,allOHT1)
    plt.plot(lat,expt_OHT1[0,:],'b.')

    if expt_name2 != 'none':
        allOHT2=np.nansum(expt_OHT2,axis=0)
        plt.plot(lat,allOHT2,'r-')
        plt.plot(lat,expt_OHT2[0,:],'r.')




    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/'+expt_name1+'_'+expt_name2+'_Atl_lat.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    print('end lat heat transport')



#end def lat_heat_transport

################################
# main program

# annual mean salinity by depth

retdata=Atlantic_heat_transport('xkvjg')
lat=retdata[0]
dep=retdata[1]
xkvjg_OHT=retdata[2]

retdata=Atlantic_heat_transport('xkvjf')
xkvjf_OHT=retdata[2]

retdata=Atlantic_heat_transport('xkvje')
xkvje_OHT=retdata[2]

# do an anomaly plot

anomplot=xkvjg_OHT-xkvje_OHT
titlename='Atlantic Heat transport: xkvjg-xkvje'
plot_lat_dep(anomplot,0,lat,dep,titlename,-0.5,0.5,0.05,'Petawatts')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/xkvjg-xkvje_Atl_lat_depth.eps'
plt.savefig(fileout, bbox_inches='tight')  
plt.close()


anomplot=xkvjf_OHT-xkvje_OHT
titlename='Atlantic Heat transport: xkvjf-xkvje'
plot_lat_dep(anomplot,0,lat,dep,titlename,-0.5,0.5,0.05,'Petawatts')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/xkvjf-xkvje_Atl_lat_depth.eps'
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

# integrate over ocean depth and then plot
print('calling lat heat transport')

lat_heat_transport('xkvjg',xkvjg_OHT,'xkvje',xkvje_OHT,lat,dep)


sys.exit()



####

::::::::::::::
plot_precip_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFPRECIP
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='h')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,cmap='spectral',extend='max')
                cbar = plt.colorbar(cs,orientation="horizontal")

    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-60,size=15)
        cbar.ax.tick_params(labelsize=15)
        plt.title(titlename,loc='left',fontsize=18)
  
#end def plotdata

###########################################################
def plotmap_nh(plotdata,mPWP_data,PI_data,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind,ygrid,xgrid,yuse,xuse,yspan,xspan):


    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    #plt.subplot2grid((10,12),(fileno*2,0),colspan=9,rowspan=2)

    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    lons, lats = np.meshgrid(lon,lat)
   
    if mask_ind =='n': # tropics mask
        northlat=90.0
        southlat=30.0
    elif mask_ind == 'nalt': # alternative tropical region:
        northlat=90.0
        southlat=0.0
    else:
        northlat=90.0
        southlat=-90.0

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata


    # plot limits
    if V == 0:
        V=np.arange(minval,maxval,valinc)

    # plot map
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotdata,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
   
    #parallels=np.arange(-90.,90.,15.)
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,True,False,False]) # labels right
    meridians=np.arange(-180.,180.,60.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 
    # colorbar
    if fileno==0:
        plt.subplot2grid((10,12),(9,0),colspan=9,rowspan=1)
        plt.gca().set_visible(False)
        cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0)         
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=10)
        
   

    plotdata=plotdata2
    
    # plot map boundary
    map.drawmapboundary


    ###################################################
    # do line graph showing absolute value by latitude


    print('fileno is',fileno)
    ax=plt.subplot2grid((10,12),(fileno*2,10),colspan=2,rowspan=2)
    ax.plot(np.mean(mPWP_data,axis=1),lat,label='mPWP',linewidth=0.8)
    ax.plot(np.mean(PI_data,axis=1),lat,label='PI',linewidth=0.8)
    # plot dotted lines at locations
    xmax=4
    xmin=0
    ax.plot([xmin,xmax],[45,45],color='black',linestyle='dotted',linewidth=0.8) 
    ax.plot([xmin,xmax],[60,60],color='black',linestyle='dotted',linewidth=0.8) 
    ax.plot([xmin,xmax],[75,75],color='black',linestyle='dotted',linewidth=0.8) 
   
    ax.tick_params(axis='y',which='both',labelleft='off')
    ax.set_ylim(southlat,northlat)
    ax.set_xlim(xmin,xmax)
    if fileno !=3:
        ax.set_xticks([]) # disable xticks
    else:
        ax.set_xticks(list(range(xmin,xmax,1)))
        #ax.set_xlabel("mm/day",va='top')

    # add legend away from plot
    ax_leg=plt.subplot2grid((10,12),(9,10),colspan=2,rowspan=1)
    ax_leg.legend(*ax.get_legend_handles_labels(),loc='center')
    ax_leg.axis('off')
    plt.legend()
    
   


#end def plotmap_nh


###########################################################
def plotmap_nh_rainsnow(plotrain,plotsnow,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind,ygrid,xgrid,yuse,xuse,yspan,xspan):

    # setup

    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    lons, lats = np.meshgrid(lon,lat)
   
    if mask_ind =='n': # tropics mask
        northlat=90.0
        southlat=30.0
    elif mask_ind == 'nalt': # alternative tropical region:
        northlat=90.0
        southlat=0.0
    else:
        northlat=90.0
        southlat=-90.0

    if V == 0:
        V=np.arange(minval,maxval,valinc)


    # plot rain
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotrain,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotrain,V,cmap='RdBu',extend='both')
   
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,False,False,False]) # labels right
    meridians=np.arange(-180.,180.,90.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 
    plt.text(-180.0-6,northlat-fontsize-1-15,'(rain)',fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

    # plot map boundary
    map.drawmapboundary


    # plot snow
    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse+yspan+1),colspan=yspan,rowspan=xspan)

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotsnow,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotsnow,V,cmap='RdBu',extend='both')
   
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,False,False,False]) # no labels
    meridians=np.arange(-180.,180.,90.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

    plt.text(-180.0-6,northlat-fontsize-1-15,'(snow)',fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

  
  # plot map boundary
    map.drawmapboundary


    # colorbar
    if fileno==0:
        plt.subplot2grid((10,11),(9,0),colspan=11,rowspan=1)
        plt.gca().set_visible(False)
        cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0)         
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=10)
   
    
  

    
    
   


#end def plotmap_nh_rainsnow


def annmean(figureno,HadCM3,moses2):
    #==============
    # preindustrial


    # read in data from multiple files
    if HadCM3 == 'y':
        if moses2 =='y':  #my simulations moses 2
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        else: # fergus simulation xgrad
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip'][:]
        titlepi='PI-Ann_HadCM3'
        titleplio='Plio-Ann_HadCM3'
        titlediff='Plio - preind  Ann_HadCM3'
            
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip_1'][:]
        titlepi='PI-Ann_HadGEM2'
        titleplio='Plio-Ann_HadGEM2'
        titlediff='Plio - preind Ann_HadGEM2'


    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_precip_ann=np.mean(aprecip,axis=0)
    print('new shape',np.shape(pi_precip_ann))
    
    pi_precip_ann=pi_precip_ann * 60. * 60. * 24. # mm/day
    
    plt.figure(0)
    lonprecip=lon
    pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    
    plotdata(pi_precip_ann,0,lon,lat,titlepi,0,275,25.0,0.0,'n','mm/month')
    f.close()

     #==============
     # Pliocene

    if HadCM3 == 'y':
        if moses2 == 'y':
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*.nc')
        else: # fergus simulation xgrac
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*.nc')
        aprecip=f.variables['precip'][:]
        aprecip=np.squeeze(aprecip)
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[7-9]*.nc')
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

    plio_precip_ann=np.mean(aprecip,axis=0)
    plio_precip_ann=plio_precip_ann * 60. * 60. * 24. # mm/day

    lon=lonprecip
    plio_precip_ann,lon = shiftgrid(180.,plio_precip_ann,lon,start=False)

    plotdata(plio_precip_ann,1,lon,lat,titleplio,0,275,25,0.0,'n','mm/month')
    f.close()

     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[7-9]*.nc')
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aprecip)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_precipp2_ann=np.mean(aprecip,axis=0)
        plio_precipp2_ann=plio_precipp2_ann * 60. * 60. * 24. # mm/day
        lon=lonprecip
        plio_precipp2_ann,lon = shiftgrid(180.,plio_precipp2_ann,lon,start=False)

        f.close()


    # Pliocene - preindustrial

    plio_anom=plio_precip_ann-pi_precip_ann

    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,titlediff,0,275,25,V,'n','mm/month')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_precipp2_ann-pi_precip_ann
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'n','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_HadCM3'+moses2+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_HadCM3'+moses2+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    ###############################################
    # plot anomaly in mm/day for paper.
   
    if HadCM3 == 'y':  # hadgem equivelent is plotted in plot_precip.py
        V=0
        plotdata(plio_anom,99,lon,lat,'HadCM3 mPWP precipitation anomaly',-1.0,1.1,0.1,V,'a','mm/day')
        if moses2 == 'y':
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xibol.eps' 
        else:
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xgrad.eps' 
        plt.savefig(fileout, bbox_inches='tight') 
        if moses2 =='y':
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xibol.tiff' 
        else:
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xgrad.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
    else:
        V=0
        plotdata(pliop2_anom,99,lon,lat,'HadGEM2 mPWP precip anomaly',-1.0,1.1,0.1,V,'a','mm/day')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xkvjg.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_xkvjg.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()



    # Pliocene - preindustrial percentage change

    print(pi_precip_ann)
    if HadCM3 == 'y':
        plio_peranom=((plio_precip_ann-pi_precip_ann)/pi_precip_ann)*100.
        plotdata(plio_peranom,99,lon,lat,'b) HadCM3: mPWP-PI Precip anomaly',-70,75,5,0,'a','%')

    if HadCM3 != 'y':
        plio_peranomp2=((plio_precipp2_ann-pi_precip_ann)/pi_precip_ann)*100.
        plotdata(plio_peranomp2,99,lon,lat,'a) HadGEM2: mPWP-PI Precip anomaly',-70,75,5,0,'a','percentage change from PI')

    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_HadCM3'+moses2+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_HadCM3'+moses2+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_xkvjg.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_xkvjg.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  



    plt.close()

    # print out all the diagnostics we need for the paper

  # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   
    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        pi_land=pi_precip_ann/lsm
        pi_sea=pi_precip_ann / (np.abs(lsm-1.0))
        plio_land=plio_precip_ann/lsm
        plio_sea=plio_precip_ann / (np.abs(lsm-1.0))
        if HadCM3 !='y':
           pliop2_land=plio_precipp2_ann/lsm
           pliop2_sea=plio_precipp2_ann / (np.abs(lsm-1.0))
                                  
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=plio_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC)
        plt.show()
        sys.exit()



    # print temperature changes
    # create weighting array
    weightarr=np.zeros(np.shape(pi_land))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('mean pi precip',np.average(pi_precip_ann,weights=weightarr)) 
    print('mean plio precip',np.average(plio_precip_ann,weights=weightarr))

    print('mean pi precip land',np.average(pi_precip_ann,weights=weightarr*lsm)) 
    print('mean plio precip land',np.average(plio_precip_ann,weights=weightarr*lsm))
    print('mean pi precip sea',np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0))) 
    print('mean plio precip sea',np.average(plio_precip_ann,weights=weightarr*np.abs(lsm-1.0)))
    print('land panom',np.average(plio_precip_ann,weights=weightarr*lsm)-np.average(pi_precip_ann,weights=weightarr*lsm)) 
    print('sea panom',np.average(plio_precip_ann,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0))) 
    print('total panom',np.average(plio_precip_ann,weights=weightarr) - np.average(pi_precip_ann,weights=weightarr)) 
    print('land p %',(np.average(plio_precip_ann,weights=weightarr*lsm)-np.average(pi_precip_ann,weights=weightarr*lsm)) * 100. /  np.average(pi_precip_ann,weights=weightarr*lsm))
    print('sea p %',(np.average(plio_precip_ann,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0))) * 100. / np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0)))
    print('total p %',(np.average(plio_precip_ann,weights=weightarr) - np.average(pi_precip_ann,weights=weightarr)) * 100. / np.average(pi_precip_ann,weights=weightarr))
  

    if HadCM3 != 'y':
        print(' ')
        print ('mean plio p2 precip',np.average(plio_precipp2_ann,weights=weightarr))
        print('mean plio p2 precip land',np.average(plio_precipp2_ann,weights=weightarr*lsm))
        print('mean plio p2 precip sea',np.average(plio_precipp2_ann,weights=weightarr*np.abs(lsm-1.0))) 
        print('land panom',np.average(plio_precipp2_ann,weights=weightarr*lsm)-np.average(pi_precip_ann,weights=weightarr*lsm)) 
        print('sea panom',np.average(plio_precipp2_ann,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0))) 
        print('total panom',np.average(plio_precipp2_ann,weights=weightarr) - np.average(pi_precip_ann,weights=weightarr)) 
  
        print('land p %',(np.average(plio_precipp2_ann,weights=weightarr*lsm)-np.average(pi_precip_ann,weights=weightarr*lsm)) * 100. /  np.average(pi_precip_ann,weights=weightarr*lsm))
        print('sea p %',(np.average(plio_precipp2_ann,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0))) * 100. / np.average(pi_precip_ann,weights=weightarr*np.abs(lsm-1.0)))
        print('total p %',(np.average(plio_precipp2_ann,weights=weightarr) - np.average(pi_precip_ann,weights=weightarr)) * 100. / np.average(pi_precip_ann,weights=weightarr))
    
        
    
#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3,moses2):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        if moses2 == 'y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
       
        else: # fergus simulation xgrad
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m3+'.nc')
      
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aprecip=fa.variables['precip'][:]
        bprecip=fb.variables['precip'][:]
        cprecip=fc.variables['precip'][:]
        pititle='PI HadCM3: '+seasname
        pliotitle='Plio HadCM3: '+seasname
        difftitle='Plio-PI HadCM3: '+seasname
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[7-9]*'+m3+'_precip.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]
        pititle='PI HadGEM2: '+seasname
        pliotitle='Plio HadGEM2: '+seasname
        difftitle='Plio-PI HadGEM2: '+seasname




    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 24. # mm/day
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    plotdata(pi_seasprecip,0,lon,lat,pititle,0,1,0.25,0.0,'n','mm/day')
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        if moses2 =='y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        else:
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m3+'.nc')
        aprecip=fa.variables['precip'][:]
        bprecip=fb.variables['precip'][:]
        cprecip=fc.variables['precip'][:]
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[7-9]*'+m3+'_precip.nc')
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]

    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60.  * 24.

    lon=lonprecip
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
    
    
    plotdata(plio_seasprecip,1,lon,lat,pliotitle,0,1,0.25,0.0,'n','mm/day')



     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[7-9]*'+m3+'_precip.nc')
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        bprecip=np.squeeze(bprecip)
        cprecip=np.squeeze(cprecip)
        
        pliop2_aprecip_avg=np.mean(aprecip,axis=0)
        pliop2_bprecip_avg=np.mean(bprecip,axis=0)
        pliop2_cprecip_avg=np.mean(cprecip,axis=0)
        
        pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
        pliop2_seasprecip=pliop2_seasprecip * 60. * 60.  * 24.
        
        lon=lonprecip
        pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seasprecip-pi_seasprecip
    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,difftitle,0,1,0.25,V,'la','mm/day')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=pliop2_seasprecip-pi_seasprecip
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',-5,5,0.25,V,'a','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom_HadCM3'+moses2+'.eps' 
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    plotdata(plio_peranom,0,lon,lat,difftitle,-70,78,5,0,'a','%')


    if HadCM3 !='y':
        plio_peranomp2=((pliop2_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
        titlename='Plio+2-PI precip %'+seasname
        plotdata(plio_peranomp2,1,lon,lat,titlename,-70,78,5,0,'a','%')

    if HadCM3 =='y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'HadCM3'+moses2+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'HadCM3'+moses2+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    plt.close()


    # Pliocene - preindustrial mm/day change

    if HadCM3 !='y':
        plio_anom=(pliop2_seasprecip-pi_seasprecip)
    else:
        plio_anom=(plio_seasprecip-pi_seasprecip)

    titlename='Plio-PI precip'+seasname
    plotdata(plio_anom,0,lon,lat,difftitle,-1,1,0.1,0,'a','mm/day')

    if HadCM3 =='y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_'+seasname+'HadCM3'+moses2+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



    # print out all the diagnostics we need for the paper

  # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   
    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        pi_land=pi_seasprecip/lsm
        pi_sea=pi_seasprecip / (np.abs(lsm-1.0))
        plio_land=plio_seasprecip/lsm
        plio_sea=plio_seasprecip / (np.abs(lsm-1.0))
        if HadCM3 !='y':
           pliop2_land=pliop2_seasprecip/lsm
           pliop2_sea=pliop2_seasprecip / (np.abs(lsm-1.0))
                                  
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=plio_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC)
        plt.show()
        sys.exit()

    # plot land precipitation for the mPWP and the PI
    if HadCM3 !='y':

        titlename='PI land precip'+seasname
        plotdata(pi_land*30.,99,lon,lat,titlename,0,80,1,0,'n','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/PI_land_precip_'+seasname+'HadGEM.eps' 
        plt.savefig(fileout,bbox_inches='tight')
        plt.close()

        titlename='mPWP land precip'+seasname
        plotdata(pliop2_land*30.,99,lon,lat,titlename,0,80,1,0,'n','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/mPWP_land_precip_'+seasname+'HadGEM.eps' 
        plt.savefig(fileout,bbox_inches='tight')
        plt.close()
    else:
        titlename='HadCM3 PI land precip'+seasname
        plotdata(pi_land*30.,99,lon,lat,titlename,0,80,1,0,'n','mm/month')
       
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/PI_land_precip_'+seasname+'HadCM3'+moses2+'.eps' 
        plt.savefig(fileout,bbox_inches='tight')
        plt.close()

        titlename='HadCM3 mPWP land precip'+seasname
        plotdata(plio_land*30.,99,lon,lat,titlename,0,80,1,0,'n','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/mPWP_land_precip_'+seasname+'HadCM3'+moses2+'.eps' 
        plt.savefig(fileout,bbox_inches='tight')
        plt.close()
   

    # print temperature changes
    # create weighting array
    weightarr=np.zeros(np.shape(pi_land))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('SEASON iS',seasname)
    print('----------------')
    print('mean pi precip',np.average(pi_seasprecip,weights=weightarr)) 
    print('mean plio precip',np.average(plio_seasprecip,weights=weightarr))

    print('mean pi precip land',np.average(pi_seasprecip,weights=weightarr*lsm)) 
    print('mean plio precip land',np.average(plio_seasprecip,weights=weightarr*lsm))
    print('mean pi precip sea',np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0))) 
    print('mean plio precip sea',np.average(plio_seasprecip,weights=weightarr*np.abs(lsm-1.0)))
    print('land panom',np.average(plio_seasprecip,weights=weightarr*lsm)-np.average(pi_seasprecip,weights=weightarr*lsm)) 
    print('sea panom',np.average(plio_seasprecip,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0))) 
    print('total panom',np.average(plio_seasprecip,weights=weightarr) - np.average(pi_seasprecip,weights=weightarr)) 
    print('land p %',(np.average(plio_seasprecip,weights=weightarr*lsm)-np.average(pi_seasprecip,weights=weightarr*lsm)) * 100. /  np.average(pi_seasprecip,weights=weightarr*lsm))
    print('sea p %',(np.average(plio_seasprecip,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0))) * 100. / np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0)))
    print('total p %',(np.average(plio_seasprecip,weights=weightarr) - np.average(pi_seasprecip,weights=weightarr)) * 100. / np.average(pi_seasprecip,weights=weightarr))
  

    if HadCM3 != 'y':
        print(' ')
        print ('mean plio p2 precip',np.average(pliop2_seasprecip,weights=weightarr))
        print('mean plio p2 precip land',np.average(pliop2_seasprecip,weights=weightarr*lsm))
        print('mean plio p2 precip sea',np.average(pliop2_seasprecip,weights=weightarr*np.abs(lsm-1.0))) 
        print('land panom',np.average(pliop2_seasprecip,weights=weightarr*lsm)-np.average(pi_seasprecip,weights=weightarr*lsm)) 
        print('sea panom',np.average(pliop2_seasprecip,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0))) 
        print('total panom',np.average(pliop2_seasprecip,weights=weightarr) - np.average(pi_seasprecip,weights=weightarr)) 
  
        print('land p %',(np.average(pliop2_seasprecip,weights=weightarr*lsm)-np.average(pi_seasprecip,weights=weightarr*lsm)) * 100. /  np.average(pi_seasprecip,weights=weightarr*lsm))
        print('sea p %',(np.average(pliop2_seasprecip,weights=weightarr*np.abs(lsm-1.0))-np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0))) * 100. / np.average(pi_seasprecip,weights=weightarr*np.abs(lsm-1.0)))
        print('total p %',(np.average(pliop2_seasprecip,weights=weightarr) - np.average(pi_seasprecip,weights=weightarr)) * 100. / np.average(pi_seasprecip,weights=weightarr))
    



#end def seasmean


def seasmean_get(m1,m2,m3,figureno,seasname,HadCM3,moses2,field):
    # this program is a bit like seasmean but it will just get the data
    # it won't analyse it or print anything out or plot anything

    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        if moses2 == 'y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
       
        else: # fergus simulation xgrad
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m3+'.nc')
      
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        if field=='precip':
            field='precip_1'
    aprecip=fa.variables[field][:]
    bprecip=fb.variables[field][:]
    cprecip=fc.variables[field][:]




    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 24. # mm/day
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
   
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        if moses2 =='y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        else:
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m3+'.nc')
       
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m3+'.nc')
    aprecip=fa.variables[field][:]
    bprecip=fb.variables[field][:]
    cprecip=fc.variables[field][:]
    lon = fa.variables['longitude'][:]
       

    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60.  * 24.
   
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
   
    retdata=[lon,lat,pi_seasprecip,plio_seasprecip]
    return retdata
    
#end def seasmean_get


def precip_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent,season,moses2):

    plt.close()
    if land_ocn_ind == 'l' or land_ocn_ind == 'o':  # land or ocean
        # get land mask
        if HadCM3 == 'y' :
            fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
        else:
            fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
        lsmlon=fm.variables['longitude'][:]
        lsmlat=fm.variables['latitude'][:]
        lsm=fm.variables['lsm'][:]
        lsm=np.squeeze(lsm)
        fm.close()

        
    if season != 'ann':
        m1='unknown'
        m2='unknown'
        m3='unknown'

        if season == 'djf':
            m1='dc'
            m2='ja'
            m3='fb'

        if season == 'mam':
            m1='mr'
            m2='ar'
            m3='my'

        if season == 'jja':
            m1='jn'
            m2='jl'
            m3='ag'

        if season == 'son':
            m1='sp'
            m2='ot'
            m3='nv'



    #==============
    # preindustrial

    if HadCM3 == 'y':
        if season == 'ann':
            if moses2 == 'y':
                f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
            else:
                f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*.nc')
        else:
            if moses2 == 'y':
                filebase='/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*%s.nc'
            else:
                filebase='/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[5-9]*%s.nc'

            filenames=(filebase % [m1,m2,m3])
            print('filenames are',filenames)
            f=MFDataset(filenames)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip'][:]
    else:
    # read in data from multiple files
        if season == 'ann':
            f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[5-9]*.nc')
        else:
            filebase='/nfs/hera1/earjcti/um/HadGEM_data/xkvje/precip_data/xkvjea@pdn[5-9]*%s_precip.nc'
            filenames=(filebase % [m1,m2,m3])
            print('filenames are',filenames)
            f=MFDataset(filenames)

        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip_1'][:]
    
    f.close()
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

#average across the time dimension and the latitude dimension
    pi_precip_ann=np.mean(aprecip,axis=0)

    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_precip_ann=pi_precip_ann / (lsm)
            pi_precip_ann[pi_precip_ann == float('Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_precip_ann=pi_precip_ann / (np.abs(lsm-1.0))
            pi_precip_ann[pi_precip_ann == float('Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

  
    
    pi_precip_lat_ann=np.nanmean(pi_precip_ann,axis=1)
    print('new shape pi',np.shape(pi_precip_lat_ann))

    mp.rcParams.update({'font.size':15})
    if HadCM3 == 'y':
        labelwrite='HadCM3_PI'
    else:
        labelwrite='HadGEM2_PI'
    if land_ocn_ind =='l':
        labelwrite=labelwrite+'_land_'
    if land_ocn_ind =='o':
        labelwrite=labelwrite+'_ocean_'
    if land_ocn_ind =='b':
        labelwrite=labelwrite+'_land_ocean_'

    valmin=0.
    valmax=10.
    if land_ocn_ind == 'l':
        valmax=9.
    print('pi precip lat',pi_precip_lat_ann*60.*60.*24.)    
    plt.plot(pi_precip_lat_ann*60.*60.*24.,lat,'g')
    plt.plot([valmin,valmax],[-14,-14])
    plt.plot([valmin,valmax],[-12,-12])
    plt.plot([valmin,valmax],[-10,-10])
    plt.plot([valmin,valmax],[-8,-8])
    plt.plot([valmin,valmax],[-6,-6])
    plt.plot([valmin,valmax],[-4,-4])
    plt.plot([valmin,valmax],[-2,-2])
    plt.plot([valmin,valmax],[0,0])
    plt.plot([valmin,valmax],[14,14])
    plt.plot([valmin,valmax],[12,12])
    plt.plot([valmin,valmax],[10,10])
    plt.plot([valmin,valmax],[8,8])
    plt.plot([valmin,valmax],[6,6])
    plt.plot([valmin,valmax],[4,4])
    plt.plot([valmin,valmax],[2,2])

    plt.xlabel('mm/day',fontsize=20)
    plt.ylabel('latitude',fontsize=20)
    axes=plt.gca()
    axes.set_ylim([-30,15])
    axes.set_xlim([valmin,valmax])
    plt.title(labelwrite+season,loc='left',fontsize=25)



    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        if season == 'ann':
            if moses2=='y':
                f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
            else:
                f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*.nc')    
        else:
            if moses2=='y':
                filebase='/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*%s.nc'
            else:
                filebase='/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*%s.nc'
            filenames=(filebase % [m1,m2,m3])
            print('filenames are',filenames)
            f=MFDataset(filenames)

        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip'][:]

    else:
        if season == 'ann':
            f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[5-9]*_precip.nc')
        else:
            filebase='/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/precip_data/xkvjfa@pdn[5-9]*%s_precip.nc'
            filenames=(filebase % [m1,m2,m3])
            print('filenames are',filenames)
            f=MFDataset(filenames)

        aprecip=f.variables['precip_1'][:]

    f.close()
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)

    plio_precip_ann=np.mean(aprecip,axis=0)


    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_precip_ann=plio_precip_ann / (lsm)
            plio_precip_ann[plio_precip_ann == float('Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_precip_ann=plio_precip_ann / (np.abs(lsm-1.0))
            plio_precip_ann[plio_precip_ann == float('Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')


    plio_precip_lat_ann=np.nanmean(plio_precip_ann,axis=1)


    if HadCM3 == 'y':
        plt.plot(plio_precip_lat_ann*60.*60.*24.,lat,'r')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+labelwrite+season+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
        

     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        if season == 'ann':
            f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[5-9]*.nc')
        else:
            filebase='/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/precip_data/xkvjga@pdn[5-9]*%s_precip.nc'
            filenames=(filebase % [m1,m2,m3])
            print('filenames are',filenames)
            f=MFDataset(filenames)

        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aprecip)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_precipp2_ann=np.mean(aprecip,axis=0)
        if land_ocn_ind == 'l': # mask out all non land points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_precipp2_ann=plio_precipp2_ann / (lsm)
                plio_precipp2_ann[plio_precipp2_ann == float('Inf')] = float('NaN')
            
            else:
                print('error lon/lat of land sea mask dont match')

        if land_ocn_ind == 'o': # mask out all non ocean points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_precipp2_ann=plio_precipp2_ann / (np.abs(lsm-1.0))
                plio_precipp2_ann[plio_precipp2_ann == float('Inf')] = float('NaN')

            else:
                print('error lon/lat of land sea mask dont match')


        plio_precipp2_lat_ann=np.nanmean(plio_precipp2_ann,axis=1)
        f.close()

        if HadCM3 == 'n':
            plt.plot(plio_precipp2_lat_ann*60.*60.*24.,lat,'r')
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+labelwrite+season+'.eps' 
            plt.savefig(fileout, bbox_inches='tight')  
            plt.close()



    # Pliocene - preindustrial

    if abs_pcent == 'a':
        plio_anom=(plio_precip_lat_ann-pi_precip_lat_ann)* 60. *  60. *24.
    if abs_pcent == 'p':
        plio_anom=(plio_precip_lat_ann-pi_precip_lat_ann)/ pi_precip_lat_ann
        plio_anom=plio_anom * 100.

    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        if abs_pcent == 'a':
          pliop2_anom=(plio_precipp2_lat_ann-pi_precip_lat_ann)* 60.*  60. *24.
        if abs_pcent == 'p':
          pliop2_anom=(plio_precipp2_lat_ann-pi_precip_lat_ann)/ pi_precip_lat_ann
          pliop2_anom=pliop2_anom * 100.



    if HadCM3 == 'y':
        allanom=[lat,plio_anom]
        return allanom
    else:
        allanom=[lat,plio_anom,pliop2_anom]
        return allanom
    
    



#end def precip_chg_by_latitude

#############################################
def nh_allseasons(HadMC3,moses2):
    if HadCM3=='n':
        plio_expt='xkvjg'
    else:
        plio_expt='HadCM3'+moses2

    # getdata for all seasons in nh we are going to put it on a nice figure
    retdata=seasmean_get('dc','ja','fb',figureno,'djf',HadCM3,moses2,'precip')
    lon=retdata[0]
    lat=retdata[1]
    pi_djf=retdata[2]
    plio_djf=retdata[3]

    mask_ind='n' # northernhemisphere
    plotmap_nh(plio_djf-pi_djf,plio_djf,pi_djf,0,lon,lat,'DJF',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,12,0,0,9,2)
   
    retdata=seasmean_get('mr','ar','my',figureno,'mam',HadCM3,moses2,'precip')
    pi_mam=retdata[2]
    plio_mam=retdata[3]
    plotmap_nh(plio_mam-pi_mam,plio_mam,pi_mam,1,lon,lat,'MAM',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,12,2,0,9,2)
      
 
    retdata=seasmean_get('jn','jl','ag',figureno,'jja',HadCM3,moses2,'precip')
    pi_jja=retdata[2]
    plio_jja=retdata[3]
    plotmap_nh(plio_jja-pi_jja,plio_jja,pi_jja,2,lon,lat,'JJA',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,12,4,0,9,2)
       

    retdata=seasmean_get('sp','ot','nv',figureno,'son',HadCM3,moses2,'precip')
    pi_son=retdata[2]
    plio_son=retdata[3]
    plotmap_nh(plio_son-pi_son,plio_son,pi_son,3,lon,lat,'SON',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,12,6,0,9,2)
   
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/NH_'+plio_expt+'_allseasons.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/NH_'+plio_expt+'_allseasons.tiff' 
    plt.savefig(fileout, bbox_inches='tight')  



#enddef nh_allseasons

def nh_allseasons_rainsnow(HadMC3,moses2):
# plot rain and snow amount for all seasons
    if HadCM3=='n':
        plio_expt='xkvjg'
    else:
        plio_expt='HadCM3'+moses2

    # getdata for all seasons in nh we are going to put it on a nice figure
    retdata=seasmean_get('dc','ja','fb',figureno,'djf',HadCM3,moses2,'rain')
    lon=retdata[0]
    lat=retdata[1]
    pi_djf_rain=retdata[2]
    plio_djf_rain=retdata[3]
    retdata=seasmean_get('dc','ja','fb',figureno,'djf',HadCM3,moses2,'snow')
    pi_djf_snow=retdata[2]
    plio_djf_snow=retdata[3]
    

    mask_ind='n' # northernhemisphere
    plotmap_nh_rainsnow(plio_djf_rain-pi_djf_rain,plio_djf_snow-pi_djf_snow,0,lon,lat,'DJF',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,0,0,5,2)
   
    retdata=seasmean_get('mr','ar','my',figureno,'mam',HadCM3,moses2,'rain')
    pi_mam_rain=retdata[2]
    plio_mam_rain=retdata[3]
    retdata=seasmean_get('mr','ar','my',figureno,'mam',HadCM3,moses2,'snow')
    pi_mam_snow=retdata[2]
    plio_mam_snow=retdata[3]
    plotmap_nh_rainsnow(plio_mam_rain-pi_mam_rain,plio_mam_snow-pi_mam_snow,1,lon,lat,'MAM',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,2,0,5,2)
      
 
    retdata=seasmean_get('jn','jl','ag',figureno,'jja',HadCM3,moses2,'rain')
    pi_jja_rain=retdata[2]
    plio_jja_rain=retdata[3] 
    retdata=seasmean_get('jn','jl','ag',figureno,'jja',HadCM3,moses2,'snow')
    pi_jja_snow=retdata[2]
    plio_jja_snow=retdata[3]
    plotmap_nh_rainsnow(plio_jja_rain-pi_jja_rain,plio_jja_snow-pi_jja_snow,2,lon,lat,'JJA',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,4,0,5,2)
       

    retdata=seasmean_get('sp','ot','nv',figureno,'son',HadCM3,moses2,'rain')
    pi_son_rain=retdata[2]
    plio_son_rain=retdata[3]
    retdata=seasmean_get('sp','ot','nv',figureno,'son',HadCM3,moses2,'snow')
    pi_son_snow=retdata[2]
    plio_son_snow=retdata[3]
    plotmap_nh_rainsnow(plio_son_rain-pi_son_rain,plio_son_snow-pi_son_snow,3,lon,lat,'SON',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,6,0,5,2)
   
  
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/NH_rainsnow_'+plio_expt+'_allseasons.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/NH_rainsnow'+plio_expt+'_allseasons.tiff' 
    plt.savefig(fileout, bbox_inches='tight')  



#enddef nh_allseasons_rainsnow


################################
# main program

# annual mean
figureno=0

HadCM3='y'
moses2='y'
#plt.figure(figureno)
annmean(figureno,HadCM3,moses2)
#figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',HadCM3,moses2)
#figureno=figureno+1

#mam mean
#plt.figure(figureno)
#seasmean('mr','ar','my',figureno,'mam',HadCM3,moses2)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3,moses2)
#figureno=figureno+1

#son mean
#plt.figure(figureno)
#seasmean('sp','ot','nv',figureno,'son',HadCM3,moses2)
#figureno=figureno+1


# just plot poleward of 30N for all seassons
# ie all seasons on one page
#nh_allseasons(HadCM3,moses2) # get precipitation
#nh_allseasons_rainsnow(HadCM3,moses2) # get rainsnow



# to see what the polar amplification is
#HadCM3='y'
#moses2='y'
#season='ann'
#land_ocn_ind='l'    # valid values are l - land , o- ocean b=both
#abs_pcent='a'       # valid values are p - percentage chg, a=absolute change
#precip_ret=precip_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent,season,moses2)
#lats_HadCM3=precip_ret[0]
#precip_anom_HadCM3=precip_ret[1]
#plt.plot(precip_anom_HadCM3,lats_HadCM3)

#moses2='n'
#precip_ret=precip_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent,season,moses2)
#lats_HadCM3=precip_ret[0]
#precip_anom_HadCM3m1=precip_ret[1]


#HadCM3='n'
#precip_ret=precip_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent,season,moses2)
#lats_HadGEM=precip_ret[0]
#precip_anom_HadGEM=precip_ret[1]
#precip_anom_HadGEMp2=precip_ret[2]

#mp.rcParams.update({'font.size':15})
#plt.plot(precip_anom_HadGEMp2,lats_HadGEM,'g',label='HadGEM2')
#plt.plot(precip_anom_HadCM3,lats_HadCM3,'r',label='HadCM3')
#plt.plot(precip_anom_HadCM3m1,lats_HadCM3,'b',label='HadCM3m1')
#plt.plot(precip_anom_HadGEM,lats_HadGEM,'b')

#if abs_pcent == 'a':
#    plt.xlabel('mm/day',fontsize=20)
#if abs_pcent == 'p':
#    plt.xlabel('%',fontsize=20)
#plt.ylabel('latitude',fontsize=20)

#if land_ocn_ind =='l':
#    plt.title('f) mPWP - preind land precip anom '+season,loc='left',fontsize=2#5)
#if land_ocn_ind =='o':
#    plt.title('g) mPWP - preind ocean precip anom '+season,loc='left',fontsize=#25)
#if land_ocn_ind =='b':
#    plt.title('e) mPWP - preind precip anom '+season,loc='left',fontsize=25)
#axes=plt.gca()
#if abs_pcent == 'p':
#    axes.set_xlim(xmin=-20.0,xmax=100.0)
#axes.set_ylim([-80,80])
#legend=plt.legend()
#if land_ocn_ind =='l':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_land_'+season+'.eps' 
#    if abs_pcent =='p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_land_pcent_'+season+'.eps' 
#if land_ocn_ind =='o':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_ocean_'+season+'.eps' 
#    if abs_pcent =='p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_ocean_pcent_'+season+'.eps' 

#print(land_ocn_ind,abs_pcent)
#if land_ocn_ind =='b':
#    if abs_pcent == 'a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_'+season+'.eps' 
#    if abs_pcent == 'p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpre#cip/MAP_polar_amp_'+season+'.eps' 
#plt.savefig(fileout, bbox_inches='tight')  



sys.exit(0)

####

::::::::::::::
plot_precip.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFPRECIP
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016
# Julia 26/08/2018 added a subprogram to focus on plotting precipitation
#                  in ITCZ region



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def plotmap_itcz # a copy of plotdata for doing itcz
#  def annmean
#  def seasmean
#  def focusitcz

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:
        plt.subplot(2,2,fileno+1)


    if mask_ind == 'l': # ;land mask
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

    if mask_ind =='t': # tropics mask
        northlat=30.0
        southlat=-30.0
    else:
        northlat=90.0
        southlat=-90.0

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if mask_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata


def plotmap_itcz(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind,ygrid,xgrid,yuse,xuse,yspan,xspan):


    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    #plt.subplot2grid((10,12),(fileno*2,0),colspan=9,rowspan=2)

    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    lons, lats = np.meshgrid(lon,lat)
   
    if mask_ind =='t': # tropics mask
        northlat=30.0
        southlat=-30.0
    elif mask_ind == 'talt': # alternative tropical region:
        northlat=45.0
        southlat=-30.0
    else:
        northlat=90.0
        southlat=-90.0

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata


    # plot limits
    if V == 0:
        V=np.arange(minval,maxval,valinc)

    # plot map
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotdata,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
   
    #parallels=np.arange(-90.,90.,15.)
    parallels=(-15,0,15,30)
    map.drawparallels(parallels,labels=[False,True,False,False]) # labels right
    meridians=np.arange(-180.,180.,60.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 
    # colorbar
    if fileno==0:
        plt.subplot2grid((10,12),(9,0),colspan=9,rowspan=1)
        plt.gca().set_visible(False)
        #cax=plt.axes([0.85,0.1,0.075,0.8])
        #cbar = plt.colorbar(cax=cax)
        #cbar = plt.colorbar(cs,orientation="horizontal",cax=cax)
        cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0)         
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=10)
        
   

    plotdata=plotdata2
    
    # plot map boundary
    map.drawmapboundary

#end def plotmap_itcz

def annmean(figureno,preind_expt,plio_expt,pliop2_expt,extra,mask_ind):
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'+preind_expt+'a@pd'+extra+'[5-9]*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

#average across the time dimension
    pi_precip_ann=np.mean(aprecip,axis=0)
    print('new shape',np.shape(pi_precip_ann))
    
    pi_precip_ann=pi_precip_ann * 60. * 60. * 24. * 30.
    
    plt.figure(0)
    lonprecip=lon
    pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    
    plotdata(pi_precip_ann,0,lon,lat,'PI-Ann_HadGEM2',0,275,25.0,0.0,'n','mm/month',mask_ind)


     #==============
     # Pliocene


    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'+plio_expt+'a@pd'+extra+'[5-9]*.nc')
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()


    plio_precip_ann=np.mean(aprecip,axis=0)
    plio_precip_ann=plio_precip_ann * 60. * 60. * 24. * 30.

    lon=lonprecip
    plio_precip_ann,lon = shiftgrid(180.,plio_precip_ann,lon,start=False)

    plotdata(plio_precip_ann,1,lon,lat,'Plio-PAnn_HG2',0,275,25,0.0,'n','mm/month',mask_ind)


     #==============
     # Pliocene+2


     # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    f.close()

    
    #average across the time dimension
    plio_precipp2_ann=np.mean(aprecip,axis=0)
    plio_precipp2_ann=plio_precipp2_ann * 60. * 60. * 24. * 30.
    lon=lonprecip
    plio_precipp2_ann,lon = shiftgrid(180.,plio_precipp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_precip_ann-pi_precip_ann

    print('plio_precip_ann',plio_precip_ann[20,:])
    print('pi_precip_ann',pi_precip_ann[20,:])
    print('plio_anom',plio_anom[20,:])


    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
    plotdata(plio_anom,2,lon,lat,'Plio - PI Panom_HG2',0,275,25,V,'la','mm/month',mask_ind)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=plio_precipp2_ann-pi_precip_ann
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]

    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month',mask_ind)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    ###############################################
    # plot anomaly in mm/day for paper.
    # also calculate mean changes
    #V=[-4,-2,-1,-0.5,-0.25,0,0.25,0.5,1,2,4]
    #plotdata(pliop2_anom/30.,99,lon,lat,'b) mPWP precipitation anomaly',0,275,25,V,'la','mm/day')
    #plt.show()

    V=0
    plotdata(pliop2_anom/30.,99,lon,lat,'b) mPWP precipitation anomaly',-2.0,2.2,0.2,V,'a','mm/day',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

  # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        anom_land=pliop2_anom / (30. * lsm)
        anom_sea=pliop2_anom / (30. * np.abs(lsm-1.0))
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=pliop2_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC,mask_ind)
        plt.show()
        sys.exit()


    # create weighting array
    weightarr=np.zeros(np.shape(anom_sea))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('mean anom_sea',np.average(pliop2_anom/30.,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(pliop2_anom/30.,weights=weightarr*lsm))
    print('allmean',np.average(pliop2_anom/30.,weights=weightarr))



    print('non plus 2')
    print('mean anom_sea',np.average(plio_anom/30.,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(plio_anom/30.,weights=weightarr*lsm))
    print('allmean',np.average(plio_anom/30.,weights=weightarr))

    

 


    


    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_precip_ann-pi_precip_ann)/pi_precip_ann)*100.
    plotdata(plio_peranom,0,lon,lat,'Plio - PI Panom_HG2 %',-50,60,5,0,'a','%',mask_ind)

    plio_peranomp2=((plio_precipp2_ann-pi_precip_ann)/pi_precip_ann)*100.
    plotdata(plio_peranomp2,1,lon,lat,'Plio - PI Panom_HG2+2 %',-50,60,5,0,'a','%',mask_ind)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # plot percentage change on a single plot

    plotdata(plio_peranomp2,99,lon,lat,'c) mPWP precipitation anomaly',-70,78,5,0,'a','%',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_pcent'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind):

    land_ocn_ext=''
    if mask_ind == 'l':
        land_ocn_ext='_land'
    if mask_ind == 'o':
        land_ocn_ext='_ocean'

    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'
    fileend='_precip.nc'
    fieldreq='precip_1'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+preind_expt+'_netcdf/'
        fileend='.nc'
        fieldreq='precip'
    
    filestart=filestart+preind_expt+'a@pd'+extra+'*'

   
    # read in data from multiple files
    print(filestart+m1+fileend)
    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    aprecip=fa.variables[fieldreq][:]
    bprecip=fb.variables[fieldreq][:]
    cprecip=fc.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

    fa.close()
    fb.close()
    fc.close()

    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    

# find standard deviation across time dimension
    pi_aprecip_stdev=np.std(aprecip*60.*60.*24.*30.,axis=0)
    pi_bprecip_stdev=np.std(bprecip*60.*60.*24.*30.,axis=0)
    pi_cprecip_stdev=np.std(cprecip*60.*60.*24.*30.,axis=0)



    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    plotdata(pi_seasprecip,0,lon,lat,'PI HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month',mask_ind)
    
     #==============
     # Pliocene

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/'

    filestart=filestart+plio_expt+'a@pd'+extra+'*'


    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    aprecip=fa.variables[fieldreq][:]
    bprecip=fb.variables[fieldreq][:]
    cprecip=fc.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    fa.close()
    fb.close()
    fc.close()



    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
    
    



     #==============
     # Pliocene+2

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+pliop2_expt+'_netcdf/'

    filestart=filestart+pliop2_expt+'a@pd'+extra+'*'


    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    aprecip=fa.variables[fieldreq][:]
    bprecip=fb.variables[fieldreq][:]
    cprecip=fc.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    fa.close()
    fb.close()
    fc.close()

    
    pliop2_aprecip_avg=np.mean(aprecip,axis=0)
    pliop2_bprecip_avg=np.mean(bprecip,axis=0)
    pliop2_cprecip_avg=np.mean(cprecip,axis=0)


    # find standard deviation across time dimension
    pliop2_aprecip_stdev=np.std(aprecip*60.*60.*24.*30.,axis=0)
    pliop2_bprecip_stdev=np.std(bprecip*60.*60.*24.*30.,axis=0)
    pliop2_cprecip_stdev=np.std(cprecip*60.*60.*24.*30.,axis=0)

    
    pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
    pliop2_seasprecip=pliop2_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    

    plotdata(plio_seasprecip,1,lon,lat,'Plio+2 HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month',mask_ind)
 

    # Pliocene - preindustrial

    plio_anom=plio_seasprecip-pi_seasprecip
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
   

    plotdata(plio_anom,2,lon,lat,'Plio - PI Panom_HG2',0,275,25,V,'la','mm/month',mask_ind)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seasprecip-pi_seasprecip
    #V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
   

    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month',mask_ind)



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    ###############################################
    # plot anomaly in mm/day for paper.
    # also calculate mean changes

    V=0
    titlename='b) mPWP precipitation anomaly '+seasname
    plotdata(pliop2_anom/30.,99,lon,lat,titlename,-2.0,2.2,0.2,V,'a','mm/day',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_'+pliop2_expt+'_'+seasname+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio-PI precip %'+seasname
    plotdata(plio_peranom,0,lon,lat,titlename,-50,50,5,0,'a','%',mask_ind)

    plio_peranomp2=((pliop2_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio+2-PI precip %'+seasname
    plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%',mask_ind)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # plot percentage change on a single plot
    titlename='c) mPWP precipitation anomaly'+seasname
    plotdata(plio_peranomp2,99,lon,lat,titlename,-70,78,5,0,'a','%',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_only_pcent'+pliop2_expt+'_'+seasname+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()





# plot standard deviation for plio for months

    plotdata(pliop2_aprecip_stdev,0,lon,lat,'Plio stdev m1: '+seasname,0,100,5.0,0.0,'n','mm/month',mask_ind)
    plotdata(pliop2_bprecip_stdev,1,lon,lat,'Plio stdev m2: '+seasname,0,100,5.0,0.0,'n','mm/month',mask_ind)
    plotdata(pliop2_cprecip_stdev,2,lon,lat,'Plio stdev m3: '+seasname,0,100,5.0,0.0,'n','mm/month',mask_ind)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/stdevP'+seasname+'_'+pliop2_expt+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
   
# plot difference in standard deviation for each month

    stdev_anom_1=pliop2_aprecip_stdev-pi_aprecip_stdev
    stdev_anom_2=pliop2_bprecip_stdev-pi_bprecip_stdev
    stdev_anom_3=pliop2_cprecip_stdev-pi_cprecip_stdev
    plotdata(stdev_anom_1,0,lon,lat,'Plio stdev m1: '+seasname,-20,25.0,5.0,0.0,'ra','mm/month',mask_ind)
    plotdata(stdev_anom_2,1,lon,lat,'Plio stdev m2: '+seasname,-20,25.0,5.0,0.0,'ra','mm/month',mask_ind)
    plotdata(stdev_anom_3,2,lon,lat,'Plio stdev m3: '+seasname,-20,25.0,5.0,0.0,'ra','mm/month',mask_ind)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/stdevP'+seasname+'anom'+pliop2_expt+land_ocn_ext+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



     


#end def seasmean



def seas_snowrain(m1,m2,m3,seasname,preind_expt,plio_expt,extra,HadCM3,mask_ind):

    land_ocn_ext=''
    if mask_ind == 'l':
        land_ocn_ext='_land'
    if mask_ind == 'o':
        land_ocn_ext='_ocean'

    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/pdfiles/'
    fileend='.nc'
    fieldrain='rain'
    fieldsnow='snow'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+preind_expt+'_netcdf/'
        fileend='.nc'
        fieldreq='precip'
    
    filestart=filestart+preind_expt+'a@pd'+extra+'*'

   
    # read in data from multiple files
    print(filestart+m1+fileend)
    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    arain=fa.variables[fieldrain][:]
    brain=fb.variables[fieldrain][:]
    crain=fc.variables[fieldrain][:]
    arain=np.squeeze(arain)
    brain=np.squeeze(brain)
    crain=np.squeeze(crain)
    ntimes,ny,nx=np.shape(arain)
    print(ntimes,ny,nx)


    asnow=fa.variables[fieldsnow][:]
    bsnow=fb.variables[fieldsnow][:]
    csnow=fc.variables[fieldsnow][:]
    asnow=np.squeeze(asnow)
    bsnow=np.squeeze(bsnow)
    csnow=np.squeeze(csnow)
   
    fa.close()
    fb.close()
    fc.close()

    
#average across the time dimension
    pi_arain_avg=np.mean(arain,axis=0)
    pi_brain_avg=np.mean(brain,axis=0)
    pi_crain_avg=np.mean(crain,axis=0)
   
    pi_asnow_avg=np.mean(asnow,axis=0)
    pi_bsnow_avg=np.mean(bsnow,axis=0)
    pi_csnow_avg=np.mean(csnow,axis=0)
    

    pi_seasrain=np.mean((pi_arain_avg,pi_brain_avg,pi_crain_avg),axis=0)
    pi_seasrain=pi_seasrain * 60. * 60. * 30. * 24.
  
    pi_seassnow=np.mean((pi_asnow_avg,pi_bsnow_avg,pi_csnow_avg),axis=0)
    pi_seassnow=pi_seassnow * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasrain,lon = shiftgrid(180.,pi_seasrain,lon,start=False)
    lon=lonprecip
    pi_seassnow,lon = shiftgrid(180.,pi_seassnow,lon,start=False)
    
    plotdata(pi_seasrain,0,lon,lat,'PI HadGEM2:rain '+seasname,0,50,5,0.0,'n','mm/month',mask_ind)
    
    plotdata(pi_seassnow,1,lon,lat,'PI HadGEM2:snow '+seasname,0,50,5,0.0,'n','mm/month',mask_ind)
    
     #==============
     # Pliocene

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/netcdf/pdfiles/'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/'

    filestart=filestart+plio_expt+'a@pd'+extra+'*'

    print(filestart+m1+fileend)
    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    arain=fa.variables[fieldrain][:]
    brain=fb.variables[fieldrain][:]
    crain=fc.variables[fieldrain][:]
    arain=np.squeeze(arain)
    brain=np.squeeze(brain)
    crain=np.squeeze(crain)
    asnow=fa.variables[fieldsnow][:]
    bsnow=fb.variables[fieldsnow][:]
    csnow=fc.variables[fieldsnow][:]
    asnow=np.squeeze(asnow)
    bsnow=np.squeeze(bsnow)
    csnow=np.squeeze(csnow)

    # average across the time dimension    
    plio_arain_avg=np.mean(arain,axis=0)
    plio_brain_avg=np.mean(brain,axis=0)
    plio_crain_avg=np.mean(crain,axis=0)
   
    plio_asnow_avg=np.mean(asnow,axis=0)
    plio_bsnow_avg=np.mean(bsnow,axis=0)
    plio_csnow_avg=np.mean(csnow,axis=0)
    
    fa.close()
    fb.close()
    fc.close()



    plio_seasrain=np.mean((plio_arain_avg,plio_brain_avg,plio_crain_avg),axis=0)
    plio_seasrain=plio_seasrain * 60. * 60. * 30. * 24.
    plio_seassnow=np.mean((plio_asnow_avg,plio_bsnow_avg,plio_csnow_avg),axis=0)
    plio_seassnow=plio_seassnow * 60. * 60. * 30. * 24.

    lon=lonprecip
    plio_seasrain,lon = shiftgrid(180.,plio_seasrain,lon,start=False)
    lon=lonprecip
    plio_seassnow,lon = shiftgrid(180.,plio_seassnow,lon,start=False)
    
   
    plotdata(plio_seasrain,2,lon,lat,'Plio+2 HadGEM2: rain '+seasname,0,50,5,0.0,'n','mm/month',mask_ind)
 
    plotdata(plio_seassnow,3,lon,lat,'Plio+2 HadGEM2: snow '+seasname,0,50,5,0.0,'n','mm/month',mask_ind)
 

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/rainsnow_'+plio_expt+'_'+preind_expt+land_ocn_ext+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    
    # Pliocene - preindustrial

    plio_rain_anom=plio_seasrain-pi_seasrain
    plio_snow_anom=plio_seassnow-pi_seassnow
   

    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
    V=0
   
    plotdata(plio_rain_anom,99,lon,lat,'Plio - PI Panom_HG2; rain '+seasname,-20,22,2,V,'a','mm/month',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/rainanom_'+plio_expt+'_'+preind_expt+land_ocn_ext+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
   
    plotdata(plio_snow_anom,99,lon,lat,'Plio - PI Panom_HG2; snow '+seasname,-20,22,2,V,'a','mm/month',mask_ind)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/snowanom_'+plio_expt+'_'+preind_expt+land_ocn_ext+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
    
    

#end def seasmean


def focusitcz(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind):

  
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'
    fileend='_precip.nc'
    fieldreq='precip_1'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+preind_expt+'_netcdf/'
        fileend='.nc'
        fieldreq='precip'
    
    filestart=filestart+preind_expt+'a@pd'+extra+'*'

   
    # read in data from multiple files
    print(filestart+m1+fileend)
    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    aprecip=fa.variables[fieldreq][:]
    bprecip=fb.variables[fieldreq][:]
    cprecip=fc.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

    fa.close()
    fb.close()
    fc.close()

    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    

    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    
    

     #==============
     # Pliocene+2

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+pliop2_expt+'_netcdf/'

    filestart=filestart+pliop2_expt+'a@pd'+extra+'*'

    print(filestart)
    fa=MFDataset(filestart+m1+fileend)
    fb=MFDataset(filestart+m2+fileend)
    fc=MFDataset(filestart+m3+fileend)
    aprecip=fa.variables[fieldreq][:]
    bprecip=fb.variables[fieldreq][:]
    cprecip=fc.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    fa.close()
    fb.close()
    fc.close()

    
    pliop2_aprecip_avg=np.mean(aprecip,axis=0)
    pliop2_bprecip_avg=np.mean(bprecip,axis=0)
    pliop2_cprecip_avg=np.mean(cprecip,axis=0)


    pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
    pliop2_seasprecip=pliop2_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    

    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seasprecip-pi_seasprecip
    #V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
   

  


    ###############################################
    # plot anomaly in mm/day for paper.
    # also calculate mean changes

    V=0
    titlename=seasname
    plotmap_itcz(pliop2_anom/30.,figureno,lon,lat,titlename,-2.0,2.2,0.2,V,'a','mm/day',mask_ind,10,12,figureno*2,0,9,2)
   

    # do line graph showing absolute value by latitude

   
    ax=plt.subplot2grid((10,12),(figureno*2,10),colspan=2,rowspan=2)
    ax.plot(np.mean(pliop2_seasprecip/30.,axis=1),lat,label='mPWP',linewidth=0.8)
    ax.plot(np.mean(pi_seasprecip/30.,axis=1),lat,label='PI',linewidth=0.8)
    # plot dotted lines at locations
    xmax=10
    xmin=0
    ax.plot([xmin,xmax],[-15,-15],color='black',linestyle='dotted',linewidth=0.8) 
    ax.plot([xmin,xmax],[0,0],color='black',linestyle='dotted',linewidth=0.8) 
    ax.plot([xmin,xmax],[15,15],color='black',linestyle='dotted',linewidth=0.8) 
   
    ax.tick_params(axis='y',which='both',labelleft='off')
    ax.set_ylim(-30,30)
    ax.set_xlim(xmin,xmax)
    if figureno !=3:
        ax.set_xticks([]) # disable xticks
    else:
        ax.set_xticks(list(range(xmin,xmax,2)))
        #ax.set_xlabel("mm/day",va='top')

    # add legend away from plot
    ax_leg=plt.subplot2grid((10,12),(9,10),colspan=2,rowspan=1)
    ax_leg.legend(*ax.get_legend_handles_labels(),loc='center')
    ax_leg.axis('off')
    plt.legend()
    


     


#end def focus itcz


def nonanomitcz(m1,figureno,monname,preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind):

  
    # m1 is the month 
    #==============
    # preindustrial

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'
    fileend='_precip.nc'
    fieldreq='precip_1'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+preind_expt+'_netcdf/'
        fileend='.nc'
        fieldreq='precip'
    
    filestart=filestart+preind_expt+'a@pd'+extra+'*'

   
    # read in data from multiple files
    fa=MFDataset(filestart+m1+fileend)
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    aprecip=fa.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)

    fa.close()

    
#average across the time dimension
    pi_monprecip=np.mean(aprecip,axis=0)
    pi_monprecip=pi_monprecip * 60. * 60. * 24. # mm/day

    lonprecip=lon
    pi_monprecip,lon = shiftgrid(180.,pi_monprecip,lon,start=False)
    
    
     #==============
     # Pliocene+2

    filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'
    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'+pliop2_expt+'_netcdf/'

    filestart=filestart+pliop2_expt+'a@pd'+extra+'*'


    fa=MFDataset(filestart+m1+fileend)
    aprecip=fa.variables[fieldreq][:]
    aprecip=np.squeeze(aprecip)
    fa.close()
    
    pliop2_monprecip=np.mean(aprecip,axis=0)
    pliop2_monprecip=pliop2_monprecip * 60. * 60. * 24.

    lon=lonprecip
    pliop2_monprecip,lon = shiftgrid(180.,pliop2_monprecip,lon,start=False)
    


    ###############################################
    # plot precip in mm/day for paper.
    # also calculate mean changes

    V=0
    titlename=monname+' mPWP'
    plotmap_itcz(pliop2_monprecip,figureno,lon,lat,titlename,0,15,0.1,V,'n','mm/day',mask_ind,4,1,0,0,1,1)
   
    titlename=monname+' PI'
    plotmap_itcz(pi_monprecip,figureno,lon,lat,titlename,0,15,0.1,V,'n','mm/day',mask_ind,4,1,1,0,1,1)

    titlename=monname+' anomaly'
    plotmap_itcz(pliop2_monprecip-pi_monprecip,figureno,lon,lat,titlename,-2.0,2,0.1,V,'a','mm/day',mask_ind,4,1,2,0,1,1)
   
  
#end def nonanomitcz

################################
# main program

# annual mean
#figureno=0
preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'
HadCM3='n'

#preind_expt='xiboi'
#plio_expt='xibol'
#pliop2_expt='xibol'
#extra='y'
#HadCM3='y'

#plt.figure(figureno)
#annmean(figureno,preind_expt,plio_expt,pliop2_expt,extra,'b')
#figureno=figureno+1

#djf mean
#mask_ind='b'  # values are l=land, o=ocean b=both
#seasmean('dc','ja','fb',figureno,'djf',preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind)

#mam mean
#seasmean('mr','ar','my',figureno,'mam',preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind)

#jja mean
#seasmean('jn','jl','ag',figureno,'jja',preind_expt,plio_expt,pliop2_expt,extra,#HadCM3,mask_ind)


#son mean
#seasmean('sp','ot','nv',figureno,'son',preind_expt,plio_expt,pliop2_expt,extra,#HadCM3,mask_ind)

######################################################################
# try and focus on the tropical (ITCZ) region

#fig=plt.figure()   
#mask_ind='t'  # values are l=land, o=ocean b=both t=tropics
#figureno=0
#focusitcz('dc','ja','fb',figureno,'DJF',preind_expt,plio_expt,pliop2_expt,extra#,HadCM3,mask_ind)
#focusitcz('mr','ar','my',1,'MAM',preind_expt,plio_expt,pliop2_expt,extra,HadCM3#,mask_ind)
#focusitcz('jn','jl','ag',2,'JJA',preind_expt,plio_expt,pliop2_expt,extra,HadCM3#,mask_ind)
#focusitcz('sp','ot','nv',3,'SON',preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind)


#fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/ITCZ#_diag_'+pliop2_expt+'_allseasons.eps' 
#plt.savefig(fileout, bbox_inches='tight')  

#fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/ITCZ#_diag_'+pliop2_expt+'_allseasons.tiff' 
#plt.savefig(fileout, bbox_inches='tight')  
  

#plt.close()



######################################################################
# have a look at non anomaly plots for the tropical region.
# this will just check the shape of the ITCZ

#fig=plt.figure()   
#mask_ind='talt'  # values are l=land, o=ocean b=both t=tropics
#HadCM3='n'
#figureno=0
#nonanomitcz('ja',figureno,'january',preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind)   


#monthnames=['fb','mr','ar','my','jn','jl','ag','sp','t','nv','dc']

#for month in monthnames:
#    print(month)
#    fig=plt.figure()
#    nonanomitcz(month,0,month,preind_expt,plio_expt,pliop2_expt,extra,HadCM3,mask_ind)   


##############################################################
# compare snowfall vs rain (particularly in winter

#djf mean
mask_ind='l'  # values are l=land, o=ocean b=both
seas_snowrain('dc','ja','fb','djf',preind_expt,pliop2_expt,extra,HadCM3,mask_ind)

#mam mean
seas_snowrain('mr','ar','my','mam',preind_expt,pliop2_expt,extra,HadCM3,mask_ind)

#jja mean
seas_snowrain('jn','jl','ag','jja',preind_expt,pliop2_expt,extra,HadCM3,mask_ind)


#son mean
seas_snowrain('sp','ot','nv','son',preind_expt,pliop2_expt,extra,HadCM3,mask_ind)



#plt.show()
#sys.exit(0)

####

::::::::::::::
plot_radiation.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_RADIATION
#PURPOSE
#    This program will plot the radiation budget for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import subprocess


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal",)

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def annmean(switch,HadCM3,expt,extra):
    # switch is a dummy variable to allow the program to be called

    # we will plot a) incoming sw ra flux (toa) field200
    #              b) incoming sw ra flux (toa) field201
    #              c) outgoing lw rad flux (toa) olr
    # other things if the budgets don't balance

    if HadCM3 == 'y':
        datasetname='/nfs/hera1/earjcti/um/netcdf/'+expt+'_netcdf/'+expt+'a@pd'+extra+'[7-9]*.nc'
        print(datasetname)
        f=MFDataset(datasetname)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        insw=f.variables['field200'][:]
        outsw=f.variables['field201'][:]
        outlw=f.variables['olr'][:]
        netlw= (-1.0) *outlw
        netsw=insw-outsw


        titlePI='PI-TAnn_HadCM3'
        titlediff='Plio - PI Tanom_HadCM3'
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/netcdf/'
        filename=expt+'a@pd'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename)
        os.system('ls '+dirname+filename+' | wc -l')
        nval=os.system('ls '+dirname+filename+' | wc -l')
        allfiles=subprocess.check_output('ls '+dirname+filename+' | wc -l',shell=True)
        print('number of files=',allfiles)
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        # net downward sw flux at the trop
        netsw=f.variables['solar_2'][:]
        # net downward lw flux at the trop
        netlw=f.variables['longwave_2'][:]

        # alternative 1
        insw=f.variables['field200'][:]
        outsw=f.variables['field201'][:]
        outlw=f.variables['olr'][:]
        netlw= (-1.0) *outlw
        netsw=insw-outsw


    netsw=np.squeeze(netsw)
    netlw=np.squeeze(netlw)
    ntimes,ny,nx=np.shape(netsw)
    print(ntimes,ny,nx)
    
#average across the time dimension
    netsw_ann=np.mean(netsw,axis=0)
    netlw_ann=np.mean(netlw,axis=0)
    
    
    plt.figure(0)
    wm2='w/m2'
    lontemp=lon
    titlename=expt+'net SW ann'
    netsw_ann,lon = shiftgrid(180.,netsw_ann,lon,start=False)    
    plotdata(netsw_ann,0,lon,lat,titlename,0,400,40.0,0.0,'n',wm2)


    lon=lontemp
    netlw_ann,lon = shiftgrid(180.,netlw_ann,lon,start=False)    
    plotdata(netlw_ann * (-1.0),1,lon,lat,' net lw ann',100,300,40.0,0.0,'n',wm2)

    # calculate residual and mean residual weighted by cos latitude

    residual=netsw_ann+ netlw_ann
  
    weights=np.cos(np.radians(lat))
    print('len weights',len(weights))
    resid_zon=np.average(residual,axis=0,weights=weights)
    average_residual=np.average(resid_zon)

    print(average_residual)
    titlename='residual, avg='+str(average_residual)+'(w/m2)'
    plotdata(residual,2,lon,lat,titlename,-100,100,20.0,0.0,'n',wm2)
    


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_radiation/annmean_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


#end def annmean



################################
# main program

# annual mean
figureno=0


#exptname='xkvjg'  #xkvje xkvjf xkvjg
#extra='n'
#HadCM3='n'
#exptname='ximut'
#extra='l'
#plt.figure(figureno)
#annmean('y',HadCM3,exptname,extra)
#figureno=figureno+1


HadCM3='y'
exptname='xhcph'
extra='j'
plt.figure(figureno)
annmean('y',HadCM3,exptname,extra)
figureno=figureno+1





#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',HadCM3)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3)
#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_regional_precip_indyear.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_regional_precip_indyear
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for each individual 
#    year for a specified region of the globe
#
# search for 'main program' to find end of functions
# Julia 9/2/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def get_annmean_precip
#  def get_seasmean_precip

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,lonmin,lonmax,latmin,latmax,plotbox):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(3,3,fileno+1)
    else:
        plt.subplot(2,1,1)

   # this is good for the globe
    map=Basemap(llcrnrlon=lonmin-10,urcrnrlon=lonmax+10,llcrnrlat=latmin-10,urcrnrlat=latmax+10,projection='cyl',resolution='c')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
#        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
#            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='max')
#                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)

    if plotbox =='y':  # overplot a box showing all the lats and lons
        plt.plot([lonmin,lonmin],[latmin,latmax],'white')
        plt.plot([lonmax,lonmax],[latmin,latmax],'white')
        plt.plot([lonmin,lonmax],[latmin,latmin],'white')
        plt.plot([lonmin,lonmax],[latmax,latmax],'white')
        

    if fileno == 99:  # single plot so add colorbar
        cbar = plt.colorbar(cs,orientation="horizontal")
        cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

##############################################
def get_annmean_precip(exptname,yearstart,yearend,lonmin,lonmax,latmin,latmax,regionname):


    # setup initial values before loop
    plotno=0
    fileform='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname

    # loop over each year and plot
    for year in range(yearstart,yearend):

        # get fileyear and extra value
        century=np.floor(year/100.)

        choices = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 
                   15: 'f', 16: 'g', 17: 'h', 18: 'i', 19: 'j', 
                   20: 'k', 21: 'l', 22: 'm', 23: 'n', 24: 'o', 
                   25: 'p', 26: 'q', 27: 'r', 28: 's', 29: 't', 
                   30: 'u', 31: 'v', 32: 'w', 33: 'x', 34: 'y', 
                   35: 'z'}

        extra=choices.get(century,99) # the second value is the default v
                                         # value for if it is not found in
                                         # the choices list
      
        yearuse=np.int(year-(century * 100))
        yearuse=str("%02d"%yearuse)
        
        fname=fileform+'a@pd'+extra+np.str(yearuse)+'*.nc'

        print(yearuse)
        print(fname)
        f=MFDataset(fname)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aprecip)
        
        if ntimes !=12:
            print('you have not got 12 months in year ',year)
            print('you have',ntimes)
            sys.exit()
        
    
       #average across the time dimension
        pi_precip_ann=np.mean(aprecip,axis=0)
    
        pi_precip_ann=pi_precip_ann * 60. * 60. * 24. * 30.
       
      

        # shift grid
        lonprecip=lon
        pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    

        # set up array with all data for averaging
        if year == yearstart:
            pi_precip_ann_allyears=np.zeros((yearend-yearstart,ny,nx))
            areamean_precip=np.zeros(yearend-yearstart)

            
        pi_precip_ann_allyears[year-yearstart,:,:]=pi_precip_ann


        # mask out latitudes required and get average over region

        ix1=(lon >=lonmin) & (lon <=lonmax)
        ix2=(lat >=latmin) & (lat <=latmax)
        lats_reg=lat[ix2]
        lons_reg=lon[ix1]
    
        mask_precip=pi_precip_ann[ix2]
        mask_precip=mask_precip[:,ix1]
        
        areamean_precip[year-yearstart]=np.mean(mask_precip)

        # plot the data and highlight the region of the average
       
        titlename=np.str(year)
        plotbox='y'
        plotdata(pi_precip_ann,plotno,lon,lat,titlename,0,300,1.0,0.0,'y','mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
        plotno=(plotno+1)%9

        if plotno ==0 or year==yearend:
            plt.subplots_adjust(bottom=0.2)
            cax=plt.axes([0.1,0.1,0.8,0.045])
            plt.colorbar(cax=cax,orientation='horizontal')
            axistitle='precip for '+exptname+ 'mm/month'
            plt.title(axistitle)
            
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_'+np.str(year)+'_'+regionname+'.eps'
            plt.savefig(fileout, bbox_inches='tight')  

            plt.close()

    # now plot average
    titlename=exptname+'_allavg_'+regionname
    plotdata(np.mean(pi_precip_ann_allyears,axis=0),99,lon,lat,titlename,0,300,1.0,0.0,'y','mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
    # plot average over region
    plt.subplot(2,1,2)
    plt.plot(areamean_precip)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_annaverage_'+regionname+'.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()




#end def annmean


def seasmean(m1,m2,m3,seasname,exptname,yearstart,yearend,lonmin,lonmax,latmin,latmax,regionname):

    # set up stuff for plotting depending on region
    uselog='n'
    plotmax=500
    if regionname=='Sahara':
        uselog='y'
        plotmax=300

    # setup initial values before loop
    plotno=0
    fileform='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname

    # loop over each year and plot
    for year in range(yearstart,yearend):

        # get fileyear and extra value
        century=np.floor(year/100.)

        choices = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 
                   15: 'f', 16: 'g', 17: 'h', 18: 'i', 19: 'j', 
                   20: 'k', 21: 'l', 22: 'm', 23: 'n', 24: 'o', 
                   25: 'p', 26: 'q', 27: 'r', 28: 's', 29: 't', 
                   30: 'u', 31: 'v', 32: 'w', 33: 'x', 34: 'y', 
                   35: 'z'}

        extra=choices.get(century,99) # the second value is the default v
                                         # value for if it is not found in
                                         # the choices list
      
        yearuse=np.int(year-(century * 100))
        yearuse=str("%02d"%yearuse)
        
        fname=fileform+'a@pd'
        y1=np.str(yearuse)
        y2=np.str(yearuse)
        y3=np.str(yearuse)
        e1=extra
        e2=extra
        e3=extra


        # if 1 is november or december then we need to use previous year
        if m1 == 'nv' or m1 == 'dc':
            print('reformatting month1')
            century=np.floor((year-1)/100.)
            e1=choices.get(century,99) 
            yearuse=np.int((year-1)-(century * 100))
            y1=str("%02d"%yearuse)

        if m2 == 'dc':
            print('reformatting month2')
            century=np.floor(year-1/100.)
            e1=choices.get(century,99) 
            yearuse=np.int(year-1-(century * 100))
            y2=str("%02d"%yearuse)

        

        
        print('yearuse=',yearuse)
        print(fname+e1+np.str(y1)+m1+'_precip.nc')
        print(fname+e2+np.str(y2)+m2+'_precip.nc')
        print(fname+e3+np.str(y3)+m3+'_precip.nc')
        print(' ')
        fa=Dataset(fname+e1+np.str(y1)+m1+'_precip.nc')
        fb=Dataset(fname+e2+np.str(y2)+m2+'_precip.nc')
        fc=Dataset(fname+e3+np.str(y3)+m3+'_precip.nc')

        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        bprecip=np.squeeze(bprecip)
        cprecip=np.squeeze(cprecip)
        ny,nx=np.shape(aprecip)


        # average across the time dimension
        precip_seas=np.mean([aprecip,bprecip,cprecip],axis=0)
        precip_seas=precip_seas * 60. * 60. * 24. * 30.
       
      

        # shift grid
        lonprecip=lon
        precip_seas,lon = shiftgrid(180.,precip_seas,lon,start=False)
    

        # set up array with all data for averaging
        if year == yearstart:
            precip_seas_allyears=np.zeros((yearend-yearstart,ny,nx))
            areamean_precip=np.zeros(yearend-yearstart)

            
        precip_seas_allyears[year-yearstart,:,:]=precip_seas


        # mask out latitudes required and get average over region

        ix1=(lon >=lonmin) & (lon <=lonmax)
        ix2=(lat >=latmin) & (lat <=latmax)
        lats_reg=lat[ix2]
        lons_reg=lon[ix1]
    
        mask_precip=precip_seas[ix2]
        mask_precip=mask_precip[:,ix1]
        
        areamean_precip[year-yearstart]=np.mean(mask_precip)

        # plot the data and highlight the region of the average
       
        titlename=np.str(year)
        plotbox='y'
        plotdata(precip_seas,plotno,lon,lat,titlename,0,plotmax,1.0,0.0,uselog,'mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
        plotno=(plotno+1)%9

        if plotno ==0 or year==yearend:
            plt.subplots_adjust(bottom=0.2)
            cax=plt.axes([0.1,0.1,0.8,0.045])
            plt.colorbar(cax=cax,orientation='horizontal')
            axistitle='precip for '+exptname+ 'mm/month'
            plt.title(axistitle)
            
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_'+np.str(year)+'_'+seasname+'_'+regionname+'.eps'
            plt.savefig(fileout, bbox_inches='tight')  

            plt.close()

    # now plot average
    titlename=exptname+'_allavg_'+regionname
    plotdata(np.mean(precip_seas_allyears,axis=0),99,lon,lat,titlename,0,plotmax,1.0,0.0,uselog,'mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
    # plot average over region
    plt.subplot(2,1,2)
    plt.plot(areamean_precip)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_'+seasname+'_'+regionname+'.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()





#end def seasmean

################################
# main program

# annual mean
figureno=0

#plt.figure(figureno)
#get_annmean_precip('xkvjf',2301,2400,-10.0,30.0,15.0,30.0,'Sahara')
#figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb','djf','xkvje',2301,2400,15.0,30.0,-30.0,-5.0,'SAfrica')
seasmean('jl','ag','sp','jas','xkvje',2301,2400,75.0,85.0,10.0,25.0,'India')
seasmean('jl','ag','sp','jas','xkvjg',2301,2400,75.0,85.0,10.0,25.0,'India')
#figureno=figureno+1



#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja')
#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_salinity.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SALINITY
#PURPOSE
#    This program will do all the plots to do with salinity
#    we will begin by plotting salinity by depth across the Atlantic
#    However we will move on to other things to do with satlinity
# search for 'main program' to find end of functions
# Julia 19/1/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)


   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata
#####################################
def plot_lat_dep(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,cbarname):
    lats, deps  = np.meshgrid(lat,dep)

    V=np.arange(minval,maxval,valinc)
    
    print(np.shape(plotdata))
    cs = plt.contourf(lats,deps,plotdata,V,extend="both")
    plt.gca().invert_yaxis()

    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata

#  to check if a character is numeric
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

#============================
def Atlantic_salinity_depth_plot(expt_name):



#  get data from files

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pg2/'+expt_name+'o@pg*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    dep = f.variables['depth_1'][:]
    salin=f.variables['salinity'][:]
    salin=np.squeeze(salin)
    f.close()

    ntimes,ndep,nlat,nlon=np.shape(salin)
    print(ntimes,ndep,nlat,nlon)

    mean_salin=np.mean(salin,axis=0)


    print(np.shape(mean_salin))

#  get mask of Oceans
    filemask='/nfs/see-fs-02_users/earjcti/MOC/merid/basin_hadgom_216'
    f1=open(filemask,'r')
    # discard 3 title lines
    textline=f1.readline()
    textline=f1.readline()
    textline=f1.readline()
    # next line is details from basin
    nrows=nlat
    Indian_d=np.zeros((nrows,4))
    Pacific_d=np.zeros((nrows,4))
    Atlantic_d=np.zeros((nrows,4))
    Combined_d=np.zeros((nrows,4))
    for line in f1:
        linesplit=line.split()  # split line by space
        if is_number(linesplit[0]):
            rowno=int(linesplit[0])
            Indian_d[rowno-1,:]=int(linesplit[1]),int(linesplit[2]),\
                int(linesplit[3]),int(linesplit[4])
            Pacific_d[rowno-1,:]=int(linesplit[5]),int(linesplit[6]),\
                int(linesplit[7]),int(linesplit[8])
            Atlantic_d[rowno-1,:]=int(linesplit[9]),int(linesplit[10]),\
                int(linesplit[11]),int(linesplit[12])
            Combined_d[rowno-1,:]=int(linesplit[13]),int(linesplit[14]),\
                int(linesplit[15]),int(linesplit[16])

    f1.close()

    Indian_mask=np.ones((nlat,nlon),dtype=bool)
    Pacific_mask=np.ones((nlat,nlon),dtype=bool)
    Atlantic_mask=np.ones((nlat,nlon),dtype=bool)
    Combined_mask=np.ones((nlat,nlon),dtype=bool)
    for j in range(0,nrows):
        Indian_mask[j,Indian_d[j,0]:Indian_d[j,1]]=0
        Indian_mask[j,Indian_d[j,2]:Indian_d[j,3]]=0
        Pacific_mask[j,Pacific_d[j,0]:Pacific_d[j,1]]=0
        Pacific_mask[j,Pacific_d[j,2]:Pacific_d[j,3]]=0
        Atlantic_mask[j,Atlantic_d[j,0]:Atlantic_d[j,1]]=0
        Atlantic_mask[j,Atlantic_d[j,2]:Atlantic_d[j,3]]=0
        Combined_mask[j,Combined_d[j,0]:Combined_d[j,1]]=0
        Combined_mask[j,Combined_d[j,2]:Combined_d[j,3]]=0



    # get mean salinity over indian ocean
    Indian_salin=np.ma.masked_array(mean_salin,mask=np.tile(Indian_mask,(mean_salin.shape[0],1)))
    Pacific_salin=np.ma.masked_array(mean_salin,mask=np.tile(Pacific_mask,(mean_salin.shape[0],1)))
    Atlantic_salin=np.ma.masked_array(mean_salin,mask=np.tile(Atlantic_mask,(mean_salin.shape[0],1)))
    Combined_salin=np.ma.masked_array(mean_salin,mask=np.tile(Combined_mask,(mean_salin.shape[0],1)))

    lontemp=lon
    Indian_salin,lon = shiftgrid(180.,Indian_salin,lon,start=False)
    lon=lontemp
    Pacific_salin,lon = shiftgrid(180.,Pacific_salin,lon,start=False)
    lon=lontemp
    Atlantic_salin,lon = shiftgrid(180.,Atlantic_salin,lon,start=False)
    lon=lontemp
    Combined_salin,lon = shiftgrid(180.,Combined_salin,lon,start=False)


   # plotmap(Indian_salin[0,:,:]*1000.,0,lon,lat,'test Ind',-4,4,0.5,0.0,'n','psu')
   # plotmap(Pacific_salin[0,:,:]*1000.,1,lon,lat,'test Pac',-4,4,0.5,0.0,'n','psu')
   # plotmap(Atlantic_salin[0,:,:]*1000.,2,lon,lat,'test Atl',-4,4,0.5,0.0,'n','psu')
   # plotmap(Combined_salin[0,:,:]*1000.,3,lon,lat,'test Com',-4,4,0.5,0.0,'n','psu')
   # plt.show()


    # julia note - atlantic basin is fine - not sure about other ones


    # now average the salinity across the latitude over the Atlantic basin

    print('Atl Salin',np.shape(Atlantic_salin))
    Atlantic_sal_avg=np.mean(Atlantic_salin,axis=2)
    print('Atl salin mean',np.shape(Atlantic_sal_avg),np.shape(lat),np.shape(dep))
    

    titlename='Atlantic Salinity: '+expt_name
    plot_lat_dep((Atlantic_sal_avg*1000.)+35.0,0,lat,dep,titlename,33,36,0.2,'psu')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/'+expt_name+'_salinity.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    return(lat,dep,Atlantic_sal_avg)
    

#end def Atlantic_salinity_depth_plot
#end def annmean



################################
# main program

# annual mean salinity by depth

retdata=Atlantic_salinity_depth_plot('xkvjg')
lat=retdata[0]
dep=retdata[1]
xkvjg_salinity=retdata[2]

retdata=Atlantic_salinity_depth_plot('xkvjf')
xkvjf_salinity=retdata[2]

retdata=Atlantic_salinity_depth_plot('xkvje')
xkvje_salinity=retdata[2]


# plot lat depthanomalies
titlename='Atlantic Salinity xkvjg - xkvje'
sal_anom=xkvjg_salinity-xkvje_salinity
plot_lat_dep((sal_anom*1000.),0,lat,dep,titlename,-0.5,0.6,0.1,'psu')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/xkvjg-xkvje_salinity_anom.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

titlename='Atlantic Salinity xkvjf - xkvje'
sal_anom=xkvjf_salinity-xkvje_salinity
plot_lat_dep((sal_anom*1000.),0,lat,dep,titlename,-0.5,0.6,0.1,'psu')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/xkvjf-xkvje_salinity_anom.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()



sys.exit(0)

####

::::::::::::::
plot_seaice.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SEAICE
#PURPOSE
#    This program will plot the sea ice change mPWP-PI in the simulations
#
# search for 'main program' to find end of functions
# Julia 28/11/2018


import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(region,plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,oplot_pi,pi_seaice):

    if region == 'NP':
        proj='npstere'
        latbb=45.
    if region == 'SP':
        proj='spstere'
        latbb=-45.
    #proj='stere'

    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe

    map=Basemap(projection=proj,resolution='c',lon_0=0,boundinglat=latbb,round=True,lat_0=90)
    #map=Basemap(projection='stere', lat_0=90., lon_0=0.,
    #                       llcrnrlon=-180, llcrnrlat=60.,
    #                       urcrnrlon=180., urcrnrlat=60.)


    #map.drawmapboundary(fill_color='green')
    map.drawmapboundary

    x, y = map(lons, lats)

    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='i': #increasing
                    print(V)
                    cs = map.contourf(x,y,plotdata,V,norm=mp.colors.LogNorm(vmin=0,vmax=32),cmap='Reds')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    mycmap=mp.cm.get_cmap('Reds',len(V+2))
                    newcolors=mycmap(np.linspace(0,1,len(V+2)))
                    white=([1,1,1,1])
                    newcolors[0:2,:]=white
                    mycmap=ListedColormap(newcolors)
                    cs = map.contourf(x,y,plotdata,V,cmap=mycmap)
                   # map.drawparallels(np.arange(-80.,81.,20.))
                   # map.drawmeridians(np.arange(-180.,181.,20.))
                    map.fillcontinents()
                  
                    cbar = plt.colorbar(cs,orientation="horizontal")
                    # overplot in contours where preindustrial sea ice was over 50% (or 0.5)
                    if oplot_pi == 'y':
                        map.contour(x,y,pi_seaice,[0,0.5],colors='lime',linestyles=[':','--'],linewidth=10)
  


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   


#end def plotdata

def seasmean(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

    # read in temperature from a single file in order to get land mask
    f=Dataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/pffiles/'+preind_expt+'o@pf'+extra+'76ja.nc')
    temp=f.variables['temp'][:]
    mask=temp/temp # ie temp is 1 everywhere except where it is masked
    mask=np.squeeze(mask)
    f.close()
   

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/pffiles/'+preind_expt+'o@pf'+extra+'*'+m1+'.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/pffiles/'+preind_expt+'o@pf'+extra+'*'+m2+'.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/pffiles/'+preind_expt+'o@pf'+extra+'*'+m3+'.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    atemp=fa.variables['iceconc'][:]
    btemp=fb.variables['iceconc'][:]
    ctemp=fc.variables['iceconc'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    ntimes,ny,nx=np.shape(atemp)
    
    #average across the time dimension
    pi_atemp_avg=np.mean(atemp,axis=0)
    pi_btemp_avg=np.mean(btemp,axis=0)
    pi_ctemp_avg=np.mean(ctemp,axis=0)

    #stdev across the time dimension
    pi_atemp_stdev=np.std(atemp,axis=0)
    pi_btemp_stdev=np.std(btemp,axis=0)
    pi_ctemp_stdev=np.std(ctemp,axis=0)
    
    pi_seaice=np.mean((pi_atemp_avg,pi_btemp_avg,pi_ctemp_avg),axis=0)
   
    
    pi_seaice=pi_seaice * mask
    
  
    plotdata('NP',pi_seaice,0,lon,lat,'PI HadGEM2: '+seasname,0,1.1,0.1,0,'n','fraction','y',pi_seaice)
    plotdata('SP',pi_seaice,1,lon,lat,'PI HadGEM2: '+seasname,0,1.1,0.1,0,'n','fraction','y',pi_seaice)
    

    fa.close()
    fb.close()
    fc.close()
   
     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pffiles/'+pliop2_expt+'o@pf'+extra+'*'+m1+'.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pffiles/'+pliop2_expt+'o@pf'+extra+'*'+m2+'.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pffiles/'+pliop2_expt+'o@pf'+extra+'*'+m3+'.nc')
    atemp=fa.variables['iceconc'][:]
    btemp=fb.variables['iceconc'][:]
    ctemp=fc.variables['iceconc'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    
    pliop2_atemp_avg=np.mean(atemp,axis=0)
    pliop2_btemp_avg=np.mean(btemp,axis=0)
    pliop2_ctemp_avg=np.mean(ctemp,axis=0)
    
    pliop2_seaice=np.mean((pliop2_atemp_avg,pliop2_btemp_avg,pliop2_ctemp_avg),axis=0)

    
    fa.close()
    fb.close()
    fc.close()
   


    # plot data
    
    #pliop2_seaice=pliop2_seaice * mask

 
    plotdata('NP',pliop2_seaice,2,lon,lat,'Plio HadGEM2: '+seasname,0,1.1,0.1,0,'n','fraction','n',pi_seaice)
    plotdata('SP',pliop2_seaice,3,lon,lat,'Plio HadGEM2: '+seasname,0,1.1,0.1,0,'n','fraction','n',pi_seaice)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/'+seasname+'_'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    


    # Pliocene - preindustrial

    perc_lost=((pi_seaice-pliop2_seaice)/pi_seaice)*100.
    plotdata('NP',perc_lost,99,lon,lat,'Sea ice loss:'+seasname,0,105.,5.0,0,'n','%','y',pi_seaice)
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/'+seasname+'_'+pliop2_expt+'_NP_iceanom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
  

    plotdata('SP',perc_lost,99,lon,lat,'Sea ice loss:'+seasname,0,105.,5.0,0,'n','%','y',pi_seaice)
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/'+seasname+'_'+pliop2_expt+'_SP_iceanom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
    
    plt.show()
    


######################################################   
def seascyc(preind_expt,pliop2_expt,extra,HadCM3):
# get seasonal cycle of sea ice

    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']

    if HadCM3=='y':
        filestart='/nfs/hera1/earjcti/um/'
        filemid='/netcdf/'
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'
        filemid='/netcdf/pffiles/'

    # read in temperature from a single file in order to get land mask
    f=Dataset(filestart+preind_expt+filemid+preind_expt+'o@pf'+extra+'76ja.nc')
    temp=f.variables['temp'][:]
    mask=temp/temp # ie temp is 1 everywhere except where it is masked
   
    if HadCM3 == 'y':
      mask=np.ma.array(temp,mask=temp > 1E10)
      mask=mask/mask

    mask=np.squeeze(mask)
    f.close()
   
   
    # read in data from pi and pliocene files
    for mon in range(0,len(monthnames)):
        print(mon)
        fa=MFDataset(filestart+preind_expt+filemid+preind_expt+'o@pf'+extra+'[7-9]*'+monthnames[mon]+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        atemp=fa.variables['iceconc'][:]
        atemp=np.squeeze(atemp)
        htemp=fa.variables['icedepth'][:]
        htemp=np.squeeze(htemp)
        fa.close()
        print('array size pi',np.shape(atemp))
        pi_atemp_avg=np.mean(atemp,axis=0)
        pi_htemp_avg=np.mean(htemp,axis=0)
      

        fa=MFDataset(filestart+pliop2_expt+filemid+pliop2_expt+'o@pf'+extra+'[7-9]*'+monthnames[mon]+'.nc')
        atemp=fa.variables['iceconc'][:]
        atemp=np.squeeze(atemp)
        htemp=fa.variables['icedepth'][:]
        htemp=np.squeeze(htemp)
       
        print('array size plio',np.shape(atemp))
        pliop2_atemp_avg=np.mean(atemp,axis=0)
        pliop2_htemp_avg=np.mean(htemp,axis=0)
       
        fa.close()
        print('gotdata',mon)
  

          
        ny,nx=np.shape(pi_atemp_avg)
        if mon == 0:
            pi_seaice=np.zeros((len(monthnames),ny,nx))
            plio_seaice=np.zeros((len(monthnames),ny,nx))
            pi_seaice_d=np.zeros((len(monthnames),ny,nx))
            plio_seaice_d=np.zeros((len(monthnames),ny,nx))
   
        pi_seaice[mon,:,:]=pi_atemp_avg
        plio_seaice[mon,:,:]=pliop2_atemp_avg
        pi_seaice_d[mon,:,:]=pi_htemp_avg
        plio_seaice_d[mon,:,:]=pliop2_htemp_avg
        
   
    #======================================================
    # get average area of seaice

    xres=lon[1]-lon[0]
    yres=lat[1]-lat[0]
    a=40075. # circumference of earth in km
    onedeg=a/360.
    gridbox_nonweight=xres * yres * onedeg * onedeg
  
    pi_avg_ice_nh=np.zeros(len(monthnames))
    plio_avg_ice_nh=np.zeros(len(monthnames))
    pi_avg_ice_sh=np.zeros(len(monthnames))
    plio_avg_ice_sh=np.zeros(len(monthnames))

    pi_vol_ice_nh=np.zeros(len(monthnames))
    plio_vol_ice_nh=np.zeros(len(monthnames))
    pi_vol_ice_sh=np.zeros(len(monthnames))
    plio_vol_ice_sh=np.zeros(len(monthnames))

    for mon in range(0,len(monthnames)):
        print('averaging for',mon)
        for j in range(0,ny):
            coslat=np.cos(np.radians(lat[j]))
            if lat[j] > 0 :
                for i in range(0,nx):
                    pi_avg_ice_nh[mon]=(pi_avg_ice_nh[mon] + 
                        (pi_seaice[mon,j,i] * coslat * gridbox_nonweight))
                    plio_avg_ice_nh[mon]=(plio_avg_ice_nh[mon] + 
                        (plio_seaice[mon,j,i] * coslat * gridbox_nonweight))

                    pi_vol_ice_nh[mon]=(pi_vol_ice_nh[mon] + 
                       (pi_seaice_d[mon,j,i] * coslat * gridbox_nonweight))
                    plio_vol_ice_nh[mon]=(plio_vol_ice_nh[mon] + 
                        (plio_seaice_d[mon,j,i] * coslat * gridbox_nonweight))

            if lat[j] < 0 :
                for i in range(0,nx):
                    pi_avg_ice_sh[mon]=(pi_avg_ice_sh[mon] + 
                        (pi_seaice[mon,j,i] * coslat * gridbox_nonweight))
                    plio_avg_ice_sh[mon]=(plio_avg_ice_sh[mon] + 
                        (plio_seaice[mon,j,i] * coslat * gridbox_nonweight))

                    pi_vol_ice_sh[mon]=(pi_vol_ice_sh[mon] + 
                       (pi_seaice_d[mon,j,i] * coslat * gridbox_nonweight))
                    plio_vol_ice_sh[mon]=(plio_vol_ice_sh[mon] + 
                        (plio_seaice_d[mon,j,i] * coslat * gridbox_nonweight))

       
    
    plt.plot(np.arange(1,13),pi_avg_ice_nh,label='PI')
    plt.plot(np.arange(1,13),plio_avg_ice_nh,label='mPWP')
    plt.title('Arctic Sea Ice - Areal extent',fontsize=20)
    plt.ylabel('km^2',fontsize=20)
    plt.xlabel('month',fontsize=20)
    plt.legend(fontsize=20)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/'+pliop2_expt+'_NH_areal_extent.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
 

    plt.plot(np.arange(1,13),pi_avg_ice_sh,label='PI')
    plt.plot(np.arange(1,13),plio_avg_ice_sh,label='mPWP')
    plt.title('Antarctic Sea Ice - Areal extent')
    plt.ylabel('km^2')
    plt.xlabel('month')
    plt.legend()

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/'+pliop2_expt+'_SH_areal_extent.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
  
   
    retdata=[pi_avg_ice_nh,plio_avg_ice_nh,pi_avg_ice_sh,plio_avg_ice_sh,pi_vol_ice_nh,plio_vol_ice_nh,pi_vol_ice_sh,plio_vol_ice_sh]
    return(retdata)

# end def seascyc








################################
# main program

# annual mean
figureno=0

#preind_expt='xkvje'
#plio_expt='xkvjg'
#pliop2_expt='xkvjg'
#extra='n'
#HadCM3='n'

preind_expt='xiboi'
plio_expt='xibol'
pliop2_expt='xibol'
extra='y'
HadCM3='y'



#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',preind_expt,plio_expt,pliop2_expt,extra)

#mam mean
#plt.figure(figureno)
#seasmean('mr','ar','my',figureno,'mam',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#son mean
#plt.figure(figureno)
#seasmean('sp','ot','nv',figureno,'son',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#####################################
# plot annual cycle of sea ice loss

preind_expt='xkvje'
plio_expt='xkvjg'
pliop2_expt='xkvjg'
extra='n'
HadCM3='n'
retdata=seascyc(preind_expt,pliop2_expt,extra,HadCM3)
pi_ice_nh_HadGEM=retdata[0]
plio_ice_nh_HadGEM=retdata[1]
pi_ice_sh_HadGEM=retdata[2]
plio_ice_sh_HadGEM=retdata[3]
pi_vol_nh_HadGEM=retdata[4]
plio_vol_nh_HadGEM=retdata[5]
pi_vol_sh_HadGEM=retdata[6]
plio_vol_sh_HadGEM=retdata[7]
print('got HadGEM data') 

preind_expt='xiboi'
plio_expt='xibol'
pliop2_expt='xibol'
extra='y'
HadCM3='y'
retdata=seascyc(preind_expt,pliop2_expt,extra,HadCM3)
pi_ice_nh_HadCM3=retdata[0]
plio_ice_nh_HadCM3=retdata[1]
pi_ice_sh_HadCM3=retdata[2]
plio_ice_sh_HadCM3=retdata[3]
pi_vol_nh_HadCM3=retdata[4]
plio_vol_nh_HadCM3=retdata[5]
pi_vol_sh_HadCM3=retdata[6]
plio_vol_sh_HadCM3=retdata[7]
print('got HadCM3 data') 

# HadCM3 does not agree with fergus' paper where it is 10million
# here we have 7.6million.

print('Arctic sea ice extent in HadGEM',np.mean(plio_ice_nh_HadGEM))
print('Arctic sea ice extent in HadCM3',np.mean(plio_ice_nh_HadCM3))
 
# sea ice areal extent SH

fig=plt.figure()
ax=plt.subplot(111)
ax.plot(np.arange(1,13),pi_ice_sh_HadGEM/1000000.,'b',label='PI HadGEM')
ax.plot(np.arange(1,13),plio_ice_sh_HadGEM/1000000.,'r',label='mPWP HadGEM')
ax.plot(np.arange(1,13),pi_ice_sh_HadCM3/1000000,'b--',label='PI HadCM3')
ax.plot(np.arange(1,13),plio_ice_sh_HadCM3/1000000,'r--',label='mPWP HadCM3')
plt.title('f) Antarctic Sea Ice - Areal Extent',fontsize=20,loc='left')
plt.ylabel('million km^2',fontsize=15)
plt.xlabel('month',fontsize=15)
plt.legend(fontsize=15)
plt.tick_params(axis='both',labelsize=15)
box=ax.get_position()
ax.set_position([box.x0,box.y0+box.height*0.1,box.width,box.height*0.9])
ax.legend(loc='lower center',bbox_to_anchor=(0.5,-0.3),ncol=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_SH_areal_extent.eps' 
plt.savefig(fileout, bbox_inches='tight')  
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_SH_areal_extent.png' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()


# sea ice vol extent SH

plt.plot(np.arange(1,13),pi_vol_sh_HadGEM,'b',label='PI HadGEM')
plt.plot(np.arange(1,13),plio_vol_sh_HadGEM,'r',label='mPWP HadGEM')
plt.plot(np.arange(1,13),pi_vol_sh_HadCM3,'b--',label='PI HadCM3')
plt.plot(np.arange(1,13),plio_vol_sh_HadCM3,'r--',label='mPWP HadCM3')
plt.title('Antarctic Sea Ice - volume')
plt.ylabel('m^3')
plt.xlabel('month')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_SH_vol.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

#sea ice loss SH

plt.plot(np.arange(1,13),pi_ice_sh_HadGEM-plio_ice_sh_HadGEM,label='HadGEM')
plt.plot(np.arange(1,13),pi_ice_sh_HadCM3-plio_ice_sh_HadCM3,label='HadCM3')
plt.title('Antarctic Sea Ice - Loss')
plt.ylabel('km^2')
plt.xlabel('month')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_SH_loss.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

# NH sea ice extent
fig=plt.figure()
ax=plt.subplot(111)
ax.plot(np.arange(1,13),pi_ice_nh_HadGEM/1000000.,color='b',label='PI HadGEM')
ax.plot(np.arange(1,13),plio_ice_nh_HadGEM/1000000.,color='r',label='mPWP HadGEM')
ax.plot(np.arange(1,13),pi_ice_nh_HadCM3/1000000.,'b--',label='PI HadCM3')
ax.plot(np.arange(1,13),plio_ice_nh_HadCM3/1000000.,'r--',label='mPWP HadCM3')
plt.title('e) Arctic Sea Ice - Areal Extent',fontsize=20,loc='left')
plt.ylabel('million km^2',fontsize=15)
plt.xlabel('month',fontsize=15)
plt.tick_params(axis='both',labelsize=15)
box=ax.get_position()
ax.set_position([box.x0,box.y0+box.height*0.1,box.width,box.height*0.9])
ax.legend(loc='lower center',bbox_to_anchor=(0.5,-0.3),ncol=4)

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_NH_areal_extent.eps' 
plt.savefig(fileout, bbox_inches='tight')  
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_NH_areal_extent.png' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

# sea ice vol extent NH

plt.plot(np.arange(1,13),pi_vol_nh_HadGEM,'b',label='PI HadGEM')
plt.plot(np.arange(1,13),plio_vol_nh_HadGEM,'r',label='mPWP HadGEM')
plt.plot(np.arange(1,13),pi_vol_nh_HadCM3,'b--',label='PI HadCM3')
plt.plot(np.arange(1,13),plio_vol_nh_HadCM3,'r--',label='mPWP HadCM3')
plt.title('e) Arctic Sea Ice - volume')
plt.ylabel('m^3')
plt.xlabel('month')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_NH_vol.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

  
#sea ice loss NH

plt.plot(np.arange(1,13),pi_ice_nh_HadGEM-plio_ice_nh_HadGEM,label='HadGEM')
plt.plot(np.arange(1,13),pi_ice_nh_HadCM3-plio_ice_nh_HadCM3,label='HadCM3')
plt.title('Arctic Sea Ice - Loss')
plt.ylabel('km^2')
plt.xlabel('month')
plt.legend()

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_seaice/HadCM3_and_HadGEM_NH_loss.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()


sys.exit(0)

####

::::::::::::::
plot_smc.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SMC
#PURPOSE
#    This program will plot the soil moisture (annual at present)
#    it is based on plot_surftemp.py
#
# search for 'main program' to find end of functions
# Julia 10/7/2017
# Julia 10/12/2018 # added in seasonal



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary

    x, y = map(lons, lats)

    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='i': #increasing
                    cs = map.contourf(x,y,plotdata,V,extend='both',cmap='Reds')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    mycmap=mp.cm.get_cmap('rainbow',len(V+2))
                    newcolors=mycmap(np.linspace(0,1,len(V+2)))
                    white=([1,1,1,1])
                    newcolors[(len(V)/2)-1:(len(V)/2)+2,:]=white
                    mycmap=ListedColormap(newcolors)
               
                    cs = map.contourf(x,y,plotdata,V,cmap=mycmap,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40,size=15)
    else:
        cbar.set_label(cbarname,labelpad=-50,size=15)
        cbar.ax.tick_params(labelsize=15)
        plt.title(titlename,loc='left',fontsize=18)
   


#end def plotdata

###########################################################
def plotmap_nh(plotdata,mPWP_data,PI_data,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind,ygrid,xgrid,yuse,xuse,yspan,xspan):


    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    #plt.subplot2grid((10,12),(fileno*2,0),colspan=9,rowspan=2)

    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    lons, lats = np.meshgrid(lon,lat)
   
    if mask_ind =='n': # tropics mask
        northlat=90.0
        southlat=30.0
    elif mask_ind == 'nalt': # alternative tropical region:
        northlat=90.0
        southlat=0.0
    else:
        northlat=90.0
        southlat=-90.0

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata


    # plot limits
    if V == 0:
        V=np.arange(minval,maxval,valinc)

    # plot map
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotdata,V,cmap='YlGnBu',extend='both')
    else:
        mycmap=mp.cm.get_cmap('RdBu_r',len(V+2))
        newcolors=mycmap(np.linspace(0,1,len(V+2)))
        white=([1,1,1,1])
        newcolors[(len(V)/2)-2:(len(V)/2)+3,:]=white
        mycmap=ListedColormap(newcolors)
        cs = map.contourf(x,y,plotdata,V,cmap=mycmap,extend='both')
       
        if xuse==0:
            # overplot in contours where preindustrial
            # soil moisture fraction is 0.2, 0.4 0.6
            map.contour(x,y,PI_data,[0.2],colors=['lime'])
            map.contour(x,y,mPWP_data,[0.2],colors=['red'])
              

    #parallels=np.arange(-90.,90.,15.)
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,False,False,False]) # labels right
    meridians=np.arange(-180.,180.,90.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 
    # colorbar
    if fileno==0:

        plt.subplot2grid((10,12),(9,xuse),colspan=yspan,rowspan=1)
        plt.gca().set_visible(False)
        if xuse==0:
            cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0,ticks=np.arange(-0.5,0.6,0.1),format='%0.1f')
        else:
            cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0,ticks=np.arange(-0.5,0.6,0.25),format='%0.2f')         
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=7)
         

    plotdata=plotdata2
    
    # plot map boundary
    map.drawmapboundary



#end def plotmap_nh



def plotdata_oplotpi(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,pi_sm):
    # here we are overplotting preindustrial data as contours (currently only added to code for maptype 'a' (anomaly)
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe without antarctica

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-60.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary

    x, y = map(lons, lats)

    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                mycmap=mp.cm.get_cmap('RdBu_r',len(V+2))
                newcolors=mycmap(np.linspace(0,1,len(V+2)))
                white=([1,1,1,1])
                print(len(V),len(V/2))
                newcolors[(len(V)/2)-2:(len(V)/2)+3,:]=white
                mycmap=ListedColormap(newcolors)
                   
                cs = map.contourf(x,y,plotdata,V,cmap=mycmap,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
                 # overplot in contours where preindustrial
                 # soil moisture fraction is 0.2, 0.4 0.6
                map.contour(x,y,pi_sm,[0.2,0.5],colors=['red','lime'],linestyles=['--','--','--'],linewidth=10)
              
            else:
                if uselog =='i': #increasing
                    cs = map.contourf(x,y,plotdata,V,extend='both',cmap='Reds')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,cmap='Spectral',extend='max')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40,size=15)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=15)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   


#end def plotdata

def annmean(switch,preind_expt,plio_expt,pliop2_expt,extra,layers,HadCM3):
    # switch is a dummy variable to allow the program to be called


    if layers == 'y':
        fieldname='sm_1'
        fieldtitle='smcl'
    elif layers =='u':
        fieldname='field1385'
        fieldtitle='unfrozen frac'
    else:
        fieldname='sm'

    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'
        filemid='_netcdf/'
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'
        filemid='/netcdf/pdfiles/'

    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset(filestart+preind_expt+filemid+preind_expt+'a@pd'+extra+'[5-9]*.nc')
    
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables[fieldname][:]
    atemp=np.squeeze(atemp)
  


    if layers != 'n' :
        ntimes,nz,ny,nx=np.shape(atemp)
        print(ntimes,nz,ny,nx)
    else:
        ntimes,ny,nx=np.shape(atemp)
        nz=1
  

    
#average across the time dimension

    pi_smc_ann=np.mean(atemp,axis=0)
    print('new shape',np.shape(pi_smc_ann))

    if layers != 'n':
        lontemp=lon  
        valmax=np.zeros(nz)
        valmin=np.zeros(nz)
        valdiff=np.zeros(nz)
        valmax[0]=50.
        valmax[1]=150.
        valmax[2]=250.
        valmax[3]=1000.
        if layers == 'u':
            valmax[:]=0.7
            valmin[:]=0.2
        valdiff=(valmax-valmin)/10.
        for k in range(0,nz):
            lon=lontemp
            pi_smc_ann_lev,lon = shiftgrid(180.,pi_smc_ann[k,:,:],lon,start=False)
            titlename='PI '+fieldtitle
            plotdata(pi_smc_ann_lev,k,lon,lat,titlename,valmin[k],valmax[k],valdiff[k],0.0,'n','kg m-2')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/PI_levels_'+preind_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()

    else:
        lontemp=lon    
        pi_smc_ann,lon = shiftgrid(180.,pi_smc_ann,lon,start=False)
        plotdata(pi_smc_ann,0,lon,lat,'PI SMC',0,100,10.0,0.0,'n','kg m-2')

    
    f.close()


     #==============
     # Pliocene


    f=MFDataset(filestart+plio_expt+filemid+plio_expt+'a@pd'+extra+'[5-9]*.nc')
    atemp=f.variables[fieldname][:]
    atemp=np.squeeze(atemp)

    plio_smc_ann=np.mean(atemp,axis=0)

    if layers != 'n':
        for k in range(0,nz):
            lon=lontemp
            plio_smc_ann_lev,lon = shiftgrid(180.,plio_smc_ann[k,:,:],lon,start=False)
            titlename='Plio '+fieldtitle
            plotdata(plio_smc_ann_lev,k,lon,lat,titlename,valmin[k],valmax[k],valdiff[k],0.0,'n','kg m-2')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_'+plio_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
      
    else:

        lon=lontemp
        plio_smc_ann,lon = shiftgrid(180.,plio_smc_ann,lon,start=False)
        plotdata(plio_smc_ann,1,lon,lat,'Plio-SMC_HG2',0,100,10.0,0.0,'n','kg m-2')

 
    f.close()


     #==============
     # Pliocene+2


     # read in data from multiple files
    f=MFDataset(filestart+pliop2_expt+filemid+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    atemp=f.variables[fieldname][:]
    atemp=np.squeeze(atemp)
    
    #average across the time dimension
    pliop2_smc_ann=np.mean(atemp,axis=0)

    if layers != 'n':
        for k in range(0,nz):
            lon=lontemp
            pliop2_smc_ann_lev,lon = shiftgrid(180.,pliop2_smc_ann[k,:,:],lon,start=False)
            titlename='Pliop2'+fieldtitle+pliop2_expt
            plotdata(pliop2_smc_ann_lev,k,lon,lat,titlename,valmin[k],valmax[k],valdiff[k],0.0,'n','kg m-2')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_'+pliop2_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
    else:


        lon=lontemp
        pliop2_smc_ann,lon = shiftgrid(180.,pliop2_smc_ann,lon,start=False)
        plotdata(pliop2_smc_ann,2,lon,lat,'Pliop2 SMC',0,100.,10.,0.0,'n','kg m-2')

    f.close()



    
    # Pliocene+2 - preindustrial


    if layers != 'n':
        pliop2_anom=pliop2_smc_ann-pi_smc_ann
        for k in range(0,nz):
            lon=lontemp
            pliop2_anom_lev,lon = shiftgrid(180.,pliop2_anom[k,:,:],lon,start=False)
            titlename='Pliop2 - PI, level= '+np.str(k)+' expt:'+pliop2_expt
            if layers == 'y':
                plotdata(pliop2_anom_lev,k,lon,lat,titlename,-50.,60,10,0.0,'a','kg m-2')
            if layers == 'u':
                plotdata(pliop2_anom_lev,k,lon,lat,titlename,-0.25,0.3,0.05,0.0,'a','kg m-2')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_anom_'+pliop2_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
    else:

        pliop2_anom=pliop2_smc_ann-pi_smc_ann
        titlename='PlioP2 - PI SMC '+pliop2_expt
        plotdata(pliop2_anom,3,lon,lat,titlename,-50,50,10.0,0,'a','kg m-2')


        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/smc_alllayers'+pliop2_expt+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()




    # Pliocene+2 - preindustrial (percentage change)


    if layers != 'n':
        pliop2_pcent_anom=((pliop2_smc_ann-pi_smc_ann)/pi_smc_ann) *100.
        for k in range(0,nz):
            lon=lontemp
            pliop2_pcent_anom_lev,lon = shiftgrid(180.,pliop2_pcent_anom[k,:,:],lon,start=False)
            titlename='Pliop2 - PI (%), level= '+np.str(k)+' expt:'+pliop2_expt
            plotdata(pliop2_pcent_anom_lev,k,lon,lat,titlename,-30.,35,5,0.0,'a','%')
      
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_anom_pcent'+pliop2_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
    
    # if looking at unfrozen moisture fraction.  We need a weighted average 
    # of the top 3 levels

    if layers=='u':
        unfroz_plio=(pliop2_smc_ann[0,:,:] * 0.1) + (pliop2_smc_ann[1,:,:] * 0.25) + (pliop2_smc_ann[2,:,:] * 0.65)
        unfroz_pi=(pi_smc_ann[0,:,:] * 0.1) + (pi_smc_ann[1,:,:] * 0.25) + (pi_smc_ann[2,:,:] * 0.65)
        pcent_diff=((unfroz_plio-unfroz_pi) / unfroz_pi) * 100,
        pcent_diff=np.squeeze(pcent_diff)
        lon=lontemp
        pcent_diff,lon = shiftgrid(180.,pcent_diff,lon,start=False)
        titlename='Pliop2 - PI (%), level= '+np.str(k)+' expt:'+pliop2_expt
        plotdata(pcent_diff,0,lon,lat,titlename,-10.,35,2,0.0,'n','%',)
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_anom_pcent'+pliop2_expt+'_'+fieldname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
       
#  if layers eq 'n' then produce the plot for the paper.
# it is the total soil moisture content that the UM sees.
     
    if layers == 'n':
        if HadCM3 == 'y':
            plotdata(pliop2_anom,99,lon,lat,'f) HadCM3: mPWP-PI SMC anomaly',-40.,42.5,2.5,0,'n','kg m-2')
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/totsmc_anom_HadCM3.eps' 
        else:
            plotdata(pliop2_anom,99,lon,lat,'e) HadGEM2: mPWP-PI SMC anomaly',-40,42.5,2.5,0,'n','kg m-2')
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/totsmc_anom_HadGEM2.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()


 

#end def annmean





def seasmean(months,preind_expt,plio_expt,extra,layers,HadCM3,seasname):
    # switch is a dummy variable to allow the program to be called


    if layers == 'y':
        fieldname='sm_1'
        fieldtitle='smcl'
    elif layers =='f':
        fieldname='field1386'
        fieldtitle='frozen frac'
    else:
        fieldname='sm'

    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'
        filemid='_netcdf/'
    else:
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'
        filemid='/netcdf/pdfiles/'

    #==============
    # get data

    for mon in range(0,len(months)):
        filename=filestart+preind_expt+filemid+preind_expt+'a@pd'+extra+'[7-9]*'+months[mon]+'.nc'
        print(filename)
        f=MFDataset(filename)
    
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables[fieldname][:]
        

        if layers != 'n' :
            ntimes,nz,ny,nx=np.shape(atemp)
            print(ntimes,nz,ny,nx)
        else:
            ntimes,nz,ny,nx=np.shape(atemp)
            
        if mon == 0:
            pi_smc_allmonths=np.zeros((ntimes,nz,ny,nx))
            plio_smc_allmonths=np.zeros((ntimes,nz,ny,nx))
        pi_smc_allmonths=pi_smc_allmonths+atemp
        f.close()
        

        #mPWP
        f=MFDataset(filestart+plio_expt+filemid+plio_expt+'a@pd'+extra+'[7-9]*'+months[mon]+'.nc')
        atemp=f.variables[fieldname][:]
  
        plio_smc_allmonths=plio_smc_allmonths+atemp
        f.close()
       

  

    plio_smc_allmonths=plio_smc_allmonths / len(months)
    pi_smc_allmonths=pi_smc_allmonths / len(months)
    
    #average across the time dimension

  
    pi_smc_seas=np.mean(pi_smc_allmonths,axis=0)
    plio_smc_seas=np.mean(plio_smc_allmonths,axis=0)

   
    # plot raw data
    if layers != 'n':
        lontemp=lon  
        valmax=np.zeros(nz)
        valmin=np.zeros(nz)
        valdiff=np.zeros(nz)
        valmax[0]=50.
        valmax[1]=150.
        valmax[2]=250.
        valmax[3]=1000.
        cbartitle='kg m-2'
        if layers == 'u' or layers =='f':
            valmax[:]=0.7
            valmin[:]=0.2
            cbartitle='frac'
        valdiff=(valmax-valmin)/10.
        # plot pi
        figno=0.
        for k in range(0,4):
            lon=lontemp
            pi_smc_seas_lev,lon = shiftgrid(180.,pi_smc_seas[k,:,:],lon,start=False)
            titlename='PI '+fieldtitle+'_',seasname+' lev='+np.str(k)
            plotdata(pi_smc_seas_lev,figno,lon,lat,titlename,valmin[k],valmax[k],valdiff[k],0.0,'n',cbartitle)
            figno=figno+1
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/PI_levels_'+preind_expt+'_'+fieldname+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()

        # plot pliocene
        figno=0
        for k in range(0,4):
            lon=lontemp
            plio_smc_seas_lev,lon = shiftgrid(180.,plio_smc_seas[k,:,:],lon,start=False)
            titlename='mPWP '+fieldtitle+'_',seasname+' lev='+np.str(k)
            plotdata(plio_smc_seas_lev,figno,lon,lat,titlename,valmin[k],valmax[k],valdiff[k],0.0,'n','kg m-2')
            figno=figno+1
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/mPWP_levels_'+preind_expt+'_'+fieldname+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()


    else:
        lontemp=lon
        pi_smc_seas=np.squeeze(pi_smc_seas)
        plio_smc_seas=np.squeeze(plio_smc_seas)
        pi_smc_seas,lon = shiftgrid(180.,pi_smc_seas,lon,start=False)
        plotdata(pi_smc_seas,0,lon,lat,'PI SMC',0,100,10.0,0.0,'n','kg m-2')
        lon=lontemp   
        plio_smc_seas,lon = shiftgrid(180.,plio_smc_seas,lon,start=False)
        plotdata(plio_smc_seas,0,lon,lat,'mPWP SMC',0,100,10.0,0.0,'n','kg m-2')

   

   
    ####################################
    # Pliocene - preindustrial


    if layers != 'n':
        plio_anom=plio_smc_seas-pi_smc_seas
        figno=0
        for k in range(0,4):
            lon=lontemp
            plio_anom_lev,lon = shiftgrid(180.,plio_anom[k,:,:],lon,start=False)
            titlename='Plio - PI, level= '+np.str(k)+' expt:'+plio_expt
            if layers == 'y':
                plotdata(plio_anom_lev,figno,lon,lat,titlename,-50.,60,10,0.0,'a','kg m-2')
            if layers == 'u' or layers =='f':
                plotdata(plio_anom_lev,figno,lon,lat,titlename,-0.25,0.3,0.05,0.0,'a','kg m-2')
            figno=figno+1
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_anom_'+plio_expt+'_'+fieldname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
    else:

        plio_anom=plio_smc_seas-pi_smc_seas
        titlename='Plio - PI SMC '+plio_expt+seasname
        plotdata(plio_anom,3,lon,lat,titlename,-50,50,10.0,0,'a','kg m-2')


        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/smc_alllayers'+plio_expt+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()




    # Pliocene - preindustrial (percentage change)


    if layers != 'n':
        plio_pcent_anom=((plio_smc_seas-pi_smc_seas)/pi_smc_seas) *100.
        for k in range(0,nz):
            lon=lontemp
            plio_pcent_anom_lev,lon = shiftgrid(180.,plio_pcent_anom[k,:,:],lon,start=False)
            titlename='Plio - PI (%), level= '+np.str(k)+' expt:'+plio_expt+seasname
            plotdata(plio_pcent_anom_lev,k,lon,lat,titlename,-100.,105,5,0.0,'a','%')
      
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_levels_anom_pcent'+plio_expt+'_'+fieldname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
    
    # if looking at frozen moisture fraction.  We need a weighted average 
    # of the top 3 levels

    if layers=='f':
        froz_plio=(plio_smc_seas[0,:,:] * 0.1) + (plio_smc_seas[1,:,:] * 0.25) + (plio_smc_seas[2,:,:] * 0.65)
        froz_pi=(pi_smc_seas[0,:,:] * 0.1) + (pi_smc_seas[1,:,:] * 0.25) + (pi_smc_seas[2,:,:] * 0.65)
        pcent_diff=((froz_plio-froz_pi) / froz_pi) * 100,
        pcent_diff=np.squeeze(pcent_diff)
        frac_diff=(froz_plio-froz_pi) 
        frac_diff=np.squeeze(frac_diff)
        lon=lontemp
        pcent_diff,lon = shiftgrid(180.,pcent_diff,lon,start=False)
        lon=lontemp
        frac_diff,lon = shiftgrid(180.,frac_diff,lon,start=False)
        lon=lontemp
        froz_pi_plot,lon = shiftgrid(180.,froz_pi,lon,start=False)
        titlename='Plio - PI (%), level= '+np.str(k)+' expt:'+plio_expt+seasname
        plotdata_oplotpi(pcent_diff,99,lon,lat,titlename,-70.,75,5,0.0,'a','%',froz_pi_plot)
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_anom_pcent'+plio_expt+'_'+fieldname+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
    
        # also plot fraction change
        titlename='Plio - PI frac, levels= '+np.str(k)+' expt:'+plio_expt+' '+seasname
       
        plotdata_oplotpi(frac_diff,99,lon,lat,titlename,-0.2,0.22,0.01,0.0,'a','frac',froz_pi_plot)
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/Plio_anom_frac'+plio_expt+'_'+fieldname+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()
      
       
#  if layers eq 'n' then produce the plot for the paper.
# it is the total soil moisture content that the UM sees.
     
    if layers == 'n':
        if HadCM3 == 'y':
            plotdata(plio_anom,99,lon,lat,'d) HadCM3 SMC anomaly '+seasname,-40.,45.,5.,0,'n','kg m-2')
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/totsmc_anom_HadCM3_'+seasname+'.eps' 
        else:
            plotdata(plio_anom,99,lon,lat,'c) HadGEM2: SMC anomaly '+seasname,-40,45,5,0,'n','kg m-2')
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/totsmc_anom_HadGEM2'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()



 

#end def seasmean


def nh_data_get(m1,m2,m3,seasname,HadCM3,moses2,field,pi_expt,plio_expt):

    # this program is a bit like seasmean but it will just get the data
    # it won't analyse it or print anything out or plot anything

    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial
    print('j2',pi_expt)
   
    # read in data from multiple files
    if HadCM3 == 'y':
        if moses2 == 'y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdy[7-9]*'+m3+'.nc')
       
        else: # fergus simulation xgrad
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdq[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdq[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+pi_expt+'_netcdf/'+pi_expt+'a@pdq[7-9]*'+m3+'.nc')
      
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pi_expt+'/netcdf/pdfiles/'+pi_expt+'a@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pi_expt+'/netcdf/pdfiles/'+pi_expt+'a@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pi_expt+'/netcdf/pdfiles/'+pi_expt+'a@pdn[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
    a=fa.variables[field][:]
    b=fb.variables[field][:]
    c=fc.variables[field][:]


    a=np.squeeze(a)
    b=np.squeeze(b)
    c=np.squeeze(c)
    
#average across the time dimension
    pi_a_avg=np.mean(a,axis=0)
    pi_b_avg=np.mean(b,axis=0)
    pi_c_avg=np.mean(c,axis=0)

    
    pi_seas_temp=np.mean((pi_a_avg,pi_b_avg,pi_c_avg),axis=0)
    # we need a weighted average over the top 3 layers if frozen

    if field == 'field1386':
        pi_seas=(pi_seas_temp[0,:,:] * 0.1) + (pi_seas_temp[1,:,:] * 0.25) + (pi_seas_temp[2,:,:] * 0.65)
    else:
        pi_seas=pi_seas_temp

    pi_seas,lon = shiftgrid(180.,pi_seas,lon,start=False)
   
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        if moses2 =='y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/'+plio_expt+'a@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/'+plio_expt+'a@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/'+plio_expt+'a@pdy[7-9]*'+m3+'.nc')
        else:
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/pdfiles/'+plio_expt+'a@pdt[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+plio_expt+'_netcdf/pdfiles/'+plio_expt+'a@pdt[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/x'+plio_expt+'_netcdf/pdfiles/'+plio_expt+'a@pdt[7-9]*'+m3+'.nc')
       
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/netcdf/pdfiles/'+plio_expt+'a@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/netcdf/pdfiles/'+plio_expt+'a@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/netcdf/pdfiles/'+plio_expt+'a@pdn[7-9]*'+m3+'.nc')
    a=fa.variables[field][:]
    b=fb.variables[field][:]
    c=fc.variables[field][:]
    lon = fa.variables['longitude'][:]
       

    a=np.squeeze(a)
    b=np.squeeze(b)
    c=np.squeeze(c)

    # average across the time dimension    
    plio_a_avg=np.mean(a,axis=0)
    plio_b_avg=np.mean(b,axis=0)
    plio_c_avg=np.mean(c,axis=0)
    
    plio_seas_temp=np.mean((plio_a_avg,plio_b_avg,plio_c_avg),axis=0)

    # we need a weighted average over the top 3 layers if frozen
    if field == 'field1386':
        plio_seas=(plio_seas_temp[0,:,:] * 0.1) + (plio_seas_temp[1,:,:] * 0.25) + (plio_seas_temp[2,:,:] * 0.65)
    else:
        plio_seas=plio_seas_temp

    plio_seas,lon = shiftgrid(180.,plio_seas,lon,start=False)
   
    retdata=[lon,lat,pi_seas,plio_seas]
    return retdata
    
#end def nh_data_get



def nh_all_seasons(HadCM3,preind_expt,plio_expt,extra,layers,moses2):

 # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()


#enddef nh_all_seasons
    # get data for a nice figure
    # field1386 is frozen fraction
    # field322_1 is land albedo after timestep
   
    # djf
    retdata=nh_data_get('dc','ja','fb','djf',HadCM3,moses2,'field1386',preind_expt,plio_expt)
    lon=retdata[0]
    lat=retdata[1]
    pi_froz_djf=retdata[2]
    plio_froz_djf=retdata[3]

    mask_ind='n'  # northern hemisphere
    plotmap_nh(plio_froz_djf-pi_froz_djf,plio_froz_djf/lsm,pi_froz_djf/lsm,0,lon,lat,'DJF',-0.2,0.225,0.025,0,'a','frozen fraction',mask_ind,10,12,0,0,5,2)

    
    retdata=nh_data_get('dc','ja','fb','djf',HadCM3,moses2,'field322',preind_expt,plio_expt)
    pi_seaice_alb_djf=retdata[2]
    plio_seaice_alb_djf=retdata[3]

    retdata=nh_data_get('dc','ja','fb','djf',HadCM3,moses2,'field322_1',preind_expt,plio_expt)
    pi_land_alb_djf=retdata[2]*10.
    plio_land_alb_djf=retdata[3]*10.
    # note we are multiplying the land albedo changes by 10 so that we can see 
    # it better on the figure

    plotmap_nh(plio_land_alb_djf-pi_land_alb_djf+plio_seaice_alb_djf-pi_seaice_alb_djf,plio_land_alb_djf,pi_land_alb_djf,0,lon,lat,'DJF',-0.5,0.525,0.025,0,'a','albedo change',mask_ind,10,12,0,6,5,2)

    
    

    #mam
    retdata=nh_data_get('mr','ar','my','mam',HadCM3,moses2,'field1386',preind_expt,plio_expt)
    pi_froz_mam=retdata[2]
    plio_froz_mam=retdata[3]

    plotmap_nh(plio_froz_mam-pi_froz_mam,plio_froz_mam/lsm,pi_froz_mam/lsm,1,lon,lat,'MAM',-0.2,0.225,0.025,0,'a','frac',mask_ind,10,12,2,0,5,2)

    retdata=nh_data_get('mr','ar','my','mam',HadCM3,moses2,'field322_1',preind_expt,plio_expt)
    pi_land_alb_mam=retdata[2]*10.
    plio_land_alb_mam=retdata[3]*10.

    retdata=nh_data_get('mr','ar','my','mam',HadCM3,moses2,'field322',preind_expt,plio_expt)
    pi_seaice_alb_mam=retdata[2]
    plio_seaice_alb_mam=retdata[3]

    plotmap_nh(plio_land_alb_mam-pi_land_alb_mam+plio_seaice_alb_mam-pi_seaice_alb_mam,plio_land_alb_mam,pi_land_alb_mam,1,lon,lat,'MAM',-0.5,0.525,0.025,0,'a','frac',mask_ind,10,12,2,6,5,2)

  
    #jja
    retdata=nh_data_get('jn','jl','ag','jja',HadCM3,moses2,'field1386',preind_expt,plio_expt)
    pi_froz_jja=retdata[2]
    plio_froz_jja=retdata[3]

    plotmap_nh(plio_froz_jja-pi_froz_jja,plio_froz_jja/lsm,pi_froz_jja/lsm,2,lon,lat,'JJA',-0.2,0.225,0.025,0,'a','frac',mask_ind,10,12,4,0,5,2)

    retdata=nh_data_get('jn','jl','ag','jja',HadCM3,moses2,'field322_1',preind_expt,plio_expt)
    pi_land_alb_jja=retdata[2]*10.
    plio_land_alb_jja=retdata[3]*10.

    retdata=nh_data_get('jn','jl','ag','jja',HadCM3,moses2,'field322',preind_expt,plio_expt)
    pi_seaice_alb_jja=retdata[2]
    plio_seaice_alb_jja=retdata[3]

    plotmap_nh(plio_land_alb_jja-pi_land_alb_jja+plio_seaice_alb_jja-pi_seaice_alb_jja,plio_land_alb_jja,pi_land_alb_jja,2,lon,lat,'JJA',-0.5,0.525,0.025,0,'a','frac',mask_ind,10,12,4,6,5,2)


    #son
    retdata=nh_data_get('sp','ot','nv','son',HadCM3,moses2,'field1386',preind_expt,plio_expt)
    pi_froz_son=retdata[2]
    plio_froz_son=retdata[3]

    plotmap_nh(plio_froz_son-pi_froz_son,plio_froz_son/lsm,pi_froz_son/lsm,3,lon,lat,'SON',-0.2,0.225,0.025,0,'a','frac',mask_ind,10,12,6,0,5,2)

    retdata=nh_data_get('sp','ot','nv','son',HadCM3,moses2,'field322_1',preind_expt,plio_expt)
    pi_land_alb_son=retdata[2]*10.
    plio_land_alb_son=retdata[3]*10.

    retdata=nh_data_get('sp','ot','nv','son',HadCM3,moses2,'field322',preind_expt,plio_expt)
    pi_seaice_alb_son=retdata[2]
    plio_seaice_alb_son=retdata[3]

    plotmap_nh(plio_land_alb_son-pi_land_alb_son+plio_seaice_alb_son-pi_seaice_alb_son,plio_land_alb_son,pi_land_alb_son,3,lon,lat,'SON',-0.5,0.525,0.025,0,'a','frac',mask_ind,10,12,6,6,5,2)

   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_smc/totsmc_anom_'+plio_expt+'_allseas.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()





  
#enddef nh_all_seasons

################################
# main program

# annual mean

HadCM3='n'
preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'
layers='n' #'n' - single layer (smc), 'y' - multi layer (smcl), u- unfrozen frac

#annmean('y',preind_expt,plio_expt,pliop2_expt,extra,layers,HadCM3)

#HadCM3='y'
#preind_expt='xiboi'
#plio_expt='xibol'
#pliop2_expt='xibol'
#extra='y'
#layers='n'


#annmean('y',preind_expt,plio_expt,pliop2_expt,extra,layers,HadCM3)

#####################################
# season mean

#HadCM3='n'
#preind_expt='xkvje'
#plio_expt='xkvjg'
#extra='n'
#layers='n' #'n' - single layer (smc), 'y' - multi layer (smcl), f- frozen frac

#HadCM3='y'
#preind_expt='xiboi'
#plio_expt='xibol'
#extra='y'
#layers='f'


#seasmean(['dc','ja','fb'],preind_expt,plio_expt,extra,layers,HadCM3,'djf')
#seasmean(['mr','ar','my'],preind_expt,plio_expt,extra,layers,HadCM3,'mam')
#seasmean(['jn','jl','ag'],preind_expt,plio_expt,extra,layers,HadCM3,'jja')
#seasmean(['sp','ot','nv'],preind_expt,plio_expt,extra,layers,HadCM3,'son')

##############################################
# put all seasons on one page.

#HadCM3='n'
#preind_expt='xkvje'
#plio_expt='xkvjg'
#extra='n'
#layers='n' #'n' - single layer (smc), 'y' - multi layer (smcl), f- frozen frac

HadCM3='y'
preind_expt='xiboi'
plio_expt='xibol'
extra='y'
layers='f'
moses2='y'

nh_all_seasons(HadCM3,preind_expt,plio_expt,extra,layers,moses2)



sys.exit(0)

####

::::::::::::::
plot_surfevap_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFEVAP
#PURPOSE
#    This program will plot the evapitation (annual and seasonal) and
#    the evapitation anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   
   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='h')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
   # this is good for the eurasia
   # map=Basemap(llcrnrlon=0.0,urcrnrlon=180.0,llcrnrlat=0.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend='both')
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,cmap='spectral',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-60,size=15)
        cbar.ax.tick_params(labelsize=15)
        plt.title(titlename,loc='left',fontsize=18)
  

#end def plotdata

def annmean(figureno,HadCM3,land_ocn_ind):

    print('j0')



    if land_ocn_ind == 'l' or land_ocn_ind == 'o':  # land or ocean
        # get land mask
        if HadCM3 == 'y' :
            fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
        else:
            fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
        lsmlon=fm.variables['longitude'][:]
        lsmlat=fm.variables['latitude'][:]
        lsm=fm.variables['lsm'][:]
        lsm=np.squeeze(lsm)
        fm.close()
    if land_ocn_ind == 'l':
        valmax=100.
        valmaxanom=12.
    else:
        valmax=250.
        valmaxanom=30.
        
    valdiff=valmax/10.
    valdiffanom=valmaxanom/6.

    #==============
    # preindustrial


    # read in data from multiple files
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        titlepi='PI-Ann_HadCM3'
        titleplio='Plio-Ann_HadCM3'
        titlediff='Plio - preind  Ann_HadCM3'
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        titlepi='PI-Ann_HadGEM2'
        titleplio='Plio-Ann_HadGEM2'
        titlediff='Plio - preind Ann_HadGEM2'


    aevap=np.squeeze(aevap)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_evap_ann=np.mean(aevap,axis=0)

    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_evap_ann=pi_evap_ann / (lsm)
            pi_evap_ann[pi_evap_ann == float('Inf')] = float('NaN')
            pi_evap_ann[pi_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_evap_ann=pi_evap_ann / (np.abs(lsm-1.0))
            pi_evap_ann[pi_evap_ann == float('Inf')] = float('NaN')
            pi_evap_ann[pi_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')




    print('new shape',np.shape(pi_evap_ann))
    
    pi_evap_ann=pi_evap_ann * 60. * 60. * 24. * 30.
    
    plt.figure(0)
    lonevap=lon
    pi_evap_ann,lon = shiftgrid(180.,pi_evap_ann,lon,start=False)
    
    plotdata(pi_evap_ann,0,lon,lat,titlepi,0,valmax,valdiff,0.0,'n','mm/month')
    f.close()
    
     #==============
     # Pliocene

    print('j1')


    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/pdfiles/xkvjfa@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)

    plio_evap_ann=np.mean(aevap,axis=0)
    plio_evap_ann=plio_evap_ann * 60. * 60. * 24. * 30.
    lon=lonevap

    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_evap_ann=plio_evap_ann / (lsm)
            plio_evap_ann[plio_evap_ann == float('Inf')] = float('NaN')
            plio_evap_ann[plio_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_evap_ann=plio_evap_ann / (np.abs(lsm-1.0))
            plio_evap_ann[plio_evap_ann == float('Inf')] = float('NaN')
            plio_evap_ann[plio_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')



    plio_evap_ann,lon = shiftgrid(180.,plio_evap_ann,lon,start=False)

    plotdata(plio_evap_ann,1,lon,lat,titleplio,0,valmax,valdiff,0.0,'n','mm/month')
    f.close

     #==============
     # Pliocene+2

    print('j2')

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
        ntimes,ny,nx=np.shape(aevap)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_evapp2_ann=np.mean(aevap,axis=0)
        plio_evapp2_ann=plio_evapp2_ann * 60. * 60. * 24. * 30.
        lon=lonevap
                

        if land_ocn_ind == 'l': # mask out all non land points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_evapp2_ann=plio_evapp2_ann / (lsm)
                plio_evapp2_ann[plio_evapp2_ann == float('Inf')] = float('NaN')
                plio_evapp2_ann[plio_evapp2_ann == float('-Inf')] = float('NaN')
                
            else:
                print('error lon/lat of land sea mask dont match')
                
        if land_ocn_ind == 'o': # mask out all non ocean points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_evapp2_ann=plio_evapp2_ann / (np.abs(lsm-1.0))
                plio_evapp2_ann[plio_evapp2_ann == float('Inf')] = float('NaN')
                plio_evapp2_ann[plio_evapp2_ann == float('-Inf')] = float('NaN')
 
            else:
                print('error lon/lat of land sea mask dont match')


        plio_evapp2_ann,lon = shiftgrid(180.,plio_evapp2_ann,lon,start=False)
        f.close()



    # Pliocene - preindustrial

    print('j3')

    plio_anom=plio_evap_ann-pi_evap_ann

    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    V=0
    print(valmaxanom,valdiffanom)
    plotdata(plio_anom,2,lon,lat,titlediff,-1.0*valmaxanom,valmaxanom,valdiffanom,V,'n','mm/month')
    
    # Pliocene+2 - preindustrial

    print('j4')

    if HadCM3 != 'y':
        pliop2_anom=plio_evapp2_ann-pi_evap_ann
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
        V=0

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Eanom_HG2',-1.0*valmaxanom,valmaxanom,valdiffanom,V,'n','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    if HadCM3 == 'y':
        plotdata(plio_anom,99,lon,lat,'b) HadCM3 evaporation anomaly',-1.0*valmaxanom,valmaxanom+valdiffanom,valdiffanom,0,'n','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadCM3.eps' 
    else:
        plotdata(pliop2_anom,99,lon,lat,'a) HadGEM2 evaporation anomaly',-1.0*valmaxanom,valmaxanom+valdiffanom,valdiffanom,0,'n','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadGEM2.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # Pliocene - preindustrial percentage change

    print('j5')

    print(pi_evap_ann)
    plio_peranom=((plio_evap_ann-pi_evap_ann)/pi_evap_ann)*100.
    plotdata(plio_peranom,0,lon,lat,titlediff,-70,78,5,0,'a','%')

    if HadCM3 != 'y':
        plio_peranomp2=((plio_evapp2_ann-pi_evap_ann)/pi_evap_ann)*100.
        plotdata(plio_peranomp2,99,lon,lat,'c) Plio - PI Eanom_HG2+2 %',-70,78,5,0,'a','%')
    

    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  



    plt.close()


    # big plot for paper
    print('j5a')

    if HadCM3 != 'y':
        V=0
        plotdata(plio_peranomp2,99,lon,lat,'c) HadGEM2: mPWP-PI Evap anomaly',-70.,75.,5.,V,'a','%')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadGEM2_pcent_single.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()

    else:

        V=0
        plotdata(plio_peranom,99,lon,lat,'d) HadCM3: mPWP-PI Evap anomaly',-70.,75.,5.,V,'a','%')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_HadCM3_pcent_single.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()



#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean


 # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   
 
 

    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        pititle='PI HadCM3: '+seasname
        pliotitle='Plio HadCM3: '+seasname
        difftitle='Plio-PI HadCM3: '+seasname
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        pititle='PI HadGEM2: '+seasname
        pliotitle='Plio HadGEM2: '+seasname
        difftitle='Plio-PI HadGEM2: '+seasname




    aevap=np.squeeze(aevap)
    bevap=np.squeeze(bevap)
    cevap=np.squeeze(cevap)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aevap_avg=np.mean(aevap,axis=0)
    pi_bevap_avg=np.mean(bevap,axis=0)
    pi_cevap_avg=np.mean(cevap,axis=0)
    
    pi_seasevap=np.mean((pi_aevap_avg,pi_bevap_avg,pi_cevap_avg),axis=0)
    pi_seasevap=pi_seasevap * 60. * 60. * 30. * 24.
    
    
    lonevap=lon
    pi_seasevap,lon = shiftgrid(180.,pi_seasevap,lon,start=False)
 
    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        pi_land=pi_seasevap/lsm
        pi_sea=pi_seasevap / (np.abs(lsm-1.0))                              
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=plio_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC)
        plt.show()
        sys.exit()

   
    plotdata(pi_land,0,lon,lat,pititle,0,20,1,0.0,'n','mm/month')
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/pdfiles/xkvjfa@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/pdfiles/xkvjfa@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/pdfiles/xkvjfa@pdn[7-9]*'+m3+'.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]

    aevap=np.squeeze(aevap)
    bevap=np.squeeze(bevap)
    cevap=np.squeeze(cevap)

    # average across the time dimension    
    plio_aevap_avg=np.mean(aevap,axis=0)
    plio_bevap_avg=np.mean(bevap,axis=0)
    plio_cevap_avg=np.mean(cevap,axis=0)
    
    plio_seasevap=np.mean((plio_aevap_avg,plio_bevap_avg,plio_cevap_avg),axis=0)
    plio_seasevap=plio_seasevap * 60. * 60. * 30. * 24.

    lon=lonevap
    plio_seasevap,lon = shiftgrid(180.,plio_seasevap,lon,start=False)
    
    plio_land=plio_seasevap/lsm
    plio_sea=plio_seasevap / (np.abs(lsm-1.0))                              
    
    plotdata(plio_land,1,lon,lat,pliotitle,0,20,1,0.0,'n','mm/month')



     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m3+'.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        aevap=np.squeeze(aevap)
        bevap=np.squeeze(bevap)
        cevap=np.squeeze(cevap)
        
        pliop2_aevap_avg=np.mean(aevap,axis=0)
        pliop2_bevap_avg=np.mean(bevap,axis=0)
        pliop2_cevap_avg=np.mean(cevap,axis=0)
        
        pliop2_seasevap=np.mean((pliop2_aevap_avg,pliop2_bevap_avg,pliop2_cevap_avg),axis=0)
        pliop2_seasevap=pliop2_seasevap * 60. * 60. * 30. * 24.
        
        lon=lonevap
        pliop2_seasevap,lon = shiftgrid(180.,pliop2_seasevap,lon,start=False)
    
 

    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=pliop2_seasevap-pi_seasevap
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata((pliop2_anom/pi_seasevap)*100.,2,lon,lat,'PlioP2 - PI Eanom_HG2',-100,100,1,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_'+seasname+'anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
        plotdata(pliop2_anom,99,lon,lat,'PlioP2 - PI Eanom_HG2',-20,22,2,0,'a','mm/month')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_'+seasname+'anom_mm.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
      

    else:
        pliop_anom=pliop_seasevap-pi_seasevap
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop_anom,3,lon,lat,'Plio - PI Eanom_HG2',-10,10,1,0,'a','mm/month')
        plotdata((pliop_anom/pi_seasevap)*100.,2,lon,lat,'Plio - PI Eanom_HG2',-100,100,1,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_'+seasname+'anom_HadCM3.eps' 
        plt.savefig(fileout,bbox_inches='tight')
        plt.close()

       
  
    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasevap-pi_seasevap)/pi_seasevap)*100.
    plotdata(plio_peranom,0,lon,lat,difftitle,-50,50,5,0,'a','%')


    if HadCM3 !='y':
        plio_peranomp2=((pliop2_seasevap-pi_seasevap)/pi_seasevap)*100.
        titlename='Plio+2-PI evap %'+seasname
        plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%')

    if HadCM3 =='y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_'+seasname+'HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_'+seasname+'HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_anom_percent_'+seasname+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    plt.close()




#end def seasmean


def evap_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent):


    if land_ocn_ind == 'l' or land_ocn_ind == 'o':  # land or ocean
        # get land mask
        if HadCM3 == 'y' :
            fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
        else:
            fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
        lsmlon=fm.variables['longitude'][:]
        lsmlat=fm.variables['latitude'][:]
        lsm=fm.variables['lsm'][:]
        lsm=np.squeeze(lsm)
        fm.close()

    #==============
    # preindustrial

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
    else:
    # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/xkvjea@pdn[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
    
    f.close()
    aevap=np.squeeze(aevap)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)

#average across the time dimension and the latitude dimension
    pi_evap_ann=np.mean(aevap,axis=0)
    pi_evap_ann_orig=pi_evap_ann

    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_evap_ann=pi_evap_ann / (lsm)
            pi_evap_ann[pi_evap_ann == float('Inf')] = float('NaN')
            pi_evap_ann[pi_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_evap_ann=pi_evap_ann / (np.abs(lsm-1.0))
            pi_evap_ann[pi_evap_ann == float('Inf')] = float('NaN')
            pi_evap_ann[pi_evap_ann == float('-Inf')] = float('NaN')
 
        else:
            print('error lon/lat of land sea mask dont match')

    pi_evap_lat_ann=np.nanmean(pi_evap_ann,axis=1)
  
    
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]

    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/xkvjfa@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]

    f.close()
    aevap=np.squeeze(aevap)
    ntimes,ny,nx=np.shape(aevap)

    plio_evap_ann=np.mean(aevap,axis=0)
    plio_evap_ann_orig=plio_evap_ann


    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_evap_ann=plio_evap_ann / (lsm)
            plio_evap_ann[plio_evap_ann == float('Inf')] = float('NaN')
            plio_evap_ann[plio_evap_ann == float('-Inf')] = float('NaN')

        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_evap_ann=plio_evap_ann / (np.abs(lsm-1.0))
            plio_evap_ann[plio_evap_ann == float('Inf')] = float('NaN')
            plio_evap_ann[plio_evap_ann == float('-Inf')] = float('NaN')

        else:
            print('error lon/lat of land sea mask dont match')




    # find average
    weightarr=np.zeros(np.shape(plio_evap_ann))
    for i in range (0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lsmlat))

    

    if land_ocn_ind == 'l':
        weightarr=weightarr * lsm
    if land_ocn_ind == 'o':
        weightarr=weightarr * np.abs(lsm-1.0)

    # set values over poles to be 0
    weightarr[0,:]=0.0
    weightarr[len(lat)-1,:]=0.0
    pi_evap_ann[len(lat)-1,:]=0.0
    plio_evap_ann[len(lat)-1,:]=0.0

    

    print('HadCM3 is',HadCM3,'land ocean ind is ',land_ocn_ind,'mean Plioanom ',np.average(plio_evap_ann_orig - pi_evap_ann_orig,weights=weightarr)*60.*60.*24)


    plio_evap_lat_ann=np.nanmean(plio_evap_ann,axis=1)


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/xkvjga@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
        ntimes,ny,nx=np.shape(aevap)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_evapp2_ann=np.mean(aevap,axis=0)
        plio_evapp2_ann_orig=plio_evapp2_ann
        if land_ocn_ind == 'l': # mask out all non land points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_evapp2_ann=plio_evapp2_ann / (lsm)
                plio_evapp2_ann[plio_evapp2_ann == float('Inf')] = float('NaN')
            
            else:
                print('error lon/lat of land sea mask dont match')

        if land_ocn_ind == 'o': # mask out all non ocean points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_evapp2_ann=plio_evapp2_ann / (np.abs(lsm-1.0))
                plio_evapp2_ann[plio_evapp2_ann == float('Inf')] = float('NaN')

            else:
                print('error lon/lat of land sea mask dont match')


        # find average using weighting array found earlier
        print('HadCM3 is',HadCM3,'land ocean ind is ',land_ocn_ind,'mean Plioanomp2 ',np.average(plio_evapp2_ann_orig-pi_evap_ann_orig,weights=weightarr)*60.*60.*24)

        plio_evapp2_lat_ann=np.nanmean(plio_evapp2_ann,axis=1)
        f.close()


    # Pliocene - preindustrial

    if abs_pcent == 'a':
        plio_anom=(plio_evap_lat_ann-pi_evap_lat_ann)* 60. *  60. *24.

    if abs_pcent == 'p':
        plio_anom=(plio_evap_lat_ann-pi_evap_lat_ann)/ pi_evap_lat_ann
        plio_anom=plio_anom * 100.

    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        if abs_pcent == 'a':
          pliop2_anom=(plio_evapp2_lat_ann-pi_evap_lat_ann)* 60.*  60. *24.
         
        if abs_pcent == 'p':
          pliop2_anom=(plio_evapp2_lat_ann-pi_evap_lat_ann)/ pi_evap_lat_ann
          pliop2_anom=pliop2_anom * 100.



    if HadCM3 == 'y':
        allanom=[lat,plio_anom]
        return allanom
    else:
        allanom=[lat,plio_anom,pliop2_anom]
        return allanom
    
    



#end def evap_chg_by_latitude



################################
# main program

# annual mean
figureno=0

HadCM3='n'
land_ocn_ind='b'
#plt.figure(figureno)
annmean(figureno,HadCM3,land_ocn_ind)
#HadCM3='n'
#annmean(figureno,HadCM3,land_ocn_ind)
#figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',HadCM3)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3)
#figureno=figureno+1

#seasmean('mr','ar','my',figureno,'mam',HadCM3)
#seasmean('sp','ot','nv',figureno,'son',HadCM3)

# to see what the polar amplification is
#HadCM3='y'
#land_ocn_ind='o'    # valid values are l - land , o- ocean b=both
#abs_pcent='a'       # valid values are p - percentage chg, a=absolute change
#evap_ret=evap_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent)
#lats_HadCM3=evap_ret[0]
#evap_anom_HadCM3=evap_ret[1]
#plt.plot(evap_anom_HadCM3,lats_HadCM3)

#HadCM3='n'
#evap_ret=evap_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent)
#lats_HadGEM=evap_ret[0]
#evap_anom_HadGEM=evap_ret[1]
#evap_anom_HadGEMp2=evap_ret[2]

#mp.rcParams.update({'font.size':15})
#plt.plot(evap_anom_HadGEMp2,lats_HadGEM,'g',label='HadGEM2')
#plt.plot(evap_anom_HadCM3,lats_HadCM3,'r',label='HadCM3')
#plt.plot(evap_anom_HadGEM,lats_HadGEM,'b')

#if abs_pcent == 'a':
#    plt.xlabel('mm/day',fontsize=20)
#if abs_pcent == 'p':
#    plt.xlabel('%',fontsize=20)
#plt.ylabel('latitude',fontsize=20)

#if land_ocn_ind =='l':
#    plt.title('f) mPWP - preind land evap anom',loc='left',fontsize=25)
#if land_ocn_ind =='o':
#    plt.title('g) mPWP - preind ocean evap anom',loc='left',fontsize=25)
#if land_ocn_ind =='b':
#    plt.title('e) mPWP - preind evap anom',loc='left',fontsize=25)
#axes=plt.gca()
#if abs_pcent == 'p':
#    axes.set_xlim(xmin=-20.0,xmax=100.0)
#axes.set_ylim([-80,80])
#legend=plt.legend(loc='center right')
#if land_ocn_ind =='l':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_polar_amp_land.eps' 
#    if abs_pcent =='p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_polar_amp_land_pcent.eps' 
#if land_ocn_ind =='o':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_polar_amp_ocean.eps' 
#    if abs_pcent =='p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfeva#p/evap_polar_amp_ocean_pcent.eps' 

#if land_ocn_ind =='b':
#    if abs_pcent == 'a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_polar_amp.eps' 
#    if abs_pcent == 'p':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfevap/evap_polar_amp_pcent.eps' 
#plt.savefig(fileout, bbox_inches='tight')  



sys.exit(0)

####

::::::::::::::
plot_surfpmine_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFPMINE
#PURPOSE
#    This program will plot the p-e (annual and seasonal) and
#    the p-e anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
#    also by latitude
#
#
# search for 'main program' to find end of functions
# Julia 4/7/2017  (note annmean and seasmean not done, 
#  just done change with latitude



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='h')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata


###########################################################
def plotmap_nh_precipevap(plotprecip,plotevap,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind,ygrid,xgrid,yuse,xuse,yspan,xspan):

    # setup

    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    lons, lats = np.meshgrid(lon,lat)
   
    if mask_ind =='n': # tropics mask
        northlat=90.0
        southlat=30.0
    elif mask_ind == 'nalt': # alternative tropical region:
        northlat=90.0
        southlat=0.0
    else:
        northlat=90.0
        southlat=-90.0

    if V == 0:
        V=np.arange(minval,maxval,valinc)


    # plot precip
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotprecip,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotprecip,V,cmap='RdBu',extend='both')
   
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,False,False,False]) # labels right
    meridians=np.arange(-180.,180.,90.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 
    plt.text(-180.0-6,northlat-fontsize-1-15,'(precip)',fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

    # plot map boundary
    map.drawmapboundary


    # plot evap
    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse+yspan+1),colspan=yspan,rowspan=xspan)

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()
        
    if uselog == 'n':
        cs = map.contourf(x,y,plotevap,V,cmap='YlGnBu',extend='both')
    else:
        cs = map.contourf(x,y,plotevap,V,cmap='RdBu',extend='both')
   
    parallels=(30,45,60,75)
    map.drawparallels(parallels,labels=[False,False,False,False]) # no labels
    meridians=np.arange(-180.,180.,90.)
    if fileno !=3:
        map.drawmeridians(meridians,labels=[False,False,False,False]) # nolabels
    else:
        map.drawmeridians(meridians,labels=[False,False,False,True]) # labels bottom
   
    fontsize=10
    plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

    plt.text(-180.0-6,northlat-fontsize-1-15,'(evap)',fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))

  
  # plot map boundary
    map.drawmapboundary


    # colorbar
    if fileno==0:
        plt.subplot2grid((10,11),(9,0),colspan=11,rowspan=1)
        plt.gca().set_visible(False)
        cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0)         
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=10)
   
    
  

    
    
   


#end def plotmap_nh_precipevap


def annmean(figureno,HadCM3):
    #==============
    # preindustrial


    # read in data from multiple files
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip'][:]
        titlepi='PI-Ann_HadCM3'
        titleplio='Plio-Ann_HadCM3'
        titlediff='Plio - preind  Ann_HadCM3'
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/xkvjea@pdn[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip_1'][:]
        titlepi='PI-Ann_HadGEM2'
        titleplio='Plio-Ann_HadGEM2'
        titlediff='Plio - preind Ann_HadGEM2'


    aevap=np.squeeze(aevap)    
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)
    f.close()
    print('read in preindustrial')
  
    apme=aprecip-aevap
#average across the time dimension
    pi_pme_ann=np.mean(apme,axis=0)
    print('new shape',np.shape(pi_pme_ann))
    
    pi_pme_ann=pi_pme_ann * 60. * 60. * 24. * 30.
    
    plt.figure(0)
    lonevap=lon
    pi_pme_ann,lon = shiftgrid(180.,pi_pme_ann,lon,start=False)
    
    plotdata(pi_pme_ann,0,lon,lat,titlepi,0,275,25.0,0.0,'n','mm/month')
    print('first plot done')


     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
        aprecip=f.variables['precip'][:]
        aprecip=np.squeeze(aprecip)
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/xkvjfa@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)

    apme=aprecip-aevap
    plio_pme_ann=np.mean(apme,axis=0)
    plio_pme_ann=plio_pme_ann * 60. * 60. * 24. * 30.

    lon=lonevap
    plio_pme_ann,lon = shiftgrid(180.,plio_pme_ann,lon,start=False)

    plotdata(plio_pme_ann,1,lon,lat,titleplio,0,275,25,0.0,'n','mm/month')
    f.close()
    print('read in plio')


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/xkvjga@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aevap=np.squeeze(aevap)
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aevap)
        print(ntimes,ny,nx)
        print(np.shape(aprecip))
        print(np.shape(aevap))
        
    #average across the time dimension
        apme=aprecip-aevap
        plio_pmep2_ann=np.mean(apme,axis=0)
        plio_pmep2_ann=plio_pmep2_ann * 60. * 60. * 24. * 30.
        lon=lonevap
        plio_pmep2_ann,lon = shiftgrid(180.,plio_pmep2_ann,lon,start=False)


    f.close()
    print('read in plio+2')


    # Pliocene - preindustrial

    plio_anom=plio_pme_ann-pi_pme_ann

    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,titlediff,0,275,25,V,'n','mm/month')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_pmep2_ann-pi_pme_ann
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'n','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



    # Pliocene - preindustrial percentage change for paper

    #print(pi_pme_ann)
    #plio_peranom=((plio_pme_ann-pi_pme_ann)/pi_pme_ann)*100.
    #plotdata(plio_peranom,0,lon,lat,titlediff,-50,60,5,0,'a','%')

    # quickly check that globally averaged p-e is 0
    # create weighting array
    weightarr=np.zeros(np.shape(plio_pmep2_ann))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('mean plio pme',np.average(plio_pmep2_ann,weights=weightarr))
    print('mean pi pme',np.average(pi_pme_ann,weights=weightarr))
    print('mean plio-pi pme',np.average(plio_pmep2_ann-pi_pme_ann,weights=weightarr))


    if HadCM3 != 'y':
        # without mask
        plio_peranomp2=((plio_pmep2_ann-pi_pme_ann)/pi_pme_ann)*100.
        plotdata(plio_peranomp2,99,lon,lat,'Plio - PI Panom_HG2+2 %',-75,78,5,0,'a','%')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()

        # with mask for if pi -pme is close to zero
        plio_peranomp2_mask=plio_peranomp2

        for i in range(0,len(lon)):
            for j in range(0,len(lat)):
                if pi_pme_ann[j,i] < 2 and plio_pmep2_ann[j,i]<2:
                    plio_peranomp2_mask[j,i]=0.

        
        plotdata(plio_peranomp2_mask,99,lon,lat,'Plio - PI Panom_HG2+2 %',-75,78,5,0,'a','%')
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_mask.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_mask.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  



        plt.close()

        # in mm/month

        plio_anomp2=(plio_pmep2_ann-pi_pme_ann)
        
        plotdata(plio_anomp2,99,lon,lat,'Plio - PI Panom_HG2+2',-20,25,5,0,'a','mm/month')
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom2.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom2.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  



        plt.close()



#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        pititle='PI HadCM3: '+seasname
        pliotitle='Plio HadCM3: '+seasname
        difftitle='Plio-PI HadCM3: '+seasname
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/netcdf/xkvjaa@pdm[7-9]*'+m1+'_evap.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/netcdf/xkvjaa@pdm[7-9]*'+m2+'_evap.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/netcdf/xkvjaa@pdm[7-9]*'+m3+'_evap.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        pititle='PI HadGEM2: '+seasname
        pliotitle='Plio HadGEM2: '+seasname
        difftitle='Plio-PI HadGEM2: '+seasname




    aevap=np.squeeze(aevap)
    bevap=np.squeeze(bevap)
    cevap=np.squeeze(cevap)
    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aevap_avg=np.mean(aevap,axis=0)
    pi_bevap_avg=np.mean(bevap,axis=0)
    pi_cevap_avg=np.mean(cevap,axis=0)
    
    pi_seasevap=np.mean((pi_aevap_avg,pi_bevap_avg,pi_cevap_avg),axis=0)
    pi_seasevap=pi_seasevap * 60. * 60. * 30. * 24.
    
    
    lonevap=lon
    pi_seasevap,lon = shiftgrid(180.,pi_seasevap,lon,start=False)
    
    plotdata(pi_seasevap,0,lon,lat,pititle,0,275,25,0.0,'n','mm/month')
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/netcdf/xkvjba@pdm[7-9]*'+m1+'_evap.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/netcdf/xkvjba@pdm[7-9]*'+m2+'_evap.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/netcdf/xkvjba@pdm[7-9]*'+m3+'_evap.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]

    aevap=np.squeeze(aevap)
    bevap=np.squeeze(bevap)
    cevap=np.squeeze(cevap)

    # average across the time dimension    
    plio_aevap_avg=np.mean(aevap,axis=0)
    plio_bevap_avg=np.mean(bevap,axis=0)
    plio_cevap_avg=np.mean(cevap,axis=0)
    
    plio_seasevap=np.mean((plio_aevap_avg,plio_bevap_avg,plio_cevap_avg),axis=0)
    plio_seasevap=plio_seasevap * 60. * 60. * 30. * 24.

    lon=lonevap
    plio_seasevap,lon = shiftgrid(180.,plio_seasevap,lon,start=False)
    
    
    plotdata(plio_seasevap,1,lon,lat,pliotitle,0,275,25,0.0,'n','mm/month')



     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/netcdf/xkvjca@pdm[7-9]*'+m1+'_evap.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/netcdf/xkvjca@pdm[7-9]*'+m2+'_evap.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/netcdf/xkvjca@pdm[7-9]*'+m3+'_evap.nc')
        aevap=fa.variables['field184'][:]
        bevap=fb.variables['field184'][:]
        cevap=fc.variables['field184'][:]
        aevap=np.squeeze(aevap)
        bevap=np.squeeze(bevap)
        cevap=np.squeeze(cevap)
        
        pliop2_aevap_avg=np.mean(aevap,axis=0)
        pliop2_bevap_avg=np.mean(bevap,axis=0)
        pliop2_cevap_avg=np.mean(cevap,axis=0)
        
        pliop2_seasevap=np.mean((pliop2_aevap_avg,pliop2_bevap_avg,pliop2_cevap_avg),axis=0)
        pliop2_seasevap=pliop2_seasevap * 60. * 60. * 30. * 24.
        
        lon=lonevap
        pliop2_seasevap,lon = shiftgrid(180.,pliop2_seasevap,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seasevap-pi_seasevap
    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,difftitle,0,275,25,V,'la','mm/month')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=pliop2_seasevap-pi_seasevap
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_'+seasname+'anom_HadCM3.eps' 
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_'+seasname+'anom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasevap-pi_seasevap)/pi_seasevap)*100.
    plotdata(plio_peranom,0,lon,lat,difftitle,-50,50,5,0,'a','%')


    if HadCM3 !='y':
        plio_peranomp2=((pliop2_seasevap-pi_seasevap)/pi_seasevap)*100.
        titlename='Plio+2-PI evap %'+seasname
        plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%')

    if HadCM3 =='y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_'+seasname+'HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_'+seasname+'HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_anom_percent_'+seasname+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    plt.close()




#end def seasmean


def seasmean_get(m1,m2,m3,figureno,seasname,HadCM3,moses2,field):
    # this program is a bit like seasmean but it will just get the data
    # it won't analyse it or print anything out or plot anything

    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        if moses2 == 'y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
       
        else: # fergus simulation xgrad
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrad_netcdf/pdfiles/xgrada@pdq[7-9]*'+m3+'.nc')
      
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/pdfiles/xkvjea@pdn[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        if field=='precip':
            field='precip_1'
    aprecip=fa.variables[field][:]
    bprecip=fb.variables[field][:]
    cprecip=fc.variables[field][:]




    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 24. # mm/day
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
   
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        if moses2 =='y':
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        else:
            fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m1+'.nc')
            fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m2+'.nc')
            fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xgrac_netcdf/pdfiles/xgraca@pdt[7-9]*'+m3+'.nc')
       
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/pdfiles/xkvjga@pdn[7-9]*'+m3+'.nc')
    aprecip=fa.variables[field][:]
    bprecip=fb.variables[field][:]
    cprecip=fc.variables[field][:]
    lon = fa.variables['longitude'][:]
       

    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60.  * 24.
   
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
   
    retdata=[lon,lat,pi_seasprecip,plio_seasprecip]
    return retdata
    
#end def seasmean_get

#####################################
def nh_allseasons_precipevap(HadMC3,moses2):
# plot precip and evap amount for all seasons
    if HadCM3=='n':
        plio_expt='xkvjg'
        precip_field='precip_1'
    else:
        plio_expt='HadCM3'+moses2
        precip_field='precip'

    # getdata for all seasons in nh we are going to put it on a nice figure
    retdata=seasmean_get('dc','ja','fb',figureno,'djf',HadCM3,moses2,precip_field)
    lon=retdata[0]
    lat=retdata[1]
    pi_djf_precip=retdata[2]
    plio_djf_precip=retdata[3]
    retdata=seasmean_get('dc','ja','fb',figureno,'djf',HadCM3,moses2,'field184')
    pi_djf_evap=retdata[2]
    plio_djf_evap=retdata[3]
    

    mask_ind='n' # northernhemisphere
    plotmap_nh_precipevap(plio_djf_precip-pi_djf_precip,plio_djf_evap-pi_djf_evap,0,lon,lat,'DJF',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,0,0,5,2)
   
    retdata=seasmean_get('mr','ar','my',figureno,'mam',HadCM3,moses2,precip_field)
    pi_mam_precip=retdata[2]
    plio_mam_precip=retdata[3]
    retdata=seasmean_get('mr','ar','my',figureno,'mam',HadCM3,moses2,'field184')
    pi_mam_evap=retdata[2]
    plio_mam_evap=retdata[3]
    plotmap_nh_precipevap(plio_mam_precip-pi_mam_precip,plio_mam_evap-pi_mam_evap,1,lon,lat,'MAM',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,2,0,5,2)
      
 
    retdata=seasmean_get('jn','jl','ag',figureno,'jja',HadCM3,moses2,precip_field)
    pi_jja_precip=retdata[2]
    plio_jja_precip=retdata[3] 
    retdata=seasmean_get('jn','jl','ag',figureno,'jja',HadCM3,moses2,'field184')
    pi_jja_evap=retdata[2]
    plio_jja_evap=retdata[3]
    plotmap_nh_precipevap(plio_jja_precip-pi_jja_precip,plio_jja_evap-pi_jja_evap,2,lon,lat,'JJA',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,4,0,5,2)
       

    retdata=seasmean_get('sp','ot','nv',figureno,'son',HadCM3,moses2,precip_field)
    pi_son_precip=retdata[2]
    plio_son_precip=retdata[3]
    retdata=seasmean_get('sp','ot','nv',figureno,'son',HadCM3,moses2,'field184')
    pi_son_evap=retdata[2]
    plio_son_evap=retdata[3]
    plotmap_nh_precipevap(plio_son_precip-pi_son_precip,plio_son_evap-pi_son_evap,3,lon,lat,'SON',-1.0,1.1,0.1,0,'a','mm/day',mask_ind,10,11,6,0,5,2)
   
  
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/NH_precipevap_'+plio_expt+'_allseasons.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/NH_precipevap'+plio_expt+'_allseasons.tiff' 
    plt.savefig(fileout, bbox_inches='tight')  



#enddef nh_allseasons_precipevap



def pmine_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent):


    if land_ocn_ind == 'l' or land_ocn_ind == 'o':  # land or ocean
        # get land mask
        if HadCM3 == 'y' :
            fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
        else:
            fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
        lsmlon=fm.variables['longitude'][:]
        lsmlat=fm.variables['latitude'][:]
        lsm=fm.variables['lsm'][:]
        lsm=np.squeeze(lsm)
        fm.close()

    #==============
    # preindustrial

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip'][:]
    else:
    # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/netcdf/xkvjea@pdn[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip_1'][:]
    
    f.close()
    aevap=np.squeeze(aevap) 
    aprecip=np.squeeze(aprecip)
    pmine=aprecip-aevap

    ntimes,ny,nx=np.shape(aevap)
    print(ntimes,ny,nx)

#average across the time dimension and the latitude dimension
    pi_pmine_ann=np.mean(pmine,axis=0)

    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_pmine_ann=pi_pmine_ann / (lsm)
            pi_pmine_ann[pi_pmine_ann == float('Inf')] = float('NaN')
            pi_pmine_ann[pi_pmine_ann == float('-Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            pi_pmine_ann=pi_pmine_ann / (np.abs(lsm-1.0))
            pi_pmine_ann[pi_pmine_ann == float('Inf')] = float('NaN')
            pi_pmine_ann[pi_pmine_ann == float('-Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

  
    

    pi_pmine_lat_ann=np.nanmean(pi_pmine_ann,axis=1)
    print('new shape pi',np.shape(pi_pmine_lat_ann))
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip'][:]
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/netcdf/xkvjfa@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip_1'][:]

    f.close()
    aevap=np.squeeze(aevap)
    aprecip=np.squeeze(aprecip)
    pmine=aprecip-aevap

    ntimes,ny,nx=np.shape(aevap)

    plio_pmine_ann=np.mean(pmine,axis=0)


    if land_ocn_ind == 'l': # mask out all non land points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_pmine_ann=plio_pmine_ann / (lsm)
            plio_pmine_ann[plio_pmine_ann == float('Inf')] = float('NaN')
            plio_pmine_ann[plio_pmine_ann == float('-Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')

    if land_ocn_ind == 'o': # mask out all non ocean points.
        if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
            plio_pmine_ann=plio_pmine_ann / (np.abs(lsm-1.0))
            plio_pmine_ann[plio_pmine_ann == float('Inf')] = float('NaN')
            plio_pmine_ann[plio_pmine_ann == float('-Inf')] = float('NaN')
        else:
            print('error lon/lat of land sea mask dont match')


    plio_pmine_lat_ann=np.nanmean(plio_pmine_ann,axis=1)


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/netcdf/xkvjga@pdn[5-9]*.nc')
        aevap=f.variables['field184'][:]
        aprecip=f.variables['precip_1'][:]
        aevap=np.squeeze(aevap)
        aprecip=np.squeeze(aprecip)
        pmine=aprecip-aevap

        ntimes,ny,nx=np.shape(aevap)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_evapp2_ann=np.mean(pmine,axis=0)
        if land_ocn_ind == 'l': # mask out all non land points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_pmep2_ann=plio_pmep2_ann / (lsm)
                plio_pmep2_ann[plio_pmep2_ann == float('Inf')] = float('NaN')
                plio_pmep2_ann[plio_pmep2_ann == float('-Inf')] = float('NaN')
            
            else:
                print('error lon/lat of land sea mask dont match')

        if land_ocn_ind == 'o': # mask out all non ocean points.
            if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
                plio_pmep2_ann=plio_pmep2_ann / (np.abs(lsm-1.0))
                plio_pmep2_ann[plio_pmep2_ann == float('Inf')] = float('NaN')
                plio_pmep2_ann[plio_pmep2_ann == float('-Inf')] = float('NaN')

            else:
                print('error lon/lat of land sea mask dont match')


        plio_pmep2_lat_ann=np.nanmean(plio_pmep2_ann,axis=1)
        f.close()


    # Pliocene - preindustrial

    if abs_pcent == 'a':
        plio_anom=(plio_pmine_lat_ann-pi_pmine_lat_ann)* 60. *  60. *24.
    if abs_pcent == 'p':
        plio_anom=(plio_pmine_lat_ann-pi_pmine_lat_ann)/ pi_pmine_lat_ann
        plio_anom=plio_anom * 100.

    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        if abs_pcent == 'a':
          pliop2_anom=(plio_pmep2_lat_ann-pi_pmine_lat_ann)* 60.*  60. *24.
        if abs_pcent == 'p':
          pliop2_anom=(plio_pmep2_lat_ann-pi_pmine_lat_ann)/ pi_pmine_lat_ann
          pliop2_anom=pliop2_anom * 100.



    if HadCM3 == 'y':
        allanom=[lat,plio_anom]
        return allanom
    else:
        allanom=[lat,plio_anom,pliop2_anom]
        return allanom
    
    



#end def evap_chg_by_latitude



################################
# main program

# annual mean
figureno=0

HadCM3='y'
moses2='y'
#plt.figure(figureno)
#annmean(figureno,HadCM3)
#figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',HadCM3)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3)
#figureno=figureno+1

############################################################
# just plot poleward of 30N for all seasons
# we would like precipitation and evaporation on the same plot
# ie all seasons on one page
#nh_allseasons(HadCM3,moses2) # get precipitation
nh_allseasons_precipevap(HadCM3,moses2) # get precipevap

##########################################################
# to see what the polar amplification is
#HadCM3='y'
#land_ocn_ind='l'    # valid values are l - land , o- ocean b=both
#abs_pcent='a'       # valid values are p - percentage chg, a=absolute change
                    # note percent change is not meaningful in p-e because 
                     # p-e can be negative for the preindustrial
#evap_ret=pmine_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent)
#lats_HadCM3=evap_ret[0]
#pmine_anom_HadCM3=evap_ret[1]
#plt.plot(pmine_anom_HadCM3,lats_HadCM3)

#HadCM3='n'
#evap_ret=pmine_chg_by_latitude(HadCM3,land_ocn_ind,abs_pcent)
#lats_HadGEM=evap_ret[0]
#pmine_anom_HadGEM=evap_ret[1]
#pmine_anom_HadGEMp2=evap_ret[2]


#mp.rcParams.update({'font.size':15})
#plt.plot(pmine_anom_HadGEMp2,lats_HadGEM,'g',label='HadGEM2')
#plt.plot(pmine_anom_HadCM3,lats_HadCM3,'r',label='HadCM3')
#plt.plot(pmine_anom_HadGEM,lats_HadGEM,'b')

#if abs_pcent == 'a':
#    plt.xlabel('mm/day',fontsize=20)
#if abs_pcent == 'p': 
#    plt.xlabel('%',fontsize=20)
#plt.ylabel('latitude',fontsize=20)

#if land_ocn_ind =='l':
#    plt.title('f) mPWP - preind land p-e anom',loc='left',fontsize=25)
#if land_ocn_ind =='o':
#    plt.title('g) mPWP - preind ocean p-e anom',loc='left',fontsize=25)
#if land_ocn_ind =='b':
#    plt.title('e) mPWP - preind p-e anom',loc='left',fontsize=25)
#axes=plt.gca()
#if abs_pcent == 'p':
#    axes.set_xlim(xmin=-60.0,xmax=100.0)
#axes.set_ylim([-80,80])
#legend=plt.legend()
#if land_ocn_ind =='l':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_polar_amp_land.eps' 
#if land_ocn_ind =='o':
#    if abs_pcent =='a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmine/P-E_polar_amp_ocean.eps' 


#if land_ocn_ind =='b':
#    if abs_pcent == 'a':
#        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfpmi#ne/P-E_polar_amp.eps' 
#plt.savefig(fileout, bbox_inches='tight')  

#if abs_pcent =='p':
#    plt.show()



sys.exit(0)

####

::::::::::::::
plot_surftemp_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFTEMP
#PURPOSE
#    This program will plot the temperature (annual and seasonal) and
#    the temperature anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,oplot_pi,pi_temp,plio_temp):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
   # this is good for the Europe
    #map=Basemap(llcrnrlon=0.0,urcrnrlon=180.0,llcrnrlat=0.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                #cmap='afmhot_r'
                cmap='Reds'
                cs = map.contourf(x,y,plotdata,V,cmap=cmap,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
                if oplot_pi == 'y':
                    map.contour(x,y,pi_temp,[0],colors='lime',linestyles=[':'],linewidth=10) 
                    map.contour(x,y,plio_temp,[0],colors='aqua',linestyles=['--'],linewidth=10)
  

    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-60,size=15)
        cbar.ax.tick_params(labelsize=15)
        plt.title(titlename,loc='left',fontsize=18)
  
#end def plotdata

def annmean(switch,HadCM3):
    # switch is a dummy variable to allow the program to be called
    #==============
    # preindustrial


    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]
        titlePI='PI-TAnn_HadCM3'
        titlediff='Plio - PI Tanom_HadCM3'
    else:
    # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/temp_data/xkvjea@pdn[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp_1'][:]
        titlePI='PI-TAnn_HadGEM2'
        titlediff='Plio - PI Tanom_HadGEM2'

    

    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_temp_ann=np.mean(atemp,axis=0)
    print('new shape',np.shape(pi_temp_ann))
    
    
    plt.figure(0)
    degC=u'\N{DEGREE SIGN}'+'C'
    lontemp=lon
    pi_temp_ann,lon = shiftgrid(180.,pi_temp_ann,lon,start=False)
    
    plotdata(pi_temp_ann-273.15,0,lon,lat,titlePI,-50,50,5.0,0.0,'n',degC,'n',0,0)


     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]
        titlePlio='Plio-TAnn_HadCM3'

    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/temp_data/xkvjfa@pdn[7-9]*.nc')
        atemp=f.variables['temp_1'][:]
        titlePlio='Plio-TAnn_HadGEM2'


    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)

    plio_temp_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_temp_ann))

    lon=lontemp
    plio_temp_ann,lon = shiftgrid(180.,plio_temp_ann,lon,start=False)

    plotdata(plio_temp_ann-273.15,1,lon,lat,titlePlio,-50,50,5.0,0.0,'n',degC,'n',0,0)


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/temp_data/xkvjga@pdn[7-9]*.nc')
        atemp=f.variables['temp_1'][:]
        atemp=np.squeeze(atemp)
        ntimes,ny,nx=np.shape(atemp)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_tempp2_ann=np.mean(atemp,axis=0)
        print('new shape plio',np.shape(plio_tempp2_ann))
        lon=lontemp
        plio_tempp2_ann,lon = shiftgrid(180.,plio_tempp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_temp_ann-pi_temp_ann

    #V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    plotdata(plio_anom,2,lon,lat,titlediff,0,10,1.0,0,'n',degC,'n',0,0)
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_tempp2_ann-pi_temp_ann
        #V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,0,'n',degC,'n',0,0)


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    
    plt.close()

  
     # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   

    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        anom_land=plio_anom / lsm
        anom_sea=plio_anom / np.abs(lsm-1.0)
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=plio_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP - PI Temperature Anomaly',0,10,1.0,V,'i',degC,'n',0,0)
        plt.show()
        sys.exit()



    # print temperature changes
    # create weighting array
    weightarr=np.zeros(np.shape(anom_sea))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('mean anom_sea',np.average(plio_anom,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(plio_anom,weights=weightarr*lsm))
    print('allmean',np.average(plio_anom,weights=weightarr))


    # plot temperature change by latitude    

    lat_avg_diff=np.average(plio_anom,axis=1)
    print(lat_avg_diff)
    print(np.shape(lat_avg_diff))
    allavg=np.average(lat_avg_diff,weights=np.cos(np.deg2rad(lat)))
    plt.plot(lat,lat_avg_diff)
    

    # find temperature change poleward of 60deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 60:
            print(lat[j],lat_avg_diff[j])
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -60:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 60N=',nhsum/nhsum_weights)
    print('sh t change poleward 60S=',shsum/shsum_weights)

 # find temperature change poleward of 75deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 75:
            print(lat[j],lat_avg_diff[j])
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -75:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 75N=',nhsum/nhsum_weights)
    print('sh t change poleward 75S=',shsum/shsum_weights)
    


#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
        tempname='temp'
        titlePI='PI-TAnn_HadCM3'
        titlediff='Plio - PI Tanom_HadCM3'
    else:
   
        # read in data from multiple files
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/temp_data/xkvjea@pdn[7-9]*'+m1+'_temp.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/temp_data/xkvjea@pdn[7-9]*'+m2+'_temp.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/temp_data/xkvjea@pdn[7-9]*'+m3+'_temp.nc')
        tempname='temp_1'
        titlePI='PI-TAnn_HadGEM2'
        titlediff='Plio - PI Tanom_HadGEM2'


    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    atemp=fa.variables[tempname][:]
    btemp=fb.variables[tempname][:]
    ctemp=fc.variables[tempname][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    ntimes,ny,nx=np.shape(atemp)
    
#average across the time dimension
    pi_atemp_avg=np.mean(atemp,axis=0)
    pi_btemp_avg=np.mean(btemp,axis=0)
    pi_ctemp_avg=np.mean(ctemp,axis=0)
    
    pi_seastemp=np.mean((pi_atemp_avg,pi_btemp_avg,pi_ctemp_avg),axis=0)
    print('seastemp',np.shape(pi_seastemp))
    
    
    degC=u'\N{DEGREE SIGN}'+'C'
    
    lontemp=lon
    pi_seastemp,lon = shiftgrid(180.,pi_seastemp,lon,start=False)

    lon=lontemp
    pi_atemp_avg,lon = shiftgrid(180.,pi_atemp_avg,lon,start=False)
    
    plotdata(pi_seastemp-273.15,0,lon,lat,titlePI+seasname,-20,21,1.0,0.0,'a',degC,'n',0,0)

  
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        tempname='temp'
        titlePlio='Plio-TAnn_HadCM3'
    else:
   
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/temp_data/xkvjfa@pdn[7-9]*'+m1+'_temp.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/temp_data/xkvjfa@pdn[7-9]*'+m2+'_temp.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/temp_data/xkvjfa@pdn[7-9]*'+m3+'_temp.nc')
        tempname='temp_1'
        titlePlio='Plio-TAnn_HadGEM2'
 
    atemp=fa.variables[tempname][:]
    btemp=fb.variables[tempname][:]
    ctemp=fc.variables[tempname][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)

    # average across the time dimension    
    plio_atemp_avg=np.mean(atemp,axis=0)
    plio_btemp_avg=np.mean(btemp,axis=0)
    plio_ctemp_avg=np.mean(ctemp,axis=0)
    
    plio_seastemp=np.mean((plio_atemp_avg,plio_btemp_avg,plio_ctemp_avg),axis=0)
    print('seastemp',np.shape(plio_seastemp))

    lon=lontemp
    plio_seastemp,lon = shiftgrid(180.,plio_seastemp,lon,start=False)
    
    if HadCM3 != 'y':
        plotdata(plio_seastemp-273.15,1,lon,lat,titlePlio+seasname,-20,21,1.0,0.0,'a',degC,'n',0,0)
    
    
  

     #==============
     # Pliocene+2

    if HadCM3 !='y':
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/temp_data/xkvjga@pdn[7-9]*'+m1+'_temp.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/temp_data/xkvjga@pdn[7-9]*'+m2+'_temp.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/temp_data/xkvjga@pdn[7-9]*'+m3+'_temp.nc')
        atemp=fa.variables['temp_1'][:]
        btemp=fb.variables['temp_1'][:]
        ctemp=fc.variables['temp_1'][:]
        atemp=np.squeeze(atemp)
        btemp=np.squeeze(btemp)
        ctemp=np.squeeze(ctemp)
        
        pliop2_atemp_avg=np.mean(atemp,axis=0)
        pliop2_btemp_avg=np.mean(btemp,axis=0)
        pliop2_ctemp_avg=np.mean(ctemp,axis=0)
        
        pliop2_seastemp=np.mean((pliop2_atemp_avg,pliop2_btemp_avg,pliop2_ctemp_avg),axis=0)
        print('seastemp',np.shape(pliop2_seastemp))
        
        lon=lontemp
        pliop2_seastemp,lon = shiftgrid(180.,pliop2_seastemp,lon,start=False)
  
        plotdata(pliop2_seastemp-273.15,1,lon,lat,titlePlio+seasname,-20,21,1.0,0.0,'a',degC,'n',0,0)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seastemp-pi_seastemp
    #V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(plio_anom,2,lon,lat,titlediff+seasname,-10,10,3.0,V,'a',degC,'n',0,0)
    
    # Pliocene+2 - preindustrial

    if HadCM3 !='y':
        pliop2_anom=pliop2_seastemp-pi_seastemp
        V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',-10,10,1.0,V,'a',degC,'n',0,0)



    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    plt.figure(1)

    # do figure for paper
    
    if seasname=='DJF': seasname_plus='a) DJF'
    if seasname=='MAM': seasname_plus='b) MAM'
    if seasname=='JJA': seasname_plus='c) JJA'
    if seasname=='SON': seasname_plus='d) SON'
    if HadCM3 =='n':
        plotdata(pliop2_anom,99,lon,lat,seasname_plus,0,15,1.0,0,'n',degC,'y',pi_seastemp-273.15,pliop2_seastemp-273.15)
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+seasname+'xkvjg.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only'+seasname+'xkvjg.png' 
        plt.savefig(fileout, bbox_inches='tight')  

    else:
        plotdata(plio_anom,99,lon,lat,seasname,0,15,1.0,0,'n',degC,'y',pi_seastemp-273.15,plio_seastemp-273.15)
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+seasname+'xibol.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+seasname+'xibol.png' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
   


    # set up for writing out averages
    # get land mask and put on correct grid

    if HadCM3 != 'y':
        fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    else:
        fm=Dataset('/nfs/hera2/apps/metadata/ancil/preind2/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   

    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        anom_land=plio_anom / lsm
        anom_sea=plio_anom / np.abs(lsm-1.0)
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=plio_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC,'n',0,0)
        plt.show()
        sys.exit()



    # print temperature changes
    # create weighting array
    weightarr=np.zeros(np.shape(anom_sea))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print(seasname)
    print('mean anom_sea',np.average(plio_anom,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(plio_anom,weights=weightarr*lsm))
    print('allmean',np.average(plio_anom,weights=weightarr))


    # plot temperature change by latitude    

    lat_avg_diff=np.average(plio_anom,axis=1)
    allavg=np.average(lat_avg_diff,weights=np.cos(np.deg2rad(lat)))
    plt.plot(lat,lat_avg_diff)
    

    # find temperature change poleward of 60deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 60:
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -60:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 60N=',nhsum/nhsum_weights)
    print('sh t change poleward 60S=',shsum/shsum_weights)

    # find temperature change poleward of 75deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 75:
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -75:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 75N=',nhsum/nhsum_weights)
    print('sh t change poleward 75S=',shsum/shsum_weights)
    



#end def seasmean


def temp_chg_by_latitude(HadCM3):

    #==============
    # preindustrial

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]
    else:
    # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvje/temp_data/xkvjea@pdn[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp_1'][:]
    
    f.close()
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension and the latitude dimension
    pi_temp_ann=np.mean(atemp,axis=0)
    pi_temp_lat_ann=np.mean(pi_temp_ann,axis=1)
    print('new shape pi',np.shape(pi_temp_lat_ann))
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[5-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]

    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjf/temp_data/xkvjfa@pdn[5-9]*.nc')
        atemp=f.variables['temp_1'][:]

    f.close()
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)

    plio_temp_ann=np.mean(atemp,axis=0)
    plio_temp_lat_ann=np.mean(plio_temp_ann,axis=1)
    print('new shape plio',np.shape(pi_temp_lat_ann))


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjg/temp_data/xkvjga@pdn[5-9]*.nc')
        atemp=f.variables['temp_1'][:]
        atemp=np.squeeze(atemp)
        ntimes,ny,nx=np.shape(atemp)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_tempp2_ann=np.mean(atemp,axis=0)
        plio_tempp2_lat_ann=np.mean(plio_tempp2_ann,axis=1)
        f.close()


    # Pliocene - preindustrial

    plio_anom=plio_temp_lat_ann-pi_temp_lat_ann

    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_tempp2_lat_ann-pi_temp_lat_ann


    if HadCM3 == 'y':
        allanom=[lat,plio_anom]
        return allanom
    else:
        allanom=[lat,plio_anom,pliop2_anom]
        return allanom
    
    



#end def temp_chg_by_latitude


################################
# main program

# annual mean
figureno=0

HadCM3='n'

#plt.figure(figureno)
annmean('y',HadCM3)
#figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'DJF',HadCM3)
#figureno=figureno+1

#mam mean
#plt.figure(figureno)
#seasmean('mr','ar','my',figureno,'MAM',HadCM3)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'JJA',HadCM3)
##figureno=figureno+1

#son mean
#plt.figure(figureno)
#seasmean('sp','ot','nv',figureno,'SON',HadCM3)
#figureno=figureno+1

# to see what the polar amplification is
plt.close()
HadCM3='y'
temp_ret=temp_chg_by_latitude(HadCM3)
lats_HadCM3=temp_ret[0]
temp_anom_HadCM3=temp_ret[1]
#plt.plot(temp_anom_HadCM3,lats_HadCM3)

HadCM3='n'
temp_ret=temp_chg_by_latitude(HadCM3)
lats_HadGEM=temp_ret[0]
temp_anom_HadGEM=temp_ret[1]
temp_anom_HadGEMp2=temp_ret[2]

mp.rcParams.update({'font.size':15})
plt.plot(temp_anom_HadGEMp2,lats_HadGEM,'g',label='HadGEM2')
plt.plot(temp_anom_HadCM3,lats_HadCM3,'r',label='HadCM3')
#plt.plot(temp_anom_HadGEM,lats_HadGEM,'b')

degC=u'\N{DEGREE SIGN}'+'C'
plt.xlabel(degC,fontsize=15)
plt.ylabel('latitude',fontsize=15)
plt.title('b) mPWP - PI temperature anomaly',loc='left',fontsize=20)
axes=plt.gca()
axes.set_xlim(xmin=0,xmax=12)#
axes.set_ylim([-80,80])
legend=plt.legend(loc='center right')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_polar_amp.eps'
plt.savefig(fileout, bbox_inches='tight')   
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_polar_amp.png' 
plt.savefig(fileout, bbox_inches='tight')  



sys.exit(0)

####

::::::::::::::
plot_surftemp.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFTEMP
#PURPOSE
#    This program will plot the temperature (annual and seasonal) and
#    the temperature anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary

    x, y = map(lons, lats)

    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='i': #increasing
                    print(V)
                    cs = map.contourf(x,y,plotdata,V,norm=mp.colors.LogNorm(vmin=0,vmax=32),cmap='Reds')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    cs = map.contourf(x,y,plotdata,V,extend='both',cmap='Reds')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-60,size=15)
        cbar.ax.tick_params(labelsize=15)
        plt.title(titlename,loc='left',fontsize=18)
   


#end def plotdata

def annmean(switch,preind_expt,plio_expt,pliop2_expt,extra):
    # switch is a dummy variable to allow the program to be called
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[5-9]*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_temp_ann=np.mean(atemp,axis=0)
    print('new shape',np.shape(pi_temp_ann))
    
    
    plt.figure(0)
    degC=u'\N{DEGREE SIGN}'+'C'
    lontemp=lon
    pi_temp_ann,lon = shiftgrid(180.,pi_temp_ann,lon,start=False)
    
    print('about to plot')

    plotdata(pi_temp_ann-273.15,0,lon,lat,'PI-Ann_HadGEM2',-50,50,5.0,0.0,'n',degC)
    print('plotted first')
    f.close()


     #==============
     # Pliocene


    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'[5-9]*.nc')
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)

    plio_temp_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_temp_ann))

    lon=lontemp
    plio_temp_ann,lon = shiftgrid(180.,plio_temp_ann,lon,start=False)

    plotdata(plio_temp_ann-273.15,1,lon,lat,'Plio-TAnn_HG2',-50,50,5.0,0.0,'n',degC)
    f.close()


     #==============
     # Pliocene+2


     # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
    #average across the time dimension
    plio_tempp2_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_tempp2_ann))
    lon=lontemp
    plio_tempp2_ann,lon = shiftgrid(180.,plio_tempp2_ann,lon,start=False)
    f.close()



    # Pliocene - preindustrial

    plio_anom=plio_temp_ann-pi_temp_ann

    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(plio_anom,2,lon,lat,'Plio - PI Tanom_HG2',0,10,1.0,V,'n',degC)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=plio_tempp2_ann-pi_temp_ann
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,V,'n',degC)


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # plot anomaly plot for +2 on seperate page for paper
    V=[0,1,2,3,4,6,8,10,12,14,16]
    titlename='a) mPWP - PI  Temperature anomaly '
    plotdata(pliop2_anom,99,lon,lat,titlename,0,10,1.0,V,'n',degC)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+pliop2_expt+'.png' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()

   

    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        anom_land=pliop2_anom / lsm
        anom_sea=pliop2_anom / np.abs(lsm-1.0)
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=pliop2_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC)
        plt.show()
        sys.exit()


    # create weighting array
    weightarr=np.zeros(np.shape(anom_sea))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print('mean anom_sea',np.average(pliop2_anom,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(pliop2_anom,weights=weightarr*lsm))
    print('allmean_2',np.average(pliop2_anom,weights=weightarr))



    print('non plus 2')
    print('mean anom_sea',np.average(plio_anom,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(plio_anom,weights=weightarr*lsm))
    print('allmean',np.average(plio_anom,weights=weightarr))

    # plot temperature change by latitude    

    lat_avg_diff=np.average(pliop2_anom,axis=1)
    print(lat_avg_diff)
    print(np.shape(lat_avg_diff))
    allavg=np.average(lat_avg_diff,weights=np.cos(np.deg2rad(lat)))
    plt.plot(lat,lat_avg_diff)
    plt.show()

    # find temperature change poleward of 60deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 60:
            print(lat[j],lat_avg_diff[j])
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -60:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 60N=',nhsum/nhsum_weights)
    print('sh t change poleward 60S=',shsum/shsum_weights)

 # find temperature change poleward of 75deg
    nhsum=0.
    nhsum_weights=0.
    shsum=0.
    shsum_weights=0.
    for j in range(0,len(lat)):
        if lat[j] >= 75:
            print(lat[j],lat_avg_diff[j])
            nhsum=nhsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            nhsum_weights=nhsum_weights+(np.cos(np.deg2rad(lat[j])))
        if lat[j] <= -75:
            shsum=shsum+(lat_avg_diff[j] * np.cos(np.deg2rad(lat[j])))
            shsum_weights=shsum_weights+(np.cos(np.deg2rad(lat[j])))
    print('nh t change poleward 75N=',nhsum/nhsum_weights)
    print('sh t change poleward 75S=',shsum/shsum_weights)
    
    
 

#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'*'+m3+'_temp.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    ntimes,ny,nx=np.shape(atemp)
    
    #average across the time dimension
    pi_atemp_avg=np.mean(atemp,axis=0)
    pi_btemp_avg=np.mean(btemp,axis=0)
    pi_ctemp_avg=np.mean(ctemp,axis=0)

    #stdev across the time dimension
    pi_atemp_stdev=np.std(atemp,axis=0)
    pi_btemp_stdev=np.std(btemp,axis=0)
    pi_ctemp_stdev=np.std(ctemp,axis=0)
    
    pi_seastemp=np.mean((pi_atemp_avg,pi_btemp_avg,pi_ctemp_avg),axis=0)
    
    
    degC=u'\N{DEGREE SIGN}'+'C'
    
    lontemp=lon
    pi_seastemp,lon = shiftgrid(180.,pi_seastemp,lon,start=False)
    
    plotdata(pi_seastemp-273.15,0,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)
    

    fa.close()
    fb.close()
    fc.close()
    #==============
    # Pliocene


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)

    # average across the time dimension    
    plio_atemp_avg=np.mean(atemp,axis=0)
    plio_btemp_avg=np.mean(btemp,axis=0)
    plio_ctemp_avg=np.mean(ctemp,axis=0)

    # find standard deviation across time dimension
    plio_atemp_stdev=np.std(atemp,axis=0)
    plio_btemp_stdev=np.std(btemp,axis=0)
    plio_ctemp_stdev=np.std(ctemp,axis=0)

    
    plio_seastemp=np.mean((plio_atemp_avg,plio_btemp_avg,plio_ctemp_avg),axis=0)

    lon=lontemp
    plio_seastemp,lon = shiftgrid(180.,plio_seastemp,lon,start=False)
    
    
    plotdata(plio_seastemp-273.15,1,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)


    fa.close()
    fb.close()
    fc.close()
   
     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    
    pliop2_atemp_avg=np.mean(atemp,axis=0)
    pliop2_btemp_avg=np.mean(btemp,axis=0)
    pliop2_ctemp_avg=np.mean(ctemp,axis=0)
    
    pliop2_seastemp=np.mean((pliop2_atemp_avg,pliop2_btemp_avg,pliop2_ctemp_avg),axis=0)

    lon=lontemp
    pliop2_seastemp,lon = shiftgrid(180.,pliop2_seastemp,lon,start=False)
    
    fa.close()
    fb.close()
    fc.close()
   
 

    # Pliocene - preindustrial

    plio_anom=plio_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(plio_anom,2,lon,lat,'Plio - PI Tanom_HG2',0,10,1.0,V,'n',degC)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,V,'n',degC)



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    

    



    # plot anomaly plot for +2 on seperate page for paper
    #V=[-2,-1,0,1,2,4,8,16,32]
    #V=[-1,0,1,2,4,8,16,32]
    V=0
    plotdata(pliop2_anom,99,lon,lat,'a) mPWP temperature anomaly '+seasname,0.,16,1.0,V,'n',degC)
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_only_'+seasname+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()




# plot standard deviation for plio for months


    plotdata(pi_atemp_stdev,0,lon,lat,'PI stdev m1: '+seasname,0,6,0.5,0.0,'n',degC)
    plotdata(pi_btemp_stdev,1,lon,lat,'PI stdev m2: '+seasname,0,6,0.5,0.0,'n',degC)
    plotdata(pi_ctemp_stdev,2,lon,lat,'PI stdev m3: '+seasname,0,6,0.5,0.0,'n',degC)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/stdevT'+seasname+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()

# plot standard deviation for plio for months


    plotdata(plio_atemp_stdev,0,lon,lat,'Plio stdev m1: '+seasname,0,6,0.5,0.0,'n',degC)
    plotdata(plio_btemp_stdev,1,lon,lat,'Plio stdev m2: '+seasname,0,6,0.5,0.0,'n',degC)
    plotdata(plio_ctemp_stdev,2,lon,lat,'Plio stdev m3: '+seasname,0,6,0.5,0.0,'n',degC)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/stdevT'+seasname+'_'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()
   
# plot difference in standard deviation for each month

    stdev_anom_1=plio_atemp_stdev-pi_atemp_stdev
    stdev_anom_2=plio_btemp_stdev-pi_btemp_stdev
    stdev_anom_3=plio_atemp_stdev-pi_ctemp_stdev
    plotdata(stdev_anom_1,0,lon,lat,'Plio stdev m1: '+seasname,-2.5,3.0,0.5,0.0,'a',degC)
    plotdata(stdev_anom_2,1,lon,lat,'Plio stdev m2: '+seasname,-2.5,3.0,0.5,0.0,'a',degC)
    plotdata(stdev_anom_3,2,lon,lat,'Plio stdev m3: '+seasname,-2.5,3.0,0.5,0.0,'a',degC)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/stdevT'+seasname+'anom'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # get land mask and put on correct grid

    fm=Dataset('/nfs/hera1/earjcti/um/HadGEM_ancils/qrparm.mask.nc')
    lsmlon=fm.variables['longitude'][:]
    lsmlat=fm.variables['latitude'][:]
    lsm=fm.variables['lsm'][:]
    lsm=np.squeeze(lsm)
    lsm,lsmlon = shiftgrid(180.,lsm,lsmlon,start=False)
    fm.close()
   
    # arctic circle mask polewards of 60N
    arct_circ_mask=np.zeros(np.shape(lsm))
    arct_circ_mask_high=np.zeros(np.shape(lsm))
    antarct_circ_mask=np.zeros(np.shape(lsm))
    antarct_circ_mask_high=np.zeros(np.shape(lsm))
    for j in range(0,len(lat)):
        if lsmlat[j] < 60.:
            arct_circ_mask[j,:]=1.0
        if lsmlat[j] < 75.:
            arct_circ_mask_high[j,:]=1.0
        if lsmlat[j] > -60.:
            antarct_circ_mask[j,:]=1.0
        if lsmlat[j] > -75.:
            antarct_circ_mask_high[j,:]=1.0



    if (np.array_equal(lsmlon,lon)) and (np.array_equal(lsmlat,lat)):
        anom_land=pliop2_anom / lsm
        anom_sea=pliop2_anom / np.abs(lsm-1.0)
        arctic_anom=pliop2_anom / np.abs(arct_circ_mask-1.0)
        antarctic_anom_high=pliop2_anom / np.abs(antarct_circ_mask_high-1.0)
    else:
        print('error lon/lat of land sea mask dont match')
        anom_land=pliop2_anom * lsm
        plotdata(anom_land,99,lon,lat,'a) mPWP temperature anomaly',0,10,1.0,V,'i',degC)
        plt.show()
        sys.exit()


    # create weighting array
    weightarr=np.zeros(np.shape(anom_sea))
    for i in range(0,len(lon)):
        weightarr[:,i]=np.cos(np.deg2rad(lat))

    print()
    print(seasname)
    print('=====')
    print('mean anom_sea',np.average(pliop2_anom,weights=weightarr * np.abs(lsm-1.0)))
    print('mean anom_land',np.average(pliop2_anom,weights=weightarr*lsm))
    print('allmean',np.average(pliop2_anom,weights=weightarr))
    print('arct circ mean',np.average(pliop2_anom,weights=weightarr* np.abs(arct_circ_mask-1.0)))
    print('arct circ high mean',np.average(pliop2_anom,weights=weightarr* np.abs(arct_circ_mask_high-1.0)))
    print('antarct circ mean',np.average(pliop2_anom,weights=weightarr* np.abs(antarct_circ_mask-1.0)))
    print('antarct circ high mean',np.average(pliop2_anom,weights=weightarr* np.abs(antarct_circ_mask_high-1.0)))

    plotdata(arctic_anom,0,lon,lat,'a) mPWP temperature anomaly',8,16,1.0,V,'n',degC)
    #plotdata(antarctic_anom_high,1,lon,lat,'a) mPWP temperature anomaly',8,16,1.0,V,'n',degC)
    #plotdata(anom_land,2,lon,lat,'a) mPWP temperature anomaly',8,16,1.0,V,'n',degC)
    #plotdata(anom_sea,3,lon,lat,'a) mPWP temperature anomaly',8,16,1.0,V,'n',degC)
    #plt.show()
      





   







#end def annmean

################################
# main program

# annual mean
figureno=0

preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'


plt.figure(figureno)
annmean('y',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#mam mean
#plt.figure(figureno)
#seasmean('mr','ar','my',figureno,'mam',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1

#son mean
#plt.figure(figureno)
#seasmean('sp','ot','nv',figureno,'son',preind_expt,plio_expt,pliop2_expt,extra)
#figureno=figureno+1




sys.exit(0)

####

::::::::::::::
plot_temp_chg_levels.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_temp_chg_levels.py
#PURPOSE
#    This program will plot the temperature change between the mPWP
#    and PI by level.  We will normalise it by the surface temperature
#    change
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

    print(fileno)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=0.0,urcrnrlon=360.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                mycmap=mp.cm.get_cmap('bwr',len(V+2))
                newcolors=mycmap(np.linspace(0,1,len(V+2)))
                white=([1,1,1,1])
                newcolors[(len(V)/2)-1:(len(V)/2)+2,:]=white
                mycmap=ListedColormap(newcolors)
                print(mycmap)
                
                cs = map.contourf(x,y,plotdata,V,cmap=mycmap,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,cmap='rainbow',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal",)

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def annmean(preind_expt,plio_expt,pliop2_expt,extra,HadCM3):
   

    if HadCM3 == 'y':
        filepi='/nfs/hera1/earjcti/um/'+preind_expt+'/netcdf/'+preind_expt+'a@pc'+extra+'[7-9]*.nc'
        fileplio='/nfs/hera1/earjcti/um/'+pliop2_expt+'/netcdf/'+pliop2_expt+'a@pc'+extra+'[7-9]*.nc'
        latname='latitude_1'
        lonname='longitude_1'
    else:
        filepi='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pc'+extra+'[7-9]*.nc'
        fileplio='/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/'+pliop2_expt+'a@pc'+extra+'[7-9]*.nc'
        latname='latitude'
        lonname='longitude'

    # get preindustrial data
    f=MFDataset(filepi)
    lat = f.variables[latname][:]
    lon = f.variables[lonname][:]
    pressure = f.variables['p'][:]
    atemp=f.variables['temp'][:]
  
    temp_pi=np.mean(atemp,axis=0)
    temp_pi=np.squeeze(temp_pi)
    nz,ny,nx=np.shape(temp_pi)
  

   # get pliocene data
    f=MFDataset(fileplio)
    atemp=f.variables['temp'][:]
  
    temp_plio=np.mean(atemp,axis=0)
    temp_plio=np.squeeze(temp_plio)
   

    # get pliocene-preindustrial data
    temp_diff=temp_plio-temp_pi
    # normalize temp_diff by surface
    temp_diff_norm=temp_diff / temp_diff[0,:,:]

    nplots=2 # 2 plots per page
    npages=np.int(np.floor(nz/nplots))
    for figure in range(0,npages):
       for i in range(0,nplots):
          titlename='tdiff at pressure '+np.str(pressure[(figure *nplots)+i])
          titlename2='normalized at pressure '+np.str(pressure[(figure *nplots)+i])
          print('nums',(figure*nplots),((figure*nplots)+i),2.*((figure*nplots)+i))
          plotdata(temp_diff[(figure*nplots)+i,:,:],2*i,lon,lat,titlename,0,5.5,0.5,0.0,'n','degC')
          plotdata(temp_diff_norm[(figure*nplots)+i,:,:],2*i+1,lon,lat,titlename2,0,2.1,0.1,0.0,'a','fraction')

       fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_temp_chg_levels/'+pliop2_expt+'-'+preind_expt+'_'+np.str(pressure[(figure *nplots)+i])+'.eps' 
       plt.savefig(fileout, bbox_inches='tight')
       plt.close()
          
   
#end def annmean


def seasmean(monthnames,seasonname,preind_expt,plio_expt,pliop2_expt,extra,HadCM3):
   

    if HadCM3 == 'y':
        filepi='/nfs/hera1/earjcti/um/'+preind_expt+'/netcdf/'+preind_expt+'a@pc'+extra+'[7-9]*'
        fileplio='/nfs/hera1/earjcti/um/'+pliop2_expt+'/netcdf/'+pliop2_expt+'a@pc'+extra+'[7-9]*'
        latname='latitude_1'
        lonname='longitude_1'
    else:
        filepi='/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pc'+extra+'[7-9]*'
        fileplio='/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/'+pliop2_expt+'a@pc'+extra+'[7-9]*'
        latname='latitude'
        lonname='longitude'

   
    # get preindustrial data
    tottemp=0
    for i in range(0,len(monthnames)):
        print(filepi+monthnames[i]+'.nc')
        f=MFDataset(filepi+monthnames[i]+'.nc')
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
        pressure = f.variables['p'][:]
        atemp=f.variables['temp'][:]
        tottemp=tottemp+atemp
  
    tottemp=tottemp / len(monthnames)
    temp_pi=np.mean(tottemp,axis=0)
    temp_pi=np.squeeze(temp_pi)
    nz,ny,nx=np.shape(temp_pi)
  

   # get pliocene data
    tottemp=0
    for i in range(0,len(monthnames)):
        f=MFDataset(fileplio+monthnames[i]+'.nc')
        atemp=f.variables['temp'][:]

    tottemp=tottemp+atemp
    temp_plio=np.mean(atemp,axis=0)
    temp_plio=np.squeeze(temp_plio)
   

    # get pliocene-preindustrial data
    temp_diff=temp_plio-temp_pi
    # normalize temp_diff by surface
    temp_diff_norm=temp_diff / temp_diff[0,:,:]

    nplots=2 # 2 plots per page
    npages=np.int(np.floor(nz/nplots))
    for figure in range(0,npages):
       for i in range(0,nplots):
          titlename='tdiff '+seasonname+' at press'+np.str(pressure[(figure *nplots)+i])
          titlename2='normalized at pressure '+np.str(pressure[(figure *nplots)+i])
          print('nums',(figure*nplots),((figure*nplots)+i),2.*((figure*nplots)+i))
          plotdata(temp_diff[(figure*nplots)+i,:,:],2*i,lon,lat,titlename,0,5.5,0.5,0.0,'n','degC')
          plotdata(temp_diff_norm[(figure*nplots)+i,:,:],2*i+1,lon,lat,titlename2,0,2.1,0.1,0.0,'a','fraction')

       fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_temp_chg_levels/'+pliop2_expt+'-'+preind_expt+'_'+np.str(pressure[(figure *nplots)+i])+'_'+seasonname+'.eps' 
       plt.savefig(fileout, bbox_inches='tight')
       plt.close()
          
   
#end def seasname


################################
# main program

# annual mean
#preind_expt='xiboi'
#plio_expt='xibol'
#pliop2_expt='xibol'
#extra='y'
#HadCM3='y'


preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'
HadCM3='n'
#annmean(preind_expt,plio_expt,pliop2_expt,extra,HadCM3)
seasmean(['dc','ja','fb'],'djf',preind_expt,plio_expt,pliop2_expt,extra,HadCM3)
seasmean(['jn','jl','ag'],'jja',preind_expt,plio_expt,pliop2_expt,extra,HadCM3)




sys.exit(0)

####

::::::::::::::
plot_total_precipitable_water.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_TOTAL_PRECIPITABLE_WATER
#PURPOSE
#    This program will try and plot the total precipitable water from the
#    HadGEM2 simulations (using various methods). A quick google search suggests
#    this should be up to 50mm in the tropics and less as we go further 
#    polewards
#
# search for 'main program' to find end of functions
# Julia 14/11/2018



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean_from_HadGEM_diags

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,mask_ind):
    lons, lats = np.meshgrid(lon,lat)
    if fileno !=99:
        plt.subplot(2,2,fileno+1)


    if mask_ind == 'l': # ;land mask
        plotnew=maskoceans(lons,lats,plotdata)
        plotdata=plotnew
        if cbarname=='mm/day':
            minval=minval/2.
            maxval=maxval/2.
            valinc=valinc/2.

    if mask_ind =='t': # tropics mask
        northlat=30.0
        southlat=-30.0
    else:
        northlat=90.0
        southlat=-90.0

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c')
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu',extend='both')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='ra':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")


    if fileno != 99:
        plt.title(titlename)
        cbar.set_label(cbarname,labelpad=-40)
    else:
        cbar.set_label(cbarname,labelpad=-70,size=20)
        cbar.ax.tick_params(labelsize=20)
        plt.title(titlename,loc='left',fontsize=20)
   

    plotdata=plotdata2

    if mask_ind == 'l':
        map.drawmapboundary(fill_color='white')
    else:
        map.drawmapboundary

#end def plotdata


def annmean_from_HadGEM_diags(preind_expt,plio_expt,pliop2_expt,extra):
#
# we are assuming that this is wetmass-drymass.  The values and patterns
# generally look correct for the PI
#
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pd'+extra+'[7-9]*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    drymass=f.variables['unspecified_1'][:]
    wetmass=f.variables['unspecified_2'][:]
    drymass=np.squeeze(drymass)
    wetmass=np.squeeze(wetmass)
    ntimes,ny,nx=np.shape(drymass)
    drymass_avg=np.mean(drymass,axis=0)
    wetmass_avg=np.mean(wetmass,axis=0)
    f.close()

    pi_precip_water=wetmass_avg-drymass_avg
    pi_precip_water,lontemp = shiftgrid(180.,pi_precip_water,lon,start=False)
    
    plotdata(pi_precip_water,0,lontemp,lat,'PI-Ann_HadGEM2',0,60,1.0,0.0,'n','mm','b')

 
     #==============
     # Pliocene

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    drymass=f.variables['unspecified_1'][:]
    wetmass=f.variables['unspecified_2'][:]
    drymass=np.squeeze(drymass)
    wetmass=np.squeeze(wetmass)
    ntimes,ny,nx=np.shape(drymass)
    drymass_avg=np.mean(drymass,axis=0)
    wetmass_avg=np.mean(wetmass,axis=0)
    f.close()

    plio_precip_water=wetmass_avg-drymass_avg
    plio_precip_water,lon = shiftgrid(180.,plio_precip_water,lon,start=False)
    
    plotdata(plio_precip_water,1,lon,lat,'Plio-Ann_HadGEM2',00,60,1.0,0.0,'n','mm','b')
    


    ##############################################
    # plot the difference between the plio and the preind

    precip_water_diff=plio_precip_water-pi_precip_water
    precip_water_pcent_chg = (precip_water_diff / pi_precip_water)*100.
    plotdata(plio_precip_water,2,lon,lat,'diff Ann_HadGEM2',-40,42,2.0,0.0,'a','mm','b')
    plotdata(precip_water_pcent_chg,3,lon,lat,'diff Ann_HadGEM2 (%)',-0,50,2.0,0.0,'n','%','b')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/annmean_from_HadGEM_'+pliop2_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()

    plotdata(plio_precip_water,99,lon,lat,'diff Ann_HadGEM2',-20,22,2.0,0.0,'a','mm','b')
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/annmean_anom_from_HadGEM_'+pliop2_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()

    retdata=[lon,lat,precip_water_pcent_chg]
    return retdata

#end def annmean


def seasmean_from_HadGEM_diags(m1,m2,m3,preind_expt,plio_expt,pliop2_expt,extra,seasname):
#
# we are assuming that this is wetmass-drymass.  The values and patterns
# generally look correct for the PI
#
    #==============
    # preindustrial


    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pd'+extra+'[7-9]*'+m1+'.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pd'+extra+'[7-9]*'+m2+'.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/netcdf/'+preind_expt+'a@pd'+extra+'[7-9]*'+m3+'.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    drymass_a=fa.variables['unspecified_1'][:]
    wetmass_a=fa.variables['unspecified_2'][:]
    drymass_b=fb.variables['unspecified_1'][:]
    wetmass_b=fb.variables['unspecified_2'][:]
    drymass_c=fc.variables['unspecified_1'][:]
    wetmass_c=fc.variables['unspecified_2'][:]
    drymass=(drymass_a+drymass_b+drymass_c)/3.0
    wetmass=(wetmass_a+wetmass_b+wetmass_c)/3.0
    drymass=np.squeeze(drymass)
    wetmass=np.squeeze(wetmass)
    ntimes,ny,nx=np.shape(drymass)
    drymass_avg=np.mean(drymass,axis=0)
    wetmass_avg=np.mean(wetmass,axis=0)
    fa.close()
    fb.close()
    fc.close()

    pi_precip_water=wetmass_avg-drymass_avg
    pi_precip_water,lontemp = shiftgrid(180.,pi_precip_water,lon,start=False)
    
    plotdata(pi_precip_water,0,lontemp,lat,'PI-Ann_HadGEM2 '+seasname,0,60,1.0,0.0,'n','mm','b')

 
     #==============
     # Pliocene

    print('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*.nc')
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*'+m1+'.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*'+m2+'.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/netcdf/pdfiles/'+pliop2_expt+'a@pd'+extra+'[5-9]*'+m3+'.nc')
    drymass_a=fa.variables['unspecified_1'][:]
    wetmass_a=fa.variables['unspecified_2'][:]
    drymass_b=fb.variables['unspecified_1'][:]
    wetmass_b=fb.variables['unspecified_2'][:]
    drymass_c=fc.variables['unspecified_1'][:]
    wetmass_c=fc.variables['unspecified_2'][:]
    drymass=(drymass_a+drymass_b+drymass_c)/3.0
    wetmass=(wetmass_a+wetmass_b+wetmass_c)/3.0
    drymass=np.squeeze(drymass)
    wetmass=np.squeeze(wetmass)
    ntimes,ny,nx=np.shape(drymass)
    drymass_avg=np.mean(drymass,axis=0)
    wetmass_avg=np.mean(wetmass,axis=0)
    fa.close()
    fb.close()
    fc.close()

    plio_precip_water=wetmass_avg-drymass_avg
    plio_precip_water,lon = shiftgrid(180.,plio_precip_water,lon,start=False)
    
    plotdata(plio_precip_water,1,lon,lat,'Plio-Ann_HadGEM2',00,60,1.0,0.0,'n','mm','b')
    


    ##############################################
    # plot the difference between the plio and the preind

    precip_water_diff=plio_precip_water-pi_precip_water
    precip_water_pcent_chg = (precip_water_diff / pi_precip_water)*100.

    plotdata(plio_precip_water,2,lon,lat,'diff Ann_HadGEM2',-40,42,2.0,0.0,'a','mm','b')
    plotdata(precip_water_pcent_chg,3,lon,lat,'diff Ann_HadGEM2 (%)',-0,50,2.0,0.0,'n','%','b')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/'+seasname+'_from_HadGEM_'+pliop2_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()

    titlename=('Diff '+seasname+' HadGEM2: precipitable water')
    plotdata(plio_precip_water,99,lon,lat,titlename,-20,22,2.0,0.0,'a','mm','b')
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/'+seasname+'_anom_from_HadGEM_'+pliop2_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()

   
    

#end def seasmean

def annmean_clausius_clapeyron(preind_expt,plio_expt,pliop2_expt,extra):

#
#  get surface temperature
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[7-9]*_temp.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    temp=f.variables['temp_1'][:]
    temp=np.squeeze(temp)
    ntimes,ny,nx=np.shape(temp)
    pi_temp=np.mean(temp,axis=0)
    f.close()

    pi_temp,lontemp = shiftgrid(180.,pi_temp,lon,start=False) 
    plotdata(pi_temp-273.15,0,lontemp,lat,'PI-Ann_HadGEM2',-50,50,10.0,0.0,'n','degC','b')

 
     #==============
     # Pliocene

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*_temp.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    temp=f.variables['temp_1'][:]
    temp=np.squeeze(temp)
    ntimes,ny,nx=np.shape(temp)
    pliop2_temp=np.mean(temp,axis=0)
    f.close()

    pliop2_temp,lon = shiftgrid(180.,pliop2_temp,lon,start=False) 
    plotdata(pliop2_temp-273.15,1,lon,lat,'Plio-Ann_HadGEM2',-50,50,10.0,0.0,'n','degC','b')



    ##############################################
    # plot the difference between the plio and the preind
    # and estimate the percentage change in saturated vapour pressure
    # assuming a 7% increase per degree and using a compound interest formula
    # (1+0.07)^tdiff

    temp_diff=pliop2_temp-pi_temp
    est_perc_chg=((1.07 ** temp_diff)-1.0)*100.
    print(est_perc_chg)
    plotdata(temp_diff,2,lon,lat,'diff Ann_HadGEM2',-10,12,2.0,0.0,'ra','degC','b')
    plotdata(est_perc_chg,3,lon,lat,'est svp increase (%)',0,50,2.0,0.0,'n','%','b')
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/annmean_claus_clap_'+pliop2_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


    retdata=[lon,lat,est_perc_chg]
    return retdata

    
#end def annmean_clausius_clapeyron


#def annmean_from_q(preind_expt,plio_expt,pliop2_expt,extra):
# note the drymass and wetmass diagnostics are set up in HadGEM2 in 
# atmosphere/climate_diagnostics_eot_diag.f90

# eot_diag.f90 tcm=vert_int_array(i,j,ip_dry_mass) * grid_factor
#          total column dry mass = amount * weighting
#
# grid_factor=1/a^2 (where a is earths radius) = 6371229
# vert_int_array from vert_eng_massq (in atmosphere/energy_correction)
#
# vert_int_array = sum(over levels) of tempd/tempw   (tempd dry, tempw wet)
# tempd=rho_dry * delr_rho
# tempw=rho_r2 * delr_rho
#
# delr_rho= r_theta_levels(k)-r_theta_levels(k-1)
# rho_dry=rho_r2 * tempd (where tempd is some weighted sum of 1-q-qcl-qcf)
#
# rho_r2 is input from eot_diag (in eot_dig it is called rho) - this looks 
# like it could be standard model levels (check section 30 1-7



################################
# main program

# annual mean
#figureno=0
preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'
HadCM3='n'
# this program will get the precipitable water from some diagnostics that are
# only available in HadGEM2
retdata=annmean_from_HadGEM_diags(preind_expt,plio_expt,pliop2_expt,extra)
moist_incr_lon=retdata[0]
moist_incr_lat=retdata[1]
moist_incr=retdata[2]
#seasmean_from_HadGEM_diags('dc','ja','fb',preind_expt,plio_expt,pliop2_expt,extra,'djf')
#seasmean_from_HadGEM_diags('mr','ar','my',preind_expt,plio_expt,pliop2_expt,extra,'mam')
#seasmean_from_HadGEM_diags('jn','jl','ag',preind_expt,plio_expt,pliop2_expt,extra,'jja')
#seasmean_from_HadGEM_diags('sp','ot','nv',preind_expt,plio_expt,pliop2_expt,extra,'son')



# okay so it is impossible to get HadCM3 and HadGEM2 precipitable water in the same way because of the way in which each program has saved the data. we will try and get HadCM3 water from q, qcl and qcf (If Alan thinks it is a good idea)
####

# using clausius claperyon equation and lots of approximations we see that 
# saturation vapour pressure increases by about 7% for every 1deg rise in 
# rise in temperature (will use this like a compound interest formula)
# see what percentage change in precipitable water is expected from temperature
#
#
retdata=annmean_clausius_clapeyron(preind_expt,plio_expt,pliop2_expt,extra)
est_moist_incr_lon=retdata[0]
est_moist_incr_lat=retdata[1]
est_moist_incr=retdata[2]

# plot difference in percentage change moisture increase calculated from
# estimated vs observed value

plotdata(est_moist_incr-moist_incr,99,est_moist_incr_lon,est_moist_incr_lat,'estimated - observed moisture increase (%)',-50,50,2.0,0.0,'a','%','b')
plt.show()
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_total_precipitable_water/est_minus_obs_moisture_increase_'+pliop2_expt+'_'+preind_expt+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()



sys.exit()
 
::::::::::::::
plot_TRIFFID.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_TRIFFID
#PURPOSE
#    This program will plot the vegetation types
# search for 'main program' to find end of functions
# Julia 31/1/2019



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,ygrid,xgrid,yuse,xuse,yspan,xspan):


    if fileno > 3:
        print('ERROR NOT ENOUGH SPACE ON PAGE ',fileno)
        sys.exit()
    #plt.subplot2grid((10,12),(fileno*2,0),colspan=9,rowspan=2)

    print(ygrid,xgrid,yuse,xuse,yspan,xspan)
    plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

    lons, lats = np.meshgrid(lon,lat)
   
    northlat=90.0
    southlat=-90.0

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=southlat,urcrnrlat=northlat,projection='cyl',resolution='c',fix_aspect=False)
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata


    # plot limits
    if V == 0:
        V=np.arange(minval,maxval+valinc,valinc)

    # plot map
        
    if uselog == 'n':
        mycmap=mp.cm.get_cmap('jet',len(V+2))
        newcolors=mycmap(np.linspace(0,1,len(V+2)))
        white=([1,1,1,1])
        newcolors[0,:]=white
        mycmap=ListedColormap(newcolors)
        cs = map.contourf(x,y,plotdata,V,cmap=mycmap)
      
        #cs = map.contourf(x,y,plotdata,V,cmap='YlGnBu')
      
        #cs = map.contourf(x,y,plotdata,V,cmap='rainbow')
        if fileno == 0:
            plt.title('mPWP')
        if fileno == 1:
            plt.title('PI')
    else:
        mycmap=mp.cm.get_cmap('RdBu_r',len(V+2))
        newcolors=mycmap(np.linspace(0,1,len(V+2)))
        white=([1,1,1,1])
        newcolors[(len(V)/2)-2:(len(V)/2)+3,:]=white
        mycmap=ListedColormap(newcolors)
        cs = map.contourf(x,y,plotdata,V,cmap=mycmap,extend='none')
       
  
    fontsize=10
    if fileno == 0 or fileno ==2:
        plt.text(-180.0-6,northlat-fontsize-1,titlename,fontsize=fontsize,ha="right",bbox=dict(boxstyle="square,pad=0.1",color="white"))
 

    # colorbar
    if fileno==0:

        #plt.subplot2grid((ygrid,xgrid),(yuse,xuse),colspan=yspan,rowspan=xspan)

        plt.subplot2grid((ygrid,xgrid),(ygrid-1,xuse),colspan=4,rowspan=xspan)

        plt.gca().set_visible(False)
        cbar = plt.colorbar(cs,orientation="horizontal",fraction=1.0,format='%0.1f')
        cbar.set_label(cbarname)
        cbar.ax.tick_params(labelsize=7)
         

    plotdata=plotdata2
    
    # plot map boundary
    map.drawmapboundary



#end def plotdata



def annmean(preind_expt,plio_expt,HadCM3):

    if HadCM3 == 'n':
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'
        filemid='/netcdf/pifiles/'
        modname='HadGEM2'


    if HadCM3 == 'y':
        filestart='/nfs/hera1/earjcti/um/netcdf/'
        filemid='_netcdf/'
        modname='HadCM3'

    if HadCM3 == 'HGpeter':
        filestart='/nfs/hera1/earjcti/um/HadGEM_data/'
        filemid='/netcdf/pifiles/'
        modname='HadGEM2_peter'
    

    #==============
    # preindustrial

    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    vegdata=0.
    count=0

    for mon in range (0,len(monthnames)):
       
        f=Dataset(filestart+preind_expt+filemid+preind_expt+'a@pin99'+monthnames[mon]+'.nc')
    
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        ntypes=f.variables['pseudo_1'][:]
        atemp=f.variables['field1391'][:]
        atemp_mean=np.mean(atemp,axis=0)
        atemp_mean=np.squeeze(atemp_mean)

        vegdata=vegdata+atemp_mean
        count=count+1

    vegdata_pi=vegdata/count # get mean of vegdata

     #==============
     # Pliocene

    vegdata=0.
    count=0
    for mon in range (0,len(monthnames)):
        print(filestart+plio_expt+filemid+plio_expt+'a@piy99'+monthnames[mon]+'.nc')
        if HadCM3 =='HGpeter':
            f=Dataset('/nfs/hera1/earjcti/um/ximup/datam/ximupa@pik99'+monthnames[mon]+'.nc')
        else:
            f=Dataset(filestart+plio_expt+filemid+plio_expt+'a@pio00'+monthnames[mon]+'.nc')
    
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        ntypes=f.variables['pseudo_1'][:]
        atemp=f.variables['field1391'][:]
        atemp_mean=np.mean(atemp,axis=0)
        atemp_mean=np.squeeze(atemp_mean)

        vegdata=vegdata+atemp_mean
        count=count+1

    vegdata_plio=vegdata/count # get mean of vegdata
     
    broadleaf_pi=vegdata_pi[0,:,:]
    broadleaf_plio=vegdata_plio[0,:,:]
    needleleaf_pi=vegdata_pi[1,:,:]
    needleleaf_plio=vegdata_plio[1,:,:]
    grasses_pi=vegdata_pi[2,:,:]+vegdata_pi[3,:,:]+vegdata_pi[4,:,:]
    grasses_plio=vegdata_plio[2,:,:]+vegdata_plio[3,:,:]+vegdata_plio[4,:,:]
    soil_pi=vegdata_pi[7,:,:]
    soil_plio=vegdata_plio[7,:,:]

    # shiftgrid

    lontemp=lon
    broadleaf_pi,lon = shiftgrid(180.,broadleaf_pi,lon,start=False)
   
    lon=lontemp
    broadleaf_plio,lon = shiftgrid(180.,broadleaf_plio,lon,start=False)
   
    lon=lontemp
    needleleaf_pi,lon = shiftgrid(180.,needleleaf_pi,lon,start=False)
   
    lon=lontemp
    needleleaf_plio,lon = shiftgrid(180.,needleleaf_plio,lon,start=False)
   

    lon=lontemp
    grasses_pi,lon = shiftgrid(180.,grasses_pi,lon,start=False)
   
    lon=lontemp
    grasses_plio,lon = shiftgrid(180.,grasses_plio,lon,start=False)
   
    lon=lontemp
    soil_pi,lon = shiftgrid(180.,soil_pi,lon,start=False)
   
    lon=lontemp
    soil_plio,lon = shiftgrid(180.,soil_plio,lon,start=False)
   

   
    plotdata(broadleaf_plio,0,lon,lat,'BLT',0.,1,0.05,0,'n','fractional coverage',17,7,0,0,2,4)
    plotdata(needleleaf_plio,2,lon,lat,'NLT',0.,1,0.05,0,'n','fractional coverage',17,7,4,0,2,4)
    plotdata(grasses_plio,2,lon,lat,'Grasses',0.,1,0.05,0,'n','fractional coverage',17,7,8,0,2,4)
    plotdata(soil_plio,2,lon,lat,'Soil',0.,1,0.05,0,'n','fractional coverage',17,7,12,0,2,4)
   
    plotdata(broadleaf_pi,1,lon,lat,'BLT',0.,1,0.05,0,'n','fractional coverage',17,7,0,2,2,4)
    plotdata(needleleaf_pi,3,lon,lat,'NLT',0.,1,0.05,0,'n','fractional coverage',17,7,4,2,2,4)
    plotdata(grasses_pi,3,lon,lat,'Grasses',0.,1,0.05,0,'n','fractional coverage',17,7,8,2,2,4)
    plotdata(soil_pi,3,lon,lat,'Soil',0.,1,0.05,0,'n','fractional coverage',17,7,12,2,2,4)
   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_TRIFFID/'+modname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_TRIFFID/'+modname+'.png' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


 

#end def annmean




################################
# main program

# annual mean

HadCM3='n'
preind_expt='xkvje'
pliop2_expt='xkvjg'

annmean(preind_expt,pliop2_expt,HadCM3)

#HadCM3='y'
#preind_expt='xiboi'
#plio_expt='xibol'

#annmean(preind_expt,plio_expt,HadCM3)

#HadCM3='n'
#preind_expt='xkvje'
#pliop2_expt='ximup'
#HadCM3='HGpeter' # check against peters vegetation#

#annmean(preind_expt,pliop2_expt,HadCM3)




sys.exit(0)

####

::::::::::::::
plot_winds.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_RADIATION
#PURPOSE
#    This program will plot the radiation budget for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016


import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid

sys.path.append('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/COMMON')
from jumaps import contourglobe


#functions are:
#  def plotquiver
#  def annmean
#  def seasmean

# functions start here
def plotquiver(udata,vdata,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver

########################################################
def annmean_surf(switch,HadCM3,expt,extra):
    # switch is a dummy variable to allow the program to be called

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/netcdf/'
        filename=expt+'a@pd'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename)
        os.system('ls '+dirname+filename+' | wc -l')
        nval=os.system('ls '+dirname+filename+' | wc -l')
        allfiles=subprocess.check_output('ls '+dirname+filename+' | wc -l',shell=True)
        print('number of files=',allfiles)
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        
        # we will plot 10 m winds (called u and v)
        
        u=f.variables['u'][:]
        v=f.variables['v'][:]


    u=np.squeeze(u)
    v=np.squeeze(v)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
#average across the time dimension
    u_ann=np.mean(u,axis=0)
    v_ann=np.mean(v,axis=0)
    
    
    plt.figure(0)
    ms='m/s'
    lontemp=lon
    titlename=expt+' winds'
    u_ann,lon = shiftgrid(180.,u_ann,lon,start=False)    
    lon=lontemp
    v_ann,lon = shiftgrid(180.,v_ann,lon,start=False)    
    plotquiver(u_ann,v_ann,lon,lat,titlename,0,400,40.0,0.0,'n',ms)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/annmean_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


#end def annmean



########################################################
def seasmean_surf(m1,m2,m3,seasname,HadCM3,expt,extra):
 
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/winds_data/'
        filea=expt+'a@pd*'+m1+'_winds.nc'
        fileb=expt+'a@pd*'+m2+'_winds.nc'
        filec=expt+'a@pd*'+m3+'_winds.nc'
        os.system('ls '+dirname+filea+' | wc -l')
        os.system('ls '+dirname+fileb+' | wc -l')
        os.system('ls '+dirname+filec+' | wc -l')
        print(dirname+filea)
        fa=MFDataset(dirname+filea)
        fb=MFDataset(dirname+fileb)
        fc=MFDataset(dirname+fileb)

        lat = fa.variables['latitude_1'][:]
        lon = fa.variables['longitude_1'][:]
        au=fa.variables['u'][:]
        bu=fb.variables['u'][:]
        cu=fc.variables['u'][:]
        au=np.squeeze(au)
        bu=np.squeeze(bu)
        cu=np.squeeze(cu)


        av=fa.variables['v'][:]
        bv=fb.variables['v'][:]
        cv=fc.variables['v'][:]
        av=np.squeeze(av)
        bv=np.squeeze(bv)
        cv=np.squeeze(cv)
        ntimes,ny,nx=np.shape(au)
        print(ntimes,ny,nx)
    
        print(np.shape(au),np.shape(bu),np.shape(cu))
        u=au+bu+cu
        v=av+bv+cv

    u=np.squeeze(u)
    v=np.squeeze(v)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
#average across the time dimension
    u_seas=np.mean(u,axis=0)
    v_seas=np.mean(v,axis=0)
    
    
    plt.figure(0)
    ms='m/s'
    lontemp=lon
    titlename=expt+' winds:'+seasname
    u_seas,lon = shiftgrid(180.,u_seas,lon,start=False)    
    lon=lontemp
    v_seas,lon = shiftgrid(180.,v_seas,lon,start=False)    
    plotquiver(u_seas,v_seas,lon,lat,titlename,0,400,40.0,0.0,'n',ms)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()

    retdata=[u_seas, v_seas,lon,lat]

    return retdata

#end def seasmean


########################################################
def seasmean_height(m1,m2,m3,seasname,HadCM3,expt,extra,pressreq):
 
    import numpy as np
    print(pressreq)
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/netcdf/pcfiles/'
        filea=expt+'a@pc*'+m1+'.nc'
        fileb=expt+'a@pc*'+m2+'.nc'
        filec=expt+'a@pc*'+m3+'.nc'
        os.system('ls '+dirname+filea+' | wc -l')
        os.system('ls '+dirname+fileb+' | wc -l')
        os.system('ls '+dirname+filec+' | wc -l')
        print(dirname+filea)
        fa=MFDataset(dirname+filea)
        fb=MFDataset(dirname+fileb)
        fc=MFDataset(dirname+fileb)

        lat = fa.variables['latitude_1'][:]
        lon = fa.variables['longitude_1'][:]
        pressure=fa.variables['p'][:]
        au=fa.variables['u'][:]
        bu=fb.variables['u'][:]
        cu=fc.variables['u'][:]
        au=np.squeeze(au)
        bu=np.squeeze(bu)
        cu=np.squeeze(cu)


        av=fa.variables['v'][:]
        bv=fb.variables['v'][:]
        cv=fc.variables['v'][:]
        av=np.squeeze(av)
        bv=np.squeeze(bv)
        cv=np.squeeze(cv)
        ntimes,npress,ny,nx=np.shape(au)
      
        for press in range(0,len(pressure)):
            if pressure[press] == pressreq:
                u=au[:,press,:,:]+bu[:,press,:,:]+cu[:,press,:,:]
                v=av[:,press,:,:]+bv[:,press,:,:]+cv[:,press,:,:]

    u=np.squeeze(u)
    v=np.squeeze(v)
    
#average across the time dimension
    u_seas=np.mean(u,axis=0)
    v_seas=np.mean(v,axis=0)
    
    print('j1')
 
    plt.figure(0)
    ms='m/s'
    lontemp=lon
    titlename=expt+' winds:'+seasname
    u_seas,lon = shiftgrid(180.,u_seas,lon,start=False)    
    lon=lontemp
    v_seas,lon = shiftgrid(180.,v_seas,lon,start=False)    
    plotquiver(u_seas,v_seas,lon,lat,titlename,0,400,40.0,0.0,'n',ms)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+expt+'_'+np.str(np.int(pressreq))+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()

    retdata=[u_seas, v_seas,lon,lat]

    return retdata

#end def seasmean

##################################
def allseason_surf(exptname,extra,controlname,controlextra,HadCM3):
    #djf mean
    seasname='djf'
    retdata=seasmean('dc','ja','fb',seasname,HadCM3,exptname,extra)
    u_seas=retdata[0]
    v_seas=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # get djfmean from control
    retdata=seasmean('dc','ja','fb',seasname,HadCM3,controlname,controlextra)
    u_ctl=retdata[0]
    v_ctl=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # plot djf anomaly
    titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
    plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


    # do some contour plots of u and v for djf

    titlename='u: '+exptname
    contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+exptname
    contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='u: '+controlname
    contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+controlname
    contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='uanom'
    contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
    titlename='vanom'
    contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'u_and_v.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()



    #jja mean
    seasname='jja'
    retdata=seasmean('jn','jl','ag',seasname,HadCM3,exptname,extra)
    u_seas=retdata[0]
    v_seas=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # get jjamean from control
    retdata=seasmean('jn','jl','ag',seasname,HadCM3,controlname,controlextra)
    u_ctl=retdata[0]
    v_ctl=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # plot jja anomaly
    titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
    plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


    # do some contour plots of u and v for jja

    titlename='u: '+exptname
    contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+exptname
    contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='u: '+controlname
    contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+controlname
    contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='uanom'
    contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
    titlename='vanom'
    contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'u_and_v.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()

#


##################################
def allseason_height(exptname,extra,controlname,controlextra,HadCM3,pressreq):
    #djf mean
    seasname='djf'
    retdata=seasmean_height('dc','ja','fb',seasname,HadCM3,exptname,extra,pressreq)
    u_seas=retdata[0]
    v_seas=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # get djfmean from control
    retdata=seasmean_height('dc','ja','fb',seasname,HadCM3,controlname,controlextra,pressreq)
    u_ctl=retdata[0]
    v_ctl=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # plot djf anomaly
    titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
    plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'_'+np.str(np.int(pressreq))+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


    # do some contour plots of u and v for djf

    titlename='u: '+exptname
    contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+exptname
    contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='u: '+controlname
    contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+controlname
    contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='uanom'
    contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
    titlename='vanom'
    contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'_'+np.str(np.int(pressreq))+'_u_and_v.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()



    #jja mean
    seasname='jja'
    retdata=seasmean_height('jn','jl','ag',seasname,HadCM3,exptname,extra,pressreq)
    u_seas=retdata[0]
    v_seas=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # get jjamean from control
    retdata=seasmean_height('jn','jl','ag',seasname,HadCM3,controlname,controlextra,pressreq)
    u_ctl=retdata[0]
    v_ctl=retdata[1]
    lon=retdata[2]
    lat=retdata[3]

    # plot jja anomaly
    titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
    plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'_'+np.str(np.int(pressreq))+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


    # do some contour plots of u and v for jja

    titlename='u: '+exptname
    contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+exptname
    contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='u: '+controlname
    contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='v: '+controlname
    contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
    titlename='uanom'
    contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
    titlename='vanom'
    contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'+'+pressreq+'u_and_v.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


def zonalmean_ann_surf(exptname,controlname,extra,controlextra,HadCM3):
    # get experiment data
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+exptname+'_netcdf/'+exptname+'a@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/winds_data/'
        filename=exptname+'a@pd'+extra+'[7-9]*winds.nc'
        os.system('ls '+dirname+filename+' | wc -l')
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        # we will plot zonal wind 10 m winds (called)
        u=f.variables['u'][:]
     

    u=np.squeeze(u)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
    #average across the time dimension and longitude direction
    u_ann=np.mean(u,axis=0)
    u_zm_pi=np.mean(u_ann,axis=1)
   

  # get control data
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+controlname+'_netcdf/'+controlname+'a@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/winds_data/'
        filename=controlname+'a@pd'+extra+'[7-9]*winds.nc'
        os.system('ls '+dirname+filename+' | wc -l')
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        # we will plot zonal wind 10 m winds (called)
        u=f.variables['u'][:]
     

    u=np.squeeze(u)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
    #average across the time dimension and longitude direction
    u_ann=np.mean(u,axis=0)
    u_zm_plio=np.mean(u_ann,axis=1)
   
    # plot data

    plt.subplot(1,2,1)
    plt.plot(u_zm_pi,lat,label='preindustrial')
    plt.plot(u_zm_plio,lat,label='mPWP')
    plt.plot([0,0],[-90.,90.])
    plt.title('zonal mean u')
    plt.xlabel('m/s')
    plt.ylabel('latitude')
    plt.legend()
   
    plt.subplot(1,2,2)
    plt.plot(u_zm_plio-u_zm_pi,lat,label='mPWP-PI')
    plt.plot([0,0],[-90.,90.])
    plt.title('zm u_anom')
    plt.xlabel('m/s')
    plt.ylabel('latitude')
    plt.legend()

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/zonal_meanu_'+exptname+'-'+controlname+'_ann.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()
  
    #check for each month individually
    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    for i in range(0,len(monthnames)):
        if HadCM3 == 'y':
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+controlname+'_netcdf/'+controlname+'a@pdy[7-9]*.nc')
            lat = f.variables['latitude'][:]
            lon = f.variables['longitude'][:]
        else:
            #setup filename
            direxpt='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/winds_data/'
            dircntl='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/winds_data/'
            fileexpt=exptname+'a@pd'+extra+'[7-9]*'+monthnames[i]+'_winds.nc'
            filecntl=controlname+'a@pd'+extra+'[7-9]*'+monthnames[i]+'_winds.nc'

            # read data from experiment and control
            f=MFDataset(direxpt+fileexpt)
            lat = f.variables['latitude_1'][:]
            lon = f.variables['longitude_1'][:]
            u_ex=f.variables['u'][:]
            f.close()
            
            f=MFDataset(dircntl+filecntl)
            u_ctl=f.variables['u'][:]
            f.close()

            # average it
            u_ex=np.squeeze(u_ex)
            u_ann=np.mean(u_ex,axis=0)
            u_zm_ex=np.mean(u_ann,axis=1)
            u_ctl=np.squeeze(u_ctl)
            u_ann=np.mean(u_ctl,axis=0)
            u_zm_ct=np.mean(u_ann,axis=1)
  
            # plot it
     
            plt.subplot(1,2,1)
            plt.plot(u_zm_ct,lat,label='preindustrial')
            plt.plot(u_zm_ex,lat,label='mPWP')
            plt.plot([0,0],[-90.,90.])
            plt.title('zonal mean u '+monthnames[i])
            plt.xlabel('m/s')
            plt.ylabel('latitude')
            plt.legend()
   
            plt.subplot(1,2,2)
            plt.plot(u_zm_ex-u_zm_ct,lat,label='mPWP-PI')
            plt.plot([0,0],[-90.,90.])
            plt.title('zm u_anom')
            plt.xlabel('m/s')
            plt.ylabel('latitude')
            plt.legend()

          
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/zonal_meanu_'+exptname+'-'+controlname+'_'+monthnames[i]+'.eps' 
            plt.savefig(fileout, bbox_inches='tight')  
    
            plt.close()

    
   


#enddef zonalmean_ann


def zonalmean_ann_height(exptname,controlname,extra,controlextra,HadCM3,pressreq):
    # get experiment data
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+exptname+'_netcdf/'+exptname+'a@pcy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/netcdf/pcfiles/'
        filename=exptname+'a@pc'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename+' | wc -l')
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        pressure=f.variables['p'][:]
        # we will plot zonal wind 10 m winds (called)
        u=f.variables['u'][:]
    
    ntimes,npress,ny,nx=np.shape(u)
    print(ntimes,npress,ny,nx)
  
    for press in range(0,len(pressure)):
        if pressure[press] == pressreq:
            u_p=u[:,press,:,:]

    u=0
    
    #average across the time dimension and longitude direction
    u_ann=np.mean(u_p,axis=0)
    u_zm_pi=np.mean(u_ann,axis=1)
   

  # get control data
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+controlname+'_netcdf/'+controlname+'a@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/netcdf/pcfiles/'
        filename=controlname+'a@pc'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename+' | wc -l')
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        # we will plot zonal wind 10 m winds (called)
        u=f.variables['u'][:]
     

    for press in range(0,len(pressure)):
        if pressure[press] == pressreq:
            u_p=u[:,press,:,:]

    u_ann=np.mean(u_p,axis=0)
    u_zm_plio=np.mean(u_ann,axis=1)
   
    # plot data

    plt.subplot(1,2,1)
    plt.plot(u_zm_pi,lat,label='preindustrial')
    plt.plot(u_zm_plio,lat,label='mPWP')
    plt.plot([0,0],[-90.,90.])
    plt.title('zonal mean u')
    plt.xlabel('m/s')
    plt.ylabel('latitude')
    plt.legend()
   
    plt.subplot(1,2,2)
    plt.plot(u_zm_plio-u_zm_pi,lat,label='mPWP-PI')
    plt.plot([0,0],[-90.,90.])
    plt.title('zm u_anom')
    plt.xlabel('m/s')
    plt.ylabel('latitude')
    plt.legend()

   
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/zonal_meanu_'+exptname+'-'+controlname+'_'+np.str(pressreq)+'_ann.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()
  
    #check for each month individually
    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    for i in range(0,len(monthnames)):
        if HadCM3 == 'y':
            f=MFDataset('/nfs/hera1/earjcti/um/netcdf/'+controlname+'_netcdf/'+controlname+'a@pdy[7-9]*.nc')
            lat = f.variables['latitude'][:]
            lon = f.variables['longitude'][:]
        else:
            #setup filename
            direxpt='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/netcdf/pcfiles/'
            dircntl='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/netcdf/pcfiles/'
            fileexpt=exptname+'a@pc'+extra+'[7-9]*'+monthnames[i]+'.nc'
            filecntl=controlname+'a@pc'+extra+'[7-9]*'+monthnames[i]+'.nc'

            # read data from experiment and control
            f=MFDataset(direxpt+fileexpt)
            lat = f.variables['latitude_1'][:]
            lon = f.variables['longitude_1'][:]
            pressure=f.variables['p'][:]
            u_ex=f.variables['u'][:]
            f.close()
            
            f=MFDataset(dircntl+filecntl)
            u_ctl=f.variables['u'][:]
            f.close()

            for press in range(0,len(pressure)):
                if pressure[press] == pressreq:
                    u_p_ctl=u_ctl[:,press,:,:]
                    u_p_ex=u_ex[:,press,:,:]

            # average it
            u_ex=np.squeeze(u_p_ex)
            u_ann=np.mean(u_ex,axis=0)
            u_zm_ex=np.mean(u_ann,axis=1)
            u_ctl=np.squeeze(u_p_ctl)
            u_ann=np.mean(u_ctl,axis=0)
            u_zm_ct=np.mean(u_ann,axis=1)
  
            # plot it
     
            plt.subplot(1,2,1)
            plt.plot(u_zm_ct,lat,label='preindustrial')
            plt.plot(u_zm_ex,lat,label='mPWP')
            plt.plot([0,0],[-90.,90.])
            plt.title('zonal mean u '+monthnames[i])
            plt.xlabel('m/s')
            plt.ylabel('latitude')
            plt.legend()
   
            plt.subplot(1,2,2)
            plt.plot(u_zm_ex-u_zm_ct,lat,label='mPWP-PI')
            plt.plot([0,0],[-90.,90.])
            plt.title('zm u_anom')
            plt.xlabel('m/s')
            plt.ylabel('latitude')
            plt.legend()

          
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/zonal_meanu_'+exptname+'-'+controlname+'_'+monthnames[i]+'_'+np.str(np.int(pressreq))+'.eps' 
            plt.savefig(fileout, bbox_inches='tight')  
    
            plt.close()

    
   


#enddef zonalmean_ann_height


################################
# main program

# annual mean
figureno=0

HadCM3='n'
#exptname='ximuq'
#extra='l'

exptname='xkvjg'  #xkvje xkvjf xkvjg
extra='n'
controlname='xkvje'
controlextra='n'


#allseason_surf(exptname,extra,controlname,controlextra,HadCM3)

#zonalmean_ann_surf(exptname,controlname,extra,controlextra,HadCM3)

pressreq=200.
#zonalmean_ann_height(exptname,controlname,extra,controlextra,HadCM3,pressreq)
allseason_height(exptname,extra,controlname,controlextra,HadCM3,pressreq)






sys.exit(0)

####

::::::::::::::
prepare_files_for_charlie.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on Thu Mar 18 14:13:50 2019

#@author: earjcti1
#
# This program will extract the fields that charlie asked for
#
#
#

import os
import numpy as np
import scipy as sp
#import cf
import iris
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import netCDF4
from netCDF4 import Dataset, MFDataset
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.analysis.cartography
from iris.experimental.equalise_cubes import equalise_attributes
import sys
import warnings

warnings.filterwarnings("ignore")

def simplify_cube(cube):
    """
    gets cube and makes sure dimensions are longitude, latitude surface and
    t. 
    """    
    for coord in cube.coords():
        if coord.var_name == 'level275':
            coord.var_name = 'surface'
    
    cube.coord('surface').points = 0.0
    cube.coord('surface').units = 'm'
    cube.coord('surface').attributes = None
    
    cube.data = np.where(cube.data > 1.0E10, 0., cube.data)
    return cube

#####################################

 
def extract_fields(filestart,expt,startyear,endyear,varnamein):

    # load required cubes
    #cubes=iris.load(filename)
    #print(cubes)
    #sys.exit(0)
    monthnames=['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    
    
    # loop over years
    
   
    for year in range(startyear,endyear):
        stringyear=np.str(year).zfill(2)
        for mon in range(0,len(monthnames)):
            filename=(filestart + stringyear + monthnames[mon] + '_temp.nc')
            print(filename,varnamein)
            
            cube = iris.load_cube(filename, varnamein)
            allcubes.append(cube)
       
    print(allcubes)
    #make sure the metadata on all cubes are the same
    equalise_attributes(allcubes)
    catcube=allcubes.concatenate()
        
   
    return catcube

     
   

##########################################################
# main program

# this is regridding where all results are in a single file
# create a dictionary with the long field names in and the field names we want
# we are also using dictionaries so that we only have to change timeperiod name
# when rerunning
            
FIELEXTRA = {"TOTAL PRECIPITATION RATE     KG/M2/S" : "pd",
		"SURFACE TEMPERATURE AFTER TIMESTEP" : "pd",
        "POTENTIAL TEMPERATURE (OCEAN)  DEG.C" : "pf",
      	}

SHORTNAME = {
		"SURFACE TEMPERATURE AFTER TIMESTEP" : "SurfaceTemperature",
        "TOTAL PRECIPITATION RATE     KG/M2/S" : "TotalPrecipitation",
        "POTENTIAL TEMPERATURE (OCEAN)  DEG.C" : "SST",
  	}


#FIELDNAMES = [ "TOTAL PRECIPITATION RATE     KG/M2/S",
#               "SURFACE TEMPERATURE AFTER TIMESTEP",
#        "POTENTIAL TEMPERATURE (OCEAN)  DEG.C",
#       	]

FIELDNAMES = ["POTENTIAL TEMPERATURE (OCEAN)  DEG.C"]
	       
#fieldname=["V COMPNT OF WIND ON PRESSURE LEVELS"]

expt = 'xkvjg'
linux_win='l'
startyear=50
endyear=100


filestart='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/'

allcubes=iris.cube.CubeList([])
      

for i, varnamein in enumerate(FIELDNAMES):
    varnameout = SHORTNAME.get(varnamein)
    if varnameout == 'SST':
        filestart2 = filestart + 'temp_data/' + expt + 'o@pfn'
    if varnameout == 'TotalPrecipitation':
        filestart2 = filestart + 'precip_data/' + expt + 'a@pdn'
    if varnameout == 'SurfaceTemperature':
        filestart2 = filestart + '/netcdf/pdfiles/' + expt + 'a@pdn'
   
    print(varnameout, filestart2)
    cube = extract_fields(filestart2,expt,startyear,endyear, varnamein)

    fileout=('/nfs/hera1/earjcti/um/HadGEM_data/'
             +expt+'/'+expt+ '_' + varnameout + '_timeseries.nc')

    print(cube)
    iris.save(cube, fileout, fill_value=2.0E20)
    
#sys.exit(0)
