::::::::::::::
plot_Arctic_Osc.py
::::::::::::::
#all!/usr/bin/env python2.7
#NAME
#    PLOT_Arctic_Osc
#PURPOSE
#    This program will attempt to use principal component analysis to 
#    calculate the arctic oscillation (Northern Annular Mode) and
#    its  associated teleconnections
#
#    It is very strongly based on plot_NAO.py
#
# search for 'main program' to find end of functions
# Julia 6/1/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from  matplotlib.mlab import PCA 
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot AO index on a line graph
#  def fullprint  print full array for debugging
#  get_PC_allmonths   gets principal components and plots them (all data)
#  get_pc_seas  gets principal components for a given season

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(x),np.shape(y),np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

#===============================================================
def plotquiver(udata,vdata,lon,lat,fileno,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver



def indexplot(toplot,fileno,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt):
    plt.subplot(2,2,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    datasize=len(toplot)
    xdata=np.arange(datasize)
    
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='AO index '+expt
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint



#===============================================
def get_PC_allmonths(exptname):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E


    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    full_file_paths =  glob.glob("*a@pd*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    ntimes=nfiles
    if nfiles==0:
        print('there are no files in directory',dirname)
        sys.exit(0)


    # get the information from the files
    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

        mslp=f.variables['p'][:] 
        mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

        lon=lontemp
        mslp,lon = shiftgrid(180.,mslp,lon,start=False)

        ix1=lon
        ix2=(lat >=20) & (lat <=80)
        lats_reg=lat[ix2]
        lons_reg=lat[ix1]
        
        SLPint=mslp[ix2]
        MSLP=SLPint[:,ix1]

        MSLP=np.squeeze(MSLP)
        MSLP=MSLP/100. # convert to millibars
        
        latsize=len(lats_reg)
        lonsize=len(lons_reg)
        

        if count == 0:  # arrays for storing all data
           all_MSLP = np.empty((ntimes,latsize,lonsize)) #storing all data
           month_ss = np.zeros(ntimes)  # month indicator for all_MSLP
           month_MSLP=np.zeros((12,latsize,lonsize)) # for storing average month
           monthcount=np.zeros(12) # no of years for each month
 

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        if count == 0:
            yearstart=year
            monthstart=11 # assumed first month is december.  Will need
                          # to recode if not the case

        time=((year-yearstart)*12)+monthno-monthstart
        all_MSLP[time,:,:]=MSLP
        month_ss[time]=monthno
        month_MSLP[monthno,:,:]=month_MSLP[monthno,:,:]+MSLP
        monthcount[monthno]=monthcount[monthno]+1
        count=count+1


    # get all the averages
 
    # average annual cycle
    month_MSLP=month_MSLP/monthcount[:,np.newaxis,np.newaxis]


    # remove annual average from all_MSLP
    for t in range(0,ntimes):
        subscript=month_ss[t]
        all_MSLP[t,:,:]=all_MSLP[t,:,:]-month_MSLP[subscript,:,:]
    # subtract mean from each point
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))

    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lon_reg,lat_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lons,latsize*lonsize)

    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs))
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)

    #if EOFs[j,0] < 0.0:

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC v2 '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    plt.show()
    


#===============================================
def get_PC_seas(exptname,monthnames,extra,startyear,endyear):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E

    nmonths=len(monthnames)
    seasname=''  # get seasonname by using first letter of each month
    for mon in monthnames:
        seasname=seasname+mon[0]

    if nmonths > 4:
        print('check that you have accurately accounted for winter season overlap')
        sys.exit()

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    for year in range (startyear,endyear+1):
        for monthno in range (0,nmonths):
            yearuse=year
            extrause=extra
            month=monthnames[monthno]
            if month == 'dc' and nmonths > 1:
                yearuse=year-1
            if month == 'nv' and nmonths > 2:
                yearuse=year-1
            if month == 'ot' and nmonths > 3:
                yearuse=year-1
            if month == 'sp' and nmonths > 4:
                yearuse=year-1
            if yearuse >= 100:
                yearuse=yearuse-100
                extrause=chr(ord(extra)+1)

            if yearuse < 0:
                yearuse=yearuse+100
                extrause=chr(ord(extra)-1)

            yearfname=str(yearuse)

            if yearuse < 10:
                yearfname='0'+str(yearuse)

            fname=dirname+exptname+'a@pd'+extrause+yearfname+month+'_mslp.nc'
            print(fname)
            f=Dataset(fname,mode='r')
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

            mslp=f.variables['p'][:] 
            mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp north of 20N

            lon=lontemp
            mslp,lon = shiftgrid(180.,mslp,lon,start=False)

            ix2=(lat >=20)
            ix1=(lon > -1000)  # use all lons
            lats_reg=lat[ix2]
            lons_reg=lon
            
            SLPint=mslp[ix2]
            MSLP=SLPint[:,ix1]
            
            MSLP=np.squeeze(MSLP)
            MSLP=MSLP/100. # convert to millibars
 
            latsize=len(lats_reg)
            lonsize=len(lons_reg)
            
            if year == startyear and monthno == 0:  # arrays to store all data
                all_MSLP = np.zeros((ntimes,latsize,lonsize)) 
                

            all_MSLP[year-startyear,:,:]=all_MSLP[year-startyear,:,:]+MSLP
            # this is the end of the loop over years and months

           
           
    
    all_MSLP=all_MSLP/nmonths
   
    # remove average from MSLP
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    #plotdata(all_MSLP[0,:,:],0,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))


    #plotdata(all_MSLP[0,:,:],1,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')
    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lons_reg,lats_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lats,latsize*lonsize)

    rs_MSLP=np.transpose(rs_MSLP_nt)


    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs)) 
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)
    # check EOF1 has low (negative pressure over Iceland)
    lons,lats 
    ixuse=(lons == -18.75) & (lats == 65.)
    
    if EOFs[ixuse,0] >= 0:
        EOFs[:,0]=EOFs[:,0] * -1.0

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC'+str(i+1)+':'+exptname+'_'+seasname+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

#   write out the AO index to a file
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.txt' 
    f1=open(fileout,'w+')
    f1.write('nino index from PC1 of mslp in North Atlantic region \n')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra  year  AO index\n')
    for year in range (startyear,endyear+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-startyear,0])+'\n')
    f1.close()
        

#=========================================
def get_AO_seas_telecon(exptname,seasname,extra,startyear,endyear,monthnames,latname,lonname,fieldname,fieldlocation,fileext):
# this will plot the teleconnections associated with the AO by taking the
# most exteme 5% of the AO years and plotting the climate anomaly


    # read in the AO index

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/'+exptname+'_'+seasname+'.txt' 
    f=open(filein,'r')
    # discard titleline
    textline=f.readline()
    # get number of years from next line
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    c=b[0]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()



    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    AOindex=np.zeros(nyears)
    extremeindex=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and AOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        AOindex[count]=linesplit[2]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowdata=sorted(zip(AOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(AOindex,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)
    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+fieldlocation
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
         
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()

        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1


    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    lowdata=sorted(zip(AOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(AOindex,extraindex,yearindex),reverse=True)[:num_extr]

    # lowest and highest years
    for ex in range(0,2):
        # are we doing highest or lowest
        if ex == 0:
            extremedata=lowdata
        if ex == 1:
            extremedata=uppdata

        for time in range (0,num_extr):
            for monthno in range (0,nmonths):
                singleline=extremedata[time]
                yearuse=int(singleline[2])
                extrause=singleline[1]
                month=monthnames[monthno]
                if month == 'dc' and nmonths > 1:
                    yearuse=yearuse-1
                if month == 'nv' and nmonths > 2:
                    yearuse=yearuse-1
                if month == 'ot' and nmonths > 3:
                    yearuse=yearuse-1
                if month == 'sp' and nmonths > 4:
                    yearuse=yearuse-1
                if yearuse >= 100:
                    yearuse=yearuse-100
                    extrause=chr(ord(extrause)+1)
                                    
                if yearuse < 0:
                    yearuse=yearuse+100
                    extrause=chr(ord(extrause)-1)
                                        
                yearfname=str(yearuse)

                if yearuse < 10:
                    yearfname='0'+str(yearuse)

                fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                f=Dataset(fname,mode='r')
                lat = f.variables[latname][:]
                latsize=len(lat)
                lon = f.variables[lonname][:]
                lonsize=len(lon)
                lontemp=lon

                if len(fieldname) ==1 :
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)

                if len(fieldname) == 2:
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)
                    atemp2=f.variables[fieldname[1]][:]
                    atemp2=np.squeeze(atemp2)
        
                if len(fieldname) > 2:
                    print('you are requesting too many variables')
                    sys.exit()
    

                # set array for storing average
                if monthno == 0 and time == 0:
                    temp_extreme=atemp
                    temp2_extreme=0.
                    if len(fieldname)==2:
                        temp2_extreme=atemp2
                    count=1
                else:
                    temp_extreme=temp_extreme+atemp
                    if len(fieldname)==2:
                        temp2_extreme=temp2_extreme+atemp2
                    count=count+1

        # put temperature data in lower or higher catogry
        if ex == 0:
            temp_low=temp_extreme/count
            temp2_low=temp2_extreme/count
        if ex == 1:
            temp_high=temp_extreme/count
            temp2_high=temp2_extreme/count


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low,lon = shiftgrid(180.,temp_low,lon,start=False)    
    lon=lontemp
    temp_high,lon = shiftgrid(180.,temp_high,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    
    

    if fieldname[0] == 'temp_1':  # temperature data
        titlename=exptname+' low seas temp'
        plotdata(temp_low-273.15,0,lon,lat,titlename,-40.0,40.0,10.0,0,'n','degC')
        plotdata(temp_high-273.15,1,lon,lat,'high seas temp',-40.0,40.0,10.0,0,'n','degC')

        plotdata(temp_low-temp_avg,2,lon,lat,'low seas Tanom',-5.0,6.0,1.0,0,'n','degC')
        plotdata(temp_high-temp_avg,3,lon,lat,'high seas Tanom',-5.0,6.0,1.0,0,'n','degC')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_temp'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotdata(temp_low*60.*60.*24.*30.,0,lon,lat,titlename,-0,275,25,0,'n','mm/month')
        plotdata(temp_high*60.*60.*24.*30.,1,lon,lat,'high seas temp',0,275,25,0,'n','mm/month')

        plotdata((temp_low-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low seas panom',-50,50,15,0,'n','mm/month')
        plotdata((temp_high-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high seas panom',-50,50,10,0,'n','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
        # if precip also do percentage change
        pcent_low=((temp_low-temp_avg)/temp_avg)*100.
        pcent_high=((temp_high-temp_avg)/temp_avg)*100.
        titlename=exptname+' low seas precip anom'
        plotdata(pcent_low,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotdata(pcent_high,1,lon,lat,'high seas Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'p': # mean slp data
        titlename=exptname+' low seas mslp'
        plotdata(temp_low/100.,0,lon,lat,titlename,980,1040,10.0,0,'n','mbar')
        plotdata(temp_high/100.,1,lon,lat,'high seas mslp',980,1040,10.0,0,'n','mbar')

        plotdata((temp_low-temp_avg)/100.,2,lon,lat,'low seas mslp',-5.0,6.0,1.0,0,'n','mbar')
        plotdata((temp_high-temp_avg)/100.,3,lon,lat,'high seas mslp',-5.0,6.0,1.0,0,'n','mbar')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_mslp'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_Arctic_Osc/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
        

################################
# main program

figureno=0

#==================================
# get annual PC

#get_PC_allmonths('xkvjc')


#=================================
# get seasonal PC
monthnames=['dc','ja','fb','mr']
get_PC_seas('xkvje',monthnames,'n',1,100)
get_PC_seas('xkvjf',monthnames,'n',1,100)
get_PC_seas('xkvjg',monthnames,'n',1,100)



#=====================================
# get seasonal teleconnections

monthnames=['dc','ja','fb','mr']
seasname='djfm'
# note monthnames is the month of the climate variable, seasonnames is the 
# season that the AO index is calculated over

# temperature
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')

# winds
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')


# precipitation
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')

# mslp
#get_AO_seas_telecon('xkvja',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
#get_AO_seas_telecon('xkvjb',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
#get_AO_seas_telecon('xkvjc',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')


sys.exit(0)

####

::::::::::::::
plot_MOC.py
::::::::::::::

#!/usr/bin/env python2.7
#NAME
#    PLOT_MOC
#PURPOSE
#    This program will do some plots on the MOC (which were calculated in the 
#    ~earjcti/MOC directory
#
# search for 'main program' to find end of functions
# Julia 14/1/2017



import os
import numpy as np
import scipy as sp
import scipy.signal as sig
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize



#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,V,uselog,cbarname,pcplot):
    lats, depths = np.meshgrid(lat,dep)

    if pcplot == 'avg':
        plt.subplot(1,1,1)
    else:
        if pcplot == 'pc':
            plt.subplot(2,2,fileno+1)
        else:
            plt.subplot(5,2,fileno+1)

    V=np.arange(minval,maxval,valinc)
    if pcplot =='pc':
        cs = plt.contourf(lats,depths,plotdata,V,cmap='RdBu_r',extend='both')
    else:
        cs = plt.contourf(lats,depths,plotdata,V,extend='both')
    plt.gca().invert_yaxis()
    plt.title(titlename)

    if pcplot != 'n' or fileno >9:
        cbar = plt.colorbar(cs,orientation="horizontal")
        cbar.set_label(cbarname,labelpad=-40)



#end def plotdata

def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                if uselog =='at':
                    cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")
                else:
                    print(np.shape(x),np.shape(y),np.shape(plotdata))
                    cs = map.contourf(x,y,plotdata,V,extend='both')
                    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotmap


def indexplot(toplot,xdata,fileno,data_sm,xmin,xmax,expt,xlabel,ymin,ymax,titlename):
    plt.subplot(4,2,fileno*2)
    print(fileno)

    plt.xlim([xmin,xmax])
    plt.ylim([ymin,ymax])
    datasize=len(toplot)

    
    # plot data
    plt.plot(xdata,toplot)
    plt.title(titlename)
    plt.xlabel(xlabel)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

##################################################
def plot_avg_moc(expt_name,extra,yearstart,yearend):

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)
        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))

        allAMOC[year-yearstart,:,:]=AMOC
        f.close()

    avgAMOC=np.mean(allAMOC,axis=0)
    print(np.shape(avgAMOC))
    titlename='AMOC avg: '+expt_name
    plotdata(avgAMOC,-99,lat,depth,titlename,-18,20,2.0,0.0,'n','Sv','avg')
        
    plt.tight_layout()
    plt.show()
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_avg.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    
    return(lat,depth,avgAMOC)
    
    
#end def plot_avg_MOC
#======================================================
def amoc_diff(expt_name,cntl_name,AMOC_e,AMOC_c,lat,depth):
# this function will difference two AMOCs
    AMOC_diff=AMOC_e-AMOC_c
    titlename='diff '+expt_name+'  and '+cntl_name
    plotdata(AMOC_diff,-99,lat,depth,titlename,-4,5,1.0,0.0,'n','Sv','avg')
    plt.tight_layout()
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'-'+cntl_name+'_avg.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    
#end def amoc_diff
#==========================================
def plot_all_moc(expt_name,extra,yearstart,yearend,plotallyears):

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)

        if plotallyears == 'y':
            titlename='AMOC yr:'+str(year)
            plotdata(AMOC,figcount,lat,depth,titlename,-30,30,5.0,0.0,'n','Sv')
            if figcount == 9:
                plt.tight_layout()
                plt.show()
                sys.exit()
            figcount=(figcount+1)%10
          
        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))

        allAMOC[year-yearstart,:,:]=AMOC
        f.close()
    

    sys.exit()
    
    
#end def plot_all_MOC
#######################################
# do principal component analysis to find the periods over which the MOC varies
def MOC_PC(expt_name,extra,yearstart,yearend):

# read in data

    nyears=yearend-yearstart+1
    figcount=0
    for year in range(yearstart,yearend+1):
        if year >= 10:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+str(year)+'c1.nc'
        else:
            datasetname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pk2/'+expt_name+'o@pg'+extra+'0'+str(year)+'c1.nc'
        f=Dataset(datasetname)
        lat = f.variables['latitude'][:]
        depth = f.variables['depth'][:]
        ndepth=len(depth)
        nlat=len(lat)
        AMOC=f.variables['Merid_Atlantic'][:]
        AMOC=np.squeeze(AMOC)

        # mask out region south of equator
        ix1=(lat >=0)
        lats_reg=lat[ix1]
        nlat=len(lats_reg)
        lat=lats_reg
        AMOC=AMOC[:,ix1]
    

        if year == yearstart:
            allAMOC=np.zeros((nyears,ndepth,nlat))
            
        print(yearend-yearstart,year-yearstart,nyears)
        allAMOC[year-yearstart,:,:]=AMOC
        f.close()


    

  
    # remove time average from all AMOC 
    for j in range(0,nlat):
        for i in range(0,ndepth):
            allAMOC[:,i,j]=allAMOC[:,i,j]-np.mean(allAMOC[:,i,j])
    
    # ideally we will need to multiply by a weighting factor to account for the fact that all latitudes have a different number of gridboxes at different sizes


    # reshape and transpose the data to the correct dimension
    print('amoc shape',np.shape(allAMOC),nlat,ndepth,nyears)
    rs_allAMOC_nt=np.reshape(allAMOC,(nyears,nlat*ndepth))
    rs_allAMOC=np.transpose(rs_allAMOC_nt)

    # do a PC analysis using sklearn
    neofs=2
    AMOCpca=sk.PCA(n_components=neofs)
    AMOCpca.fit(rs_allAMOC)
    expl_var=AMOCpca.explained_variance_ratio_
    EOFs=AMOCpca.transform(rs_allAMOC)
    
    # scale so each EOF has unit length
    EOFs=normalize(EOFs,axis=0)

    # get principal components
    PCs=np.mat(rs_allAMOC_nt) * np.mat(EOFs)

    for i in range(0,neofs):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(ndepth,nlat))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc
        
        titlename='PC'+str(i+1)+':'+expt_name+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lat,depth,titlename,-2.0,2.2,0.2,0,'n','Sv','pc')
        
        toplot=PCs[:,i]
        datasize=len(toplot)
        xdata=np.arange(datasize)
        indexplot(toplot,xdata,(2*i)+1,toplot,0,nyears,expt_name,'year',-2.0,2.0,'index')

        # do a spectral analysis on the index
        # to see over which periods it is varying

        print('toplot is',toplot)
        toplot=np.squeeze(toplot)

        Pxx_f, Pxx_den=sig.periodogram(toplot,1.0)
        Pxx_den=np.squeeze(Pxx_den)
        print('PXx',Pxx_f,'size',np.shape(Pxx_f),np.shape(toplot))
        print('pxx2',Pxx_den,'size',np.shape(Pxx_den))
        indexplot(Pxx_den,Pxx_f,(2*i)+2,Pxx_den,0,0.5,expt_name,'cycles per year',0,10,'index power spectrun')
        

    plt.tight_layout()
  
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_PCs.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


#  write both indexes out to a file

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+expt_name+'_PCs.txt' 
    f1=open(fileout,'w+')
    f1.write('strength of principal components')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra year  PC1    PC2 \n')
    for year in range (yearstart,yearend+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        print(year,yearstart,yearend,np.shape(PCs))
        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-yearstart,0])+';'+str(PCs[year-yearstart,1])+'\n')
    f1.close()
        


# 

#end def annmean

# relate principal components to climate
def PCs_to_climate_telecon(exptname,fieldlocation,fileext,fieldname,seasname,monthnames,lonname,latname):
 
# this will plot the teleconnections associated with the MOC principal 
# components by taking the
# most exteme 5% of the MOC years and plotting the climate anomaly


    # read in the MOC principal components

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/'+exptname+'_PCs.txt' 
    f=open(filein,'r')
    # get titleline which contains number of years
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    print(b)
    c=b[3]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()

   
    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    PC1index=np.zeros(nyears)
    PC2index=np.zeros(nyears)
    extremePC1=np.zeros(nyears)  # here we mark the 5% most extreme values
    extremePC2=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and NAOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        PC1index[count]=linesplit[2]
        PC2index[count]=linesplit[3]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowPC1=sorted(zip(PC1index,extraindex,yearindex))[:num_extr]
    uppPC1=sorted(zip(PC1index,extraindex,yearindex),reverse=True)[:num_extr]
    lowPC2=sorted(zip(PC2index,extraindex,yearindex))[:num_extr]
    uppPC2=sorted(zip(PC2index,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/'+fieldlocation+'/'
    os.chdir(dirname)

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        print(allfiles)
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()
        f.close()
        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1

                

    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    for ex in range(0,2):     # loop for lowest or highest year
        for npcs in range (0,2):   # we will have to loop over PCS
            if ex == 0:
                if npcs == 0: 
                    extremedata=lowPC1
                if npcs == 1:
                    extremedata=lowPC2
            if ex == 1:
                if npcs == 0:
                    extremedata=uppPC1
                if npcs == 1:
                    extremedata=uppPC2


            for time in range (0,num_extr):
                for monthno in range (0,nmonths):
                    singleline=extremedata[time]
                    yearuse=int(singleline[2])
                    extrause=singleline[1]
                    month=monthnames[monthno]

                    if seasname == 'djf-1' and month == 'dc':
                        yearuse=yearuse-1

                    if seasname == 'djf+1' and month == 'ja':
                        yearuse=yearuse+1

                    if seasname == 'djf+1' and month == 'fb':
                        yearuse=yearuse+1

                    if yearuse >= 100:
                        yearuse=yearuse-100
                        extrause=chr(ord(extrause)+1)
                                    
                    if yearuse < 0:
                        yearuse=yearuse+100
                        extrause=chr(ord(extrause)-1)
                                        
                    yearfname=str(yearuse)

                    if yearuse < 10:
                        yearfname='0'+str(yearuse)
                        

                    fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                    f=Dataset(fname,mode='r')
                    lat = f.variables[latname][:]
                    latsize=len(lat)
                    lon = f.variables[lonname][:]
                    lonsize=len(lon)
                    lontemp=lon

                    if len(fieldname) ==1 :
                        atemp=f.variables[fieldname[0]][:]
                        atemp=np.squeeze(atemp)

                    if len(fieldname) == 2:
                        atemp=f.variables[fieldname[0]][:]
                        atemp=np.squeeze(atemp)
                        atemp2=f.variables[fieldname[1]][:]
                        atemp2=np.squeeze(atemp2)
                        
                    if len(fieldname) > 2:
                        print('you are requesting too many variables')
                        sys.exit()
    

                    # set array for storing average
                    if monthno == 0 and time == 0:
                        temp_extreme=atemp
                        count=1
                        count2=1
                        temp2_extreme=0.
                        if len(fieldname)==2:
                            temp2_extreme=atemp2
                    else:
                        temp_extreme=temp_extreme+atemp
                        count=count+1
                        if len(fieldname)==2:
                            temp2_extreme=temp2_extreme+atemp2
                            count2=count2+1

            # put temperature data in lower or higher catogry
            if ex == 0:
                if npcs == 0: 
                    temp_low_PC1=temp_extreme/count
                    temp2_low_PC1=temp2_extreme/count2
                if npcs == 1: 
                    temp_low_PC2=temp_extreme/count
                    temp2_low_PC2=temp2_extreme/count2
            if ex == 1:
                if npcs == 0: 
                    temp_high_PC1=temp_extreme/count
                    temp2_high_PC1=temp2_extreme/count2
                if npcs == 1: 
                    temp_high_PC2=temp_extreme/count
                    temp2_high_PC2=temp2_extreme/count2


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low_PC1,lon = shiftgrid(180.,temp_low_PC1,lon,start=False)    
    lon=lontemp
    temp_high_PC1,lon = shiftgrid(180.,temp_high_PC1,lon,start=False)    
    lon=lontemp
    temp_low_PC2,lon = shiftgrid(180.,temp_low_PC2,lon,start=False)    
    lon=lontemp
    temp_high_PC2,lon = shiftgrid(180.,temp_high_PC2,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    



    if fieldname[0] == 'temp_1':  # temperature data
        plotmap(temp_low_PC1-temp_avg,0,lon,lat,'low PC1 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_high_PC1-temp_avg,1,lon,lat,'high PC1 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_low_PC2-temp_avg,2,lon,lat,'low PC2 Tanom',-2.0,2.2,0.2,0,'at','degC')
        plotmap(temp_high_PC2-temp_avg,3,lon,lat,'high PC2 Tanom',-2.2,2.0,0.2,0,'at','degC')
       

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_tempanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.show()
        plt.close()


        titlename=exptname+' low seas temp'
        plotmap(temp_low_PC1-273.15,0,lon,lat,'low PC1 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_high_PC1-273.15,1,lon,lat,'high PC1 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_low_PC2-273.15,2,lon,lat,'low PC2 temp',-40.0,40.0,10.0,0,'n','degC')
        plotmap(temp_high_PC2-273.15,3,lon,lat,'high PC2 temp',-40.0,40.0,10.0,0,'n','degC')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_temp'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()

    


      


    if fieldname[0] == 'p':  # mean se level pressure data
        plotmap((temp_low_PC1-temp_avg)/100.,0,lon,lat,'low PC1 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_high_PC1-temp_avg)/100.,1,lon,lat,'high PC1 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_low_PC2-temp_avg)/100.,2,lon,lat,'low PC2 mslp anom',-5.,6.,1.,0,'at','hPa')
        plotmap((temp_high_PC2-temp_avg)/100.,3,lon,lat,'high PC2 mslp anom',-5.,6.,1.,0,'at','hPa')
       

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_mslpanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        plt.close()

        plotmap(temp_low_PC1/100.,0,lon,lat,'low PC1 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_high_PC1/100.,1,lon,lat,'high PC1 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_low_PC2/100.,2,lon,lat,'low PC2 mslp',980.,1040.,5,0,'n','hPa')
        plotmap(temp_high_PC2/100.,3,lon,lat,'high PC2 mslp',980.,1040.,5,0,'n','hPa')


        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_PCs_mslp_'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight') 
        plt.show()
        plt.close()

    


       

    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotmap(temp_low_PC1*60.*60.*24.*30.,0,lon,lat,'low PC1 precip',-0,275,25,0,'n','mm/month')
        plotmap(temp_high_PC1*60.*60.*24.*30.,1,lon,lat,'high PC1 precip',0,275,25,0,'n','mm/month')
        plotmap(temp_low_PC2*60.*60.*24.*30.,2,lon,lat,'low PC2 precip',-0,275,25,0,'n','mm/month')
        plotmap(temp_high_PC2*60.*60.*24.*30.,3,lon,lat,'high PC2 precip',0,275,25,0,'n','mm/month')

        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()


        plotmap((temp_low_PC1-temp_avg)*60.*60.*24.*30.,0,lon,lat,'low PC1 panom',-30,35,5,0,'a','mm/month')
        plotmap((temp_high_PC1-temp_avg)*60.*60.*24.*30.,1,lon,lat,'high PC1 panom',-30,35,5,0,'a','mm/month')

        plotmap((temp_low_PC2-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low PC2 panom',-30,35,5,0,'a','mm/month')
        plotmap((temp_high_PC2-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high PC2 panom',-30,35,5,0,'a','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precipanom'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()

        # if precip also do percentage change
        pcent_low_PC1=((temp_low_PC1-temp_avg)/temp_avg)*100.
        pcent_high_PC1=((temp_high_PC1-temp_avg)/temp_avg)*100.
        pcent_low_PC2=((temp_low_PC2-temp_avg)/temp_avg)*100.
        pcent_high_PC2=((temp_high_PC2-temp_avg)/temp_avg)*100.
        titlename=exptname+' low PC1 precip anom'
        plotmap(pcent_low_PC1,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotmap(pcent_high_PC1,1,lon,lat,'high PC1 Precip anomaly',-50,60,5,0,'a','%')
        plotmap(pcent_low_PC2,2,lon,lat,'low PC2 precip anomaly',-50,60,5,0,'a','%')
        plotmap(pcent_high_PC2,3,lon,lat,'high PC2 Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_MOC/teleconnections_PC/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
 
#end def PCs_to_climate

################################
# main program


##################################
# plot average of the MOC

#retdata=plot_avg_moc('xkvje','n',1,99)
#lat=retdata[0]
#depth=retdata[1]
#xkvje_AMOC=retdata[2]

#retdata=plot_avg_moc('xkvjf','n',1,98)
#xkvjf_AMOC=retdata[2]

#retdata=xkvjg_AMOC=plot_avg_moc('xkvjg','n',1,99)
#xkvjg_AMOC=retdata[2]

################################################
# difference of two AMOCs
#amoc_diff('xkvjg','xkvje',xkvjg_AMOC,xkvje_AMOC,lat,depth)
#amoc_diff('xkvjf','xkvje',xkvjf_AMOC,xkvje_AMOC,lat,depth)


##################################################
# plot all years of the MOC

#plt.figure(figureno)
#plotallyears='y'
#plot_all_moc('xkvjg','n',1,99,plotallyears)
#figureno=figureno+1

###########################################################################
# Principal component analysis to determine periods of variability in the MOC

#MOC_PC('xkvje','n',1,98)
#MOC_PC('xkvjg','n',1,98)

#############################################################
# Relate extreme values of PC's to climate


# usage Pcs_to_climate(expt_name',dirname,fileextension,fieldname,monthnames)
PCs_to_climate_telecon('xkvjg','temp_data','_temp.nc',['temp_1'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')

PCs_to_climate_telecon('xkvjg','precip_data','_precip.nc',['precip_1'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')

PCs_to_climate_telecon('xkvjg','mslp_data','_mslp.nc',['p'],'djf+1',\
            ['dc','ja','fb'],\
            'longitude','latitude')





sys.exit(0)

####

::::::::::::::
plot_NAO.py
::::::::::::::
#all!/usr/bin/env python2.7
#NAME
#    PLOT_NAO
#PURPOSE
#    This program will attempt to use principal component analysis to 
#    calculate the NAO and associated diagnostics
#
# search for 'main program' to find end of functions
# Julia 15/12/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from  matplotlib.mlab import PCA 
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob
import sklearn.decomposition as sk
from sklearn.preprocessing import normalize

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot NAO index on a line graph
#  def fullprint  print full array for debugging
#  get_PC_allmonths   gets principal components and plots them (all data)
#  get_pc_seas  gets principal components for a given season

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a NAO region
   # map=Basemap(width=12000000,height=8000000,projection='stere',\
   #                 resolution='c',lat_ts=50,lat_0=50,lon_0=0)
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(x),np.shape(y),np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

#===============================================================
def plotquiver(udata,vdata,lon,lat,fileno,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver



def indexplot(toplot,fileno,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt):
    plt.subplot(2,2,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    datasize=len(toplot)
    xdata=np.arange(datasize)
    
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='NAO index '+expt
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(datasize))
    #bar_width=1.0/12.0
    #plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    #plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 

# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint



#===============================================
def get_PC_allmonths(exptname):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E


    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    full_file_paths =  glob.glob("*a@pd*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    ntimes=nfiles
    if nfiles==0:
        print('there are no files in directory',dirname)
        sys.exit(0)


    # get the information from the files
    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

        mslp=f.variables['p'][:] 
        mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

        lon=lontemp
        mslp,lon = shiftgrid(180.,mslp,lon,start=False)

        ix1=(lon >=-90) & (lon <=40)
        ix2=(lat >=20) & (lat <=80)
        lats_reg=lat[ix2]
        lons_reg=lon[ix1]
        
        SLPint=mslp[ix2]
        MSLP=SLPint[:,ix1]

        MSLP=np.squeeze(MSLP)
        MSLP=MSLP/100. # convert to millibars
        
        latsize=len(lats_reg)
        lonsize=len(lons_reg)
        

        if count == 0:  # arrays for storing all data
           all_MSLP = np.empty((ntimes,latsize,lonsize)) #storing all data
           month_ss = np.zeros(ntimes)  # month indicator for all_MSLP
           month_MSLP=np.zeros((12,latsize,lonsize)) # for storing average month
           monthcount=np.zeros(12) # no of years for each month
 

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        if count == 0:
            yearstart=year
            monthstart=11 # assumed first month is december.  Will need
                          # to recode if not the case

        time=((year-yearstart)*12)+monthno-monthstart
        all_MSLP[time,:,:]=MSLP
        month_ss[time]=monthno
        month_MSLP[monthno,:,:]=month_MSLP[monthno,:,:]+MSLP
        monthcount[monthno]=monthcount[monthno]+1
        count=count+1


    # get all the averages
 
    # average annual cycle
    month_MSLP=month_MSLP/monthcount[:,np.newaxis,np.newaxis]


    # remove annual average from all_MSLP
    for t in range(0,ntimes):
        subscript=month_ss[t]
        all_MSLP[t,:,:]=all_MSLP[t,:,:]-month_MSLP[subscript,:,:]
    # subtract mean from each point
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))

    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lon_reg,lat_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lons,latsize*lonsize)

    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs))
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)

    #if EOFs[j,0] < 0.0:

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC v2 '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    plt.show()
    


#===============================================
def get_PC_seas(exptname,monthnames,extra,startyear,endyear):
# this subroutine will use the Hurrell method. 
# PC analysis SLP anomalies 20-80N, 90-40E

    nmonths=len(monthnames)
    seasname=''  # get seasonname by using first letter of each month
    for mon in monthnames:
        seasname=seasname+mon[0]

    if nmonths > 4:
        print('check that you have accurately accounted for winter season overlap')
        sys.exit()

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/mslp_data/'
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    for year in range (startyear,endyear+1):
        for monthno in range (0,nmonths):
            yearuse=year
            extrause=extra
            month=monthnames[monthno]
            if month == 'dc' and nmonths > 1:
                yearuse=year-1
            if month == 'nv' and nmonths > 2:
                yearuse=year-1
            if month == 'ot' and nmonths > 3:
                yearuse=year-1
            if month == 'sp' and nmonths > 4:
                yearuse=year-1
            if yearuse >= 100:
                yearuse=yearuse-100
                extrause=chr(ord(extra)+1)

            if yearuse < 0:
                yearuse=yearuse+100
                extrause=chr(ord(extra)-1)

            yearfname=str(yearuse)

            if yearuse < 10:
                yearfname='0'+str(yearuse)

            
            fname=dirname+exptname+'a@pd'+extrause+yearfname+month+'_mslp.nc'
            print(fname)

            f=Dataset(fname,mode='r')
            lat = f.variables['latitude'][:]
            latsize=len(lat)
            lon = f.variables['longitude'][:]
            lonsize=len(lon)
            lontemp=lon

            mslp=f.variables['p'][:] 
            mslp=np.squeeze(mslp)
       
# mask out all data so that we just have the mslp from 20-80N and 90W-40E

            lon=lontemp
            mslp,lon = shiftgrid(180.,mslp,lon,start=False)

            ix1=(lon >=-90) & (lon <=40)
            ix2=(lat >=20) & (lat <=80)
            lats_reg=lat[ix2]
            lons_reg=lon[ix1]
            
            SLPint=mslp[ix2]
            MSLP=SLPint[:,ix1]
            
            MSLP=np.squeeze(MSLP)
            MSLP=MSLP/100. # convert to millibars
 
            latsize=len(lats_reg)
            lonsize=len(lons_reg)
            
            if year == startyear and monthno == 0:  # arrays to store all data
                all_MSLP = np.zeros((ntimes,latsize,lonsize)) 
                

            all_MSLP[year-startyear,:,:]=all_MSLP[year-startyear,:,:]+MSLP
            # this is the end of the loop over years and months

           
           
    
    all_MSLP=all_MSLP/nmonths
   
    # remove average from MSLP
    for i in range(0,lonsize):
        for j in range(0,latsize):
            all_MSLP[:,j,i]=all_MSLP[:,j,i]-np.mean(all_MSLP[:,j,i])

    #plotdata(all_MSLP[0,:,:],0,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')

    # multiply by a weighting factor because all of the gridboxes are a 
    # different size
    for j in range(0,latsize):
        all_MSLP[:,j,:]=all_MSLP[:,j,:] * np.cos(np.radians(lats_reg[j]))


    #plotdata(all_MSLP[0,:,:],1,lons_reg,lats_reg,'test1',-4.0,4.0,1.0,0,'n','test2')
    # reshape and transpose the data to the correct dimension
    rs_MSLP_nt=np.reshape(all_MSLP,(ntimes,latsize*lonsize))
    lons, lats = np.meshgrid(lons_reg,lats_reg)
    lons=np.reshape(lons,latsize*lonsize)
    lats=np.reshape(lats,latsize*lonsize)

    rs_MSLP=np.transpose(rs_MSLP_nt)


    # have a go at pcanalysis using sklearn

    neofs=2
    altpca=sk.PCA(n_components=neofs)
    altpca.fit(rs_MSLP)
    expl_var=altpca.explained_variance_ratio_
    EOFs=altpca.transform(rs_MSLP)
    print(np.shape(EOFs)) 
    print('b4 pc shape',np.shape(rs_MSLP),np.shape(EOFs))

    # scale so each EOF has a unit length
    EOFs=normalize(EOFs,axis=0)
    # check EOF1 has low (negative pressure over Iceland)
    lons,lats 
    ixuse=(lons == -18.75) & (lats == 65.)
    
    if EOFs[ixuse,0] >= 0:
        EOFs[:,0]=EOFs[:,0] * -1.0

    PCs=np.mat(rs_MSLP_nt) * np.mat(EOFs)
    print('pc shape',np.shape(PCs),np.shape(rs_MSLP),np.shape(EOFs))

   
    for i in range(0,2):
        EOF_temp=EOFs[:,i]
        EOF_plot=np.reshape(EOF_temp,(latsize,lonsize))
        stdevpc=np.std(PCs[:,i])
        PCs[:,i]=PCs[:,i]/stdevpc
        EOF_plot=EOF_plot * stdevpc

        titlename='PC'+str(i+1)+':'+exptname+'_'+seasname+' '+str(np.ceil(expl_var[i]*100.))+'%'
        plotdata(EOF_plot,(i*2),lons_reg,lats_reg,titlename,-4.0,4.0,1.0,0,'n',titlename)

        toplot=PCs[:,i]
        indexplot(toplot,(2*i)+1,toplot,toplot,toplot,0,ntimes,exptname)
    
    
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

#   write out the NAO index to a file
    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.txt' 
    f1=open(fileout,'w+')
    f1.write('nino index from PC1 of mslp in North Atlantic region \n')
    f1.write('nyears='+str(nyears)+' \n')
    f1.write('extra  year  NAO index\n')
    for year in range (startyear,endyear+1):
        yearuse=year
        extrause=extra
        if yearuse >= 100:
            yearuse=yearuse-100
            extrause=chr(ord(extra)+1)

        if yearuse < 0:
            yearuse=yearuse+100
            extrause=chr(ord(extra)-1)

        yearfname=str(yearuse)

        if yearuse < 10:
            yearfname='0'+str(yearuse)

        f1.write(extrause+';'+str(yearfname)+';'+str(PCs[year-startyear,0])+'\n')
    f1.close()
        

#=========================================
def get_NAO_seas_telecon(exptname,seasname,extra,startyear,endyear,monthnames,latname,lonname,fieldname,fieldlocation,fileext):
# this will plot the teleconnections associated with the NAO by taking the
# most exteme 5% of the NAO years and plotting the climate anomaly


    # read in the NAO index

    filein='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/'+exptname+'_'+seasname+'.txt' 
    f=open(filein,'r')
    # discard titleline
    textline=f.readline()
    # get number of years from next line
    textline=f.readline()
    b=textline.split()  # split text by removing newline
    c=b[0]
    b=c.split('=')  # split text by removing equals sign
    nyears=int(b[1])
    # discard second titleline
    textline=f.readline()



    # read over the rest of the data
    extraindex=np.empty(nyears,dtype=np.dtype('S1'))
    yearindex=np.zeros(nyears)
    NAOindex=np.zeros(nyears)
    extremeindex=np.zeros(nyears)  # here we mark the 5% most extreme values
    

    count=0
    for line in f:
        # extract extra year and NAOindex
        linesplit=line.split(';')   # the data in the file is split by ;
        extraindex[count]=linesplit[0]
        yearindex[count]=linesplit[1]
        NAOindex[count]=linesplit[2]
        count=count+1


    # next we want to find the years that have the largest positive and negative
    # nao index

    num_extr=int(np.ceil(nyears*0.05))

    # get highest 5 values.
    # note that 'zip' zips the arrays together forming a multi dim list
    # sort sorts the list on the first element
    # reverse will reverse the sort
    lowdata=sorted(zip(NAOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(NAOindex,extraindex,yearindex),reverse=True)[:num_extr]
    

    # we will now put our indices to one side and get the data we are 
    # interested in 
    # the field we are using will be passed in the calling program

    nmonths=len(monthnames)
    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+fieldlocation
    os.chdir(dirname)
    nyears=endyear-startyear+1
    ntimes=nyears

    # firstly get average field over the season
    allfiles=[]
    for month in monthnames:
        allfiles.append(dirname+exptname+'a@pd*'+month+fileext)

    for monthno in range(0,nmonths):
        f=MFDataset(allfiles[monthno])
        lat = f.variables[latname][:]
        lon = f.variables[lonname][:]
    
         
        if len(fieldname) ==1 :
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)

        if len(fieldname) == 2:
            atemp=f.variables[fieldname[0]][:]
            atemp=np.squeeze(atemp)
            atemp2=f.variables[fieldname[1]][:]
            atemp2=np.squeeze(atemp2)
        
        if len(fieldname) > 2:
            print('length of fieldname is', len(fieldname))
            print('you are requesting too many variables')
            sys.exit()

        ntimes,ny,nx=np.shape(atemp)

        #average across the time dimension
        temp_m1=np.mean(atemp,axis=0)

        # set array for storing average
        if monthno == 0:
            temp_avg=temp_m1
        else:
            temp_avg=temp_avg+temp_m1

        
        if len(fieldname) ==2:
            temp_m1=np.mean(atemp2,axis=0)
            if monthno == 0:
                temp2_avg=temp_m1
            else:
                temp2_avg=temp2_avg+temp_m1


    temp_avg=temp_avg/nmonths
    if len(fieldname) == 2:
        temp2_avg=temp2_avg/nmonths

    

    # now get data for the highest and lowest years


    lowdata=sorted(zip(NAOindex,extraindex,yearindex))[:num_extr]
    uppdata=sorted(zip(NAOindex,extraindex,yearindex),reverse=True)[:num_extr]

    # lowest and highest years
    for ex in range(0,2):
        # are we doing highest or lowest
        if ex == 0:
            extremedata=lowdata
        if ex == 1:
            extremedata=uppdata

        for time in range (0,num_extr):
            for monthno in range (0,nmonths):
                singleline=extremedata[time]
                yearuse=int(singleline[2])
                extrause=singleline[1]
                month=monthnames[monthno]
                if month == 'dc' and nmonths > 1:
                    yearuse=yearuse-1
                if month == 'nv' and nmonths > 2:
                    yearuse=yearuse-1
                if month == 'ot' and nmonths > 3:
                    yearuse=yearuse-1
                if month == 'sp' and nmonths > 4:
                    yearuse=yearuse-1
                if yearuse >= 100:
                    yearuse=yearuse-100
                    extrause=chr(ord(extrause)+1)
                                    
                if yearuse < 0:
                    yearuse=yearuse+100
                    extrause=chr(ord(extrause)-1)
                                        
                yearfname=str(yearuse)

                if yearuse < 10:
                    yearfname='0'+str(yearuse)

                fname=dirname+exptname+'a@pd'+extrause+yearfname+month+fileext
                
                print(fname)

                f=Dataset(fname,mode='r')
                lat = f.variables[latname][:]
                latsize=len(lat)
                lon = f.variables[lonname][:]
                lonsize=len(lon)
                lontemp=lon

                if len(fieldname) ==1 :
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)

                if len(fieldname) == 2:
                    atemp=f.variables[fieldname[0]][:]
                    atemp=np.squeeze(atemp)
                    atemp2=f.variables[fieldname[1]][:]
                    atemp2=np.squeeze(atemp2)
        
                if len(fieldname) > 2:
                    print('you are requesting too many variables')
                    sys.exit()
    

                # set array for storing average
                if monthno == 0 and time == 0:
                    temp_extreme=atemp
                    temp2_extreme=0.
                    if len(fieldname)==2:
                        temp2_extreme=atemp2
                    count=1
                else:
                    temp_extreme=temp_extreme+atemp
                    if len(fieldname)==2:
                        temp2_extreme=temp2_extreme+atemp2
                    count=count+1

        # put temperature data in lower or higher catogry
        if ex == 0:
            temp_low=temp_extreme/count
            temp2_low=temp2_extreme/count
        if ex == 1:
            temp_high=temp_extreme/count
            temp2_high=temp2_extreme/count


    # we have finished with the loop        
    # shiftdata for plot
    lontemp=lon
    temp_low,lon = shiftgrid(180.,temp_low,lon,start=False)    
    lon=lontemp
    temp_high,lon = shiftgrid(180.,temp_high,lon,start=False)    
    lon=lontemp
    temp_avg,lon = shiftgrid(180.,temp_avg,lon,start=False)    
    

    if fieldname[0] == 'temp_1':  # temperature data
        titlename=exptname+' low seas temp'
        plotdata(temp_low-273.15,0,lon,lat,titlename,-40.0,40.0,10.0,0,'n','degC')
        plotdata(temp_high-273.15,1,lon,lat,'high seas temp',-40.0,40.0,10.0,0,'n','degC')

        plotdata(temp_low-temp_avg,2,lon,lat,'low seas Tanom',-5.0,6.0,1.0,0,'n','degC')
        plotdata(temp_high-temp_avg,3,lon,lat,'high seas Tanom',-5.0,6.0,1.0,0,'n','degC')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_temp'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'precip_1':  # precipitation data
        titlename=exptname+' low seas precip'
        plotdata(temp_low*60.*60.*24.*30.,0,lon,lat,titlename,-0,275,25,0,'n','mm/month')
        plotdata(temp_high*60.*60.*24.*30.,1,lon,lat,'high seas temp',0,275,25,0,'n','mm/month')

        plotdata((temp_low-temp_avg)*60.*60.*24.*30.,2,lon,lat,'low seas panom',-50,50,15,0,'n','mm/month')
        plotdata((temp_high-temp_avg)*60.*60.*24.*30.,3,lon,lat,'high seas panom',-50,50,10,0,'n','mm/month')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_precip'+exptname+'_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  

        plt.close()
        # if precip also do percentage change
        pcent_low=((temp_low-temp_avg)/temp_avg)*100.
        pcent_high=((temp_high-temp_avg)/temp_avg)*100.
        titlename=exptname+' low seas precip anom'
        plotdata(pcent_low,0,lon,lat,titlename,-50,60,5,0,'a','%')
        plotdata(pcent_high,1,lon,lat,'high seas Precip anomaly',-50,60,5,0,'a','%')
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_precip_pcent'+exptname+'_'+seasname+'.eps' 


    if fieldname[0] == 'p': # mean slp data
        titlename=exptname+' low seas mslp'
        plotdata(temp_low/100.,0,lon,lat,titlename,980,1040,10.0,0,'n','mbar')
        plotdata(temp_high/100.,1,lon,lat,'high seas mslp',980,1040,10.0,0,'n','mbar')

        plotdata((temp_low-temp_avg)/100.,2,lon,lat,'low seas mslp',-5.0,6.0,1.0,0,'n','mbar')
        plotdata((temp_high-temp_avg)/100.,3,lon,lat,'high seas mslp',-5.0,6.0,1.0,0,'n','mbar')

     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_mslp'+exptname+'_'+seasname+'.eps' 




    if len(fieldname)==2 and fieldname[0] == 'u':  # winds dat
        ms='m/s'
        lon=lontemp
        temp2_low,lon = shiftgrid(180.,temp2_low,lon,start=False)    
        lon=lontemp
        temp2_high,lon = shiftgrid(180.,temp2_high,lon,start=False)    
        lon=lontemp
        temp2_avg,lon = shiftgrid(180.,temp2_avg,lon,start=False)    

        titlename=exptname+' low seas winds'
        plotquiver(temp_low,temp2_low,lon,lat,0,titlename,0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high,temp2_high,lon,lat,1,'high seas winds',1,400,40.0,0.0,'n',ms)       
        #plotquiver(temp_avg,temp2_avg,lon,lat,1,'avg winds',1,400,40.0,0.0,'n',ms)       
        plotquiver(temp_low-temp_avg,temp2_low-temp2_avg,lon,lat,2,'low seas uvanom',0,400,40.0,0.0,'n',ms)
        plotquiver(temp_high-temp_avg,temp2_high-temp2_avg,lon,lat,3,'high seas uvanom',1,400,40.0,0.0,'n',ms)       
     
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NAO/tele_winds'+exptname+'_'+seasname+'.eps' 

    


    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
        

################################
# main program

figureno=0

#==================================
# get annual PC

#get_PC_allmonths('xkvje')
#get_PC_allmonths('xkvjf')
#get_PC_allmonths('xkvjg')


#=================================
# get seasonal PC
#monthnames=['dc','ja','fb','mr']
monthnames=['jn','jl','ag']
#get_PC_seas('xkvje',monthnames,'n',1,100)
#get_PC_seas('xkvjf',monthnames,'n',1,100)
#get_PC_seas('xkvjg',monthnames,'n',1,100)




#=====================================
# get seasonal teleconnections

monthnames=['jn','jl','ag']
seasname='jja'
# note monthnames is the month of the climate variable, seasonnames is the 
# season that the NAO index is calculated over

# temperature
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['temp_1'],'/temp_data/','_temp.nc')

# winds
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude_1','longitude_1',['u','v'],'/winds_data/','_winds.nc')


# precipitation
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['precip_1'],'/precip_data/','_precip.nc')

# mslp
get_NAO_seas_telecon('xkvje',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
get_NAO_seas_telecon('xkvjf',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')
get_NAO_seas_telecon('xkvjg',seasname,'m',1,100,monthnames,'latitude','longitude',['p'],'/mslp_data/','_mslp.nc')


sys.exit(0)

####

::::::::::::::
plot_NINOindex.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_NINOindex
#PURPOSE
#    This program will plot
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import scipy.signal as sig
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import glob

#functions are:
#  def plotdata   plot data (on a x-y grid)
#  def indexplot  plot nino34 index on a line graph
#  def fullprint  print full array for debugging
#  get_NINO34_temperatures gets the NINO34 temperatures and writes to a file
#  plot_NINO34_temperatures   plots NINO34 temperatures from above file

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(3,2,fileno+1)

   # this is good for a ELNINO region
    map=Basemap(llcrnrlon=100.0,urcrnrlon=300.0,llcrnrlat=-20.0,urcrnrlat=20.0,projection='cyl',resolution='c')
   # this is good for the globe
   # map=Basemap(llcrnrlon=0.0,urcrnrlon=360.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def indexplot(toplot,fileno,nyears,nmonths,data_sm,elninoarr,
              laninaarr,xmin,xmax,expt,control,meanval):
    plt.subplot(4,1,fileno+1)

    plt.xlim([xmin,xmax])
    plt.ylim([-2.0,2.0])
    xdata=np.arange(nyears*nmonths)
    xdata=xdata / float(nmonths)
    # plot data
    plt.plot(xdata,toplot)
    if fileno==0:
        titlename='ONI index '+expt+' based on '+control+' mean is '+np.str(meanval)
        plt.title(titlename)
    # overplot smoothed data
    plt.plot(xdata,data_sm,'-')
    # overplot zero line and +-0.5deg line
    plt.plot(xdata,np.zeros(nyears*nmonths))
    plt.plot(xdata,np.zeros(nyears*nmonths)+0.5)
    plt.plot(xdata,np.zeros(nyears*nmonths)-0.5)
    bar_width=1.0/12.0
    plt.bar(xdata,elninoarr,bar_width,color='red',edgecolor="none")
    plt.bar(xdata,laninaarr,bar_width,color='blue',edgecolor="none")
   
# 


   
# end def indexplot

def fullprint(printarr):
  from pprint import pprint
  opt = np.get_printoptions()
  np.set_printoptions(threshold='nan')
  pprint(printarr)
  np.set_printoptions(**opt)
#end def fullprint


def get_NINO34_temperatures(exptname):
# this subroutine will get the NINO3.4 temperature and write them to a file

    print('get nino34_temperatures')

    dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/temp_data/'
    os.chdir(dirname)
    #full_file_paths =  glob.glob(dirname+"*o@pf*")
    full_file_paths =  glob.glob("*o@pf*")
    nfiles=len(full_file_paths)
    nyears=np.ceil(nfiles/12.)
    nmonths=12
    print(nfiles,nyears,nmonths)


    # prepare output files

    fileout='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
    f1=open(fileout,'w+')
    f1.write('nyears='+str(nyears)+' nmonths='+str(nmonths)+'\n')
    f1.write('filename              year   month   NINO3.4 temperature\n')
        

    count=0
    for fname in full_file_paths:
        # extract year and month from file

        # read in data from file
        f=Dataset(fname,mode='r')
        if count == 0:
            lat = f.variables['latitude'][:]
            latsize=np.shape(lat)
            lon = f.variables['longitude'][:]
            lonsize=np.shape(lon)
        
        count==count+1
        temperature=f.variables['temp'][:] 
       
        temperature=np.squeeze(temperature)
# mask out all data that is not in nino3.4 region (120W-170W, 5N-5S) 

        ix1=(lon >=190) & (lon <=240)
        ix2=(lat <= 5) & (lat >=-5) 
        lats_reg = lat[ix2]
        lons_reg = lon[ix1]
        
        ninoint=temperature[ix2]
     
        ninotemp=ninoint[:,ix1]

        # to check that correct region is found
        #plotdata(ninotemp,0,lons_reg,lats_reg,'test',20,30,1,0,'n','tempdeg')
        #plt.show()


        # calculate average temperature in region
        weights=np.cos(np.radians(lats_reg))
        nino34_zonT=np.average(ninotemp,axis=0,weights=weights)
        nino34_T=np.average(nino34_zonT)
        #print(count,fname,nino34_T)

        # from filename obtain year and month
        year=int(float(fname[10:12]))
        month=fname[12:14]
        extra=fname[9:10]
        
        choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                   'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                   'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                   'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                   'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                   'z': 35}

        century=choices.get(extra,extra) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       

        choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                   'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                   'nv': 10, 'dc': 11}

        monthno=choices.get(month,-99) # the second extra is the default v
                                         # value for if it is not found in
                                         # the choices list
       
        year=(century * 100) + year
        print(fname,year,monthno,nyears,nmonths)
        f1.write(fname+';'+str(year)+';'+str(monthno)+';'+str(nino34_T)+'\n')

    
        
    f1.close()



#===NEW PROG=====================================
def plot_NINO34_temperatures(exptname,controlname,tempanomaly):
# this program will plot the temperatures obtained in get_NINO34_temperatures
# it will look like an el nino index
# if will also see if the index is different if we are using the reference 
# temperatures from a control simulation

    fig=plt.figure()

    # get data from experiment
    filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
    f=open(filein,'r')
    # read file to get number of years and months of data
    firstline=f.readline()
    b=firstline.split() # split into nyears and nmonths title

    c=b[0] # get nyears title
    b1=c.split('=')  # split by removing text before equals sign
    nyears=int(float(b1[1])) # this is nyears

    c=b[1] # get nmonths title
    b1=c.split('=')  # split by removing text before equals sign
    nmonths=int(float(b1[1])) # this is nmonths
    print('nyears',nyears)
    print('nmonths',nmonths)


    # discard second titleline
    secondline=f.readline()


    # read over all the rest of the data in the file, find the startyear and
    # the endyear

    yearmin=1E10
    yearmax=-1E10
    for line in f:
        # extract year month and nino index
        linesplit=line.split(';')
        year=int(float(linesplit[1]))
        if year < yearmin:
            yearmin=year
        if year > yearmax:
            yearmax=year
        
    f.close()

    # make 2 arrays to store data
    
    nyears=yearmax-yearmin+1
    allyears=np.empty(nyears)
    allyears[:]=np.NAN
    nino34index=np.empty((nyears,nmonths))
    nino34index[:,:]=np.NAN
    filelist=np.empty((nyears,nmonths),dtype=object)



    # open the file again, get the NINO3.4 index and add to the arrays
    print('yearminmax',yearmax,yearmin)

    f=open(filein,'r')
    # discard two title lines
    firstline=f.readline()
    firstline=f.readline()
    for line in f:
        # extract year month and nino index
        linesplit=line.split(';')
        year=int(float(linesplit[1]))
        month=int(float(linesplit[2]))
        ninoval=float(linesplit[3])

        allyears[year-yearmin]=year
        nino34index[year-yearmin,month]=ninoval
        filelist[year-yearmin,month]=linesplit[0]

    f.close()


    #####################################################
    # get data from control if appropriate

    if controlname != exptname:
        filein='/nfs/hera1/earjcti/um/HadGEM_data/'+controlname+'/NINODATA/'+controlname+'_NINO3.4_temp.txt'
        f=open(filein,'r')
        # read file to get number of years and months of data
        firstline=f.readline()
        b=firstline.split() # split into nyears and nmonths title

        c=b[0] # get nyears title
        b1=c.split('=')  # split by removing text before equals sign
        nyears_ct=int(float(b1[1])) # this is nyears

        c=b[1] # get nmonths title
        b1=c.split('=')  # split by removing text before equals sign
        nmonths_ct=int(float(b1[1])) # this is nmonths
        print('nyears_ct',nyears_ct)
        print('nmonths__ct',nmonths_ct)


        # discard second titleline
        secondline=f.readline()


        # read over all the rest of the data in the file, find the startyear and
        # the endyear

        yearmin_ct=1E10
        yearmax_ct=-1E10
        for line in f:
            # extract year month and nino index
            linesplit=line.split(';')
            year_ct=int(float(linesplit[1]))
            if year_ct < yearmin_ct:
                yearmin_ct=year_ct
            if year_ct > yearmax_ct:
                yearmax_ct=year_ct
           
                    
        f.close()

        # make 2 arrays to store data

        nyears_ct=yearmax_ct-yearmin_ct+1
        allyears_ct=np.empty(nyears_ct)
        allyears_ct[:]=np.NAN
        nino34index_ct=np.empty((nyears,nmonths))
        nino34index_ct[:,:]=np.NAN
        filelist_ct=np.empty((nyears,nmonths),dtype=object)
        

        
        # open the file again, get the NINO3.4 index and add to the arrays
        
        f=open(filein,'r')
        # discard two title lines
        firstline=f.readline()
        firstline=f.readline()
        for line in f:
            # extract year month and nino index
            linesplit=line.split(';')
            year_ct=int(float(linesplit[1]))
            month_ct=int(float(linesplit[2]))
            ninoval=float(linesplit[3])
            
            allyears_ct[year_ct-yearmin_ct]=year_ct
            nino34index_ct[year_ct-yearmin_ct,month_ct]=ninoval
            filelist_ct[year_ct-yearmin_ct,month_ct]=linesplit[0]
            
        f.close()


    

    # get the average annual cycle and remove
    if exptname == controlname:
        meananncyc=np.nanmean(nino34index,axis=0)
    else:
        # reduce temperature anomaly to account for the 
        # fact that the Pliocene is a warmer climate
        print(tempanomaly)
        meananncyc=np.nanmean(nino34index_ct,axis=0)-tempanomaly

    nino34index=nino34index-meananncyc

   
    toplot=np.reshape(nino34index,nyears*nmonths)
    allfiles=np.reshape(filelist,nyears*nmonths)
    smoothednino34index=[np.mean(toplot[i-1:i+1]) for i in range (0,nyears*nmonths)]


    
    # setup an el nino array and a la nina array
    # condition must be met for 5 months

    elninoarr=np.zeros(nyears*nmonths)
    laninaarr=np.zeros(nyears*nmonths)
    for i in range(1,nyears*nmonths-4):
        if elninoarr[i-1] != 0:    # if previous month is el nino
            if smoothednino34index[i] >= 0.5:
                elninoarr[i]=smoothednino34index[i]
            else:
                elninoarr[i]=0
        else:
            flag='y'
            for i2 in range(i,i+5):
                if smoothednino34index[i] <= 0.5:
                    flag='n'
            if flag == 'y':
                elninoarr[i]=smoothednino34index[i]
            else:
                elninoarr[i]=0
        
        if laninaarr[i-1] != 0:    # if previous month is la nino
            if smoothednino34index[i] <= -0.5:
                laninaarr[i]=smoothednino34index[i]
            else:
                laninaarr[i]=0
        else:
            flag='y'
            for i2 in range(i,i+5):
                if smoothednino34index[i] >= -0.5:
                    flag='n'
            if flag == 'y':
                laninaarr[i]=smoothednino34index[i]
            else:
                laninaarr[i]=0
                
            
    meanval=np.nanmean(smoothednino34index)
    indexplot(toplot,0,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,0,25,exptname,controlname,meanval)
    indexplot(toplot,1,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,25,50,exptname,controlname,meanval)
    indexplot(toplot,2,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,50,75,exptname,controlname,meanval)
    indexplot(toplot,3,nyears,nmonths,smoothednino34index,elninoarr,
              laninaarr,75,100,exptname,controlname,meanval)

                

    if exptname != controlname:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_'+controlname+'_NINO3.4_ONI.eps'
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_ONI.eps'

        fileout='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_index.txt'
        f1=open(fileout,'w+')
        f1.write('filename  year month  smoothed NINO3.4 temperature    el nino ind   la nina ind\n')

        print(allfiles)

        for i in range(0,nyears*nmonths):
            if allfiles[i]:
                fname=allfiles[i]
                print(fname)
                print(fname[10:12])
                year=int(float(fname[10:12]))
                month=fname[12:14]
                extra=fname[9:10]
                
                choices = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 
                       'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 
                       'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 
                       'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29, 
                       'u': 30, 'v': 31, 'w': 32, 'x': 33, 'y': 34, 
                       'z': 35}
            
                century=choices.get(extra,extra) # the second extra is the default v
                # value for if it is not found in
                # the choices list
            
            
                choices = {'ja': 0, 'fb': 1, 'mr': 2, 'ar': 3, 'my': 4, 
                       'jn': 5, 'jl': 6, 'ag': 7, 'sp': 8, 'ot': 9, 
                       'nv': 10, 'dc': 11}
            
                monthno=choices.get(month,-99) # the second extra is the default v
                # value for if it is not found in
                # the choices list
                
                print(century,year)
                year=(century * 100) + year
                print(fname,year,monthno,nyears,nmonths)
                f1.write(fname+';'+str(year)+';'+str(monthno)+';'+str(smoothednino34index[i])+';'+str(elninoarr[i])+';'+str(laninaarr[i])+'\n')


    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()




#end def



#===NEW PROG=====================================
def plot_NINO34_patterns(exptname,fieldreq):
# this program will plot the patterns associated with an el nino


    filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_index.txt'
    f=open(filein,'r')
    # read firstline and discard
    firstline=f.readline()

    arraysetup='n'
    for line in f:
        # extract filename
        linesplit=line.split(';')
        filename=linesplit[0]
        month=int(float(linesplit[2]))
        normval=float(linesplit[3])
        enind=float(linesplit[4])
        lnind=float(linesplit[5])

        # read in data from file
        if fieldreq == 'temp':
            ncdffile='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/temp_data/'+filename
        if fieldreq == 'precip_1':
            ncdffile='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+filename[0:5]+'a@pd'+filename[9:15]+'precip.nc'


        f=Dataset(ncdffile,mode='r')
        f.dimensions
        f.variables

        filetemp = f.variables[fieldreq][:]
        filetemp=np.squeeze(filetemp)
        
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]

        f.close()

        xsize=len(lon)
        ysize=len(lat)
    
        # setup arrays nmonths nlats nlons
        if arraysetup=='n':
            enarr=np.zeros((12,ysize,xsize))
            lnarr=np.zeros((12,ysize,xsize))
            normarr=np.zeros((12,ysize,xsize))
            cten=np.zeros(12,dtype=np.int)
            ctln=np.zeros(12,dtype=np.int)
            ctnm=np.zeros(12,dtype=np.int)
            arraysetup='y'


        if enind != 0.0:
            enarr[month,:,:]=enarr[month,:,:]+filetemp
            cten[month]=cten[month] + 1
        elif lnind != 0.0:
            lnarr[month,:,:]=lnarr[month,:,:]+filetemp
            ctln[month]=ctln[month]+1
        else:
            normarr[month,:,:]=normarr[month,:,:]+filetemp
            ctnm[month]=ctnm[month]+1


   
            
    enarr=enarr/cten[:,np.newaxis, np.newaxis]
    lnarr=lnarr/ctln[:,np.newaxis, np.newaxis]
    normarr=normarr/ctnm[:,np.newaxis, np.newaxis]
        
   
       
    enmean=np.average(enarr,axis=0)
    lnmean=np.average(lnarr,axis=0)
    nmmean=np.average(normarr,axis=0)
    units='degC'
    if fieldreq == 'precip_1': 
        units='mm/month'
        enmean=enmean * 60. *60. * 24. * 30.
        lnmean=lnmean * 60. *60. * 24. * 30.
        nmmean=nmmean * 60. *60. * 24. * 30.


    if fieldreq == 'temp':
        # figures for temperature
        titlename=exptname+'elnino'
        plotdata(enmean,0,lon,lat,titlename,20.,30,1,0,'n',units)
        plotdata(lnmean,1,lon,lat,'lanina',20.,30,1,0,'n',units)
        enanom=enmean-nmmean
        plotdata(enanom,2,lon,lat,'elninoanom',-2.,2,0.1,0,'a',units)
        lnanom=lnmean-nmmean
        plotdata(lnanom,3,lon,lat,'lanina anom',-2.,2,0.1,0,'a',units)

    if fieldreq =='precip_1':
        # plots for precip
        # figures for temperature
        titlename=exptname+'elnino'
        plotdata(enmean,0,lon,lat,titlename,0.,300,10,0,'n',units)
        plotdata(lnmean,1,lon,lat,'lanina',0.,300,10,0,'n',units)
        enanom=enmean-nmmean
        plotdata(enanom,2,lon,lat,'elninoanom',-100.,100,10,0,'a',units)
        lnanom=lnmean-nmmean
        plotdata(lnanom,3,lon,lat,'lanina anom',-100.,100,0.10,0,'a',units)



    # get average temperature across pacific
    ix1=(lon >=100) & (lon <=300)
    ix2=(lat <= 20) & (lat >=-20) 
    lats_reg = lat[ix2]
    lons_reg = lon[ix1]
        
    avg_pac=nmmean[ix2]
    avg_pac=avg_pac[:,ix1]
        
    print(np.shape(avg_pac))
    for i in range(0,len(lons_reg)):
        for j in range(0,len(lats_reg)):
            if avg_pac[j,i] == 0:  # land point
                avg_pac[j,i]=float('NaN')
    
    WPminEP=np.nanmean(avg_pac[:,0:len(lons_reg)/2.0])- \
        np.nanmean(avg_pac[:,len(lons_reg)/2.0:len(lons_reg)])

    print('avg pac',avg_pac)
    
    print('mean is',np.nanmean(avg_pac),WPminEP)

    if fieldreq =='temp':
        titlename='normal W-E is:'+np.str(WPminEP)
        plotdata(nmmean-np.nanmean(avg_pac),4,lon,lat,titlename,-4.,4,0.1,0,'a','degC')





    # print out the average anomaly associated with elnino

    avg_enanom=enanom[ix2]
    avg_enanom=avg_enanom[:,ix1]
    avg_lnanom=lnanom[ix2]
    avg_lnanom=avg_lnanom[:,ix1]
   
    for i in range(0,len(lons_reg)):
        for j in range(0,len(lats_reg)):
            if avg_enanom[j,i] == 0 and avg_lnanom[j,i]==0:  # land point
                 avg_enanom[j,i]=float('NaN')
                 avg_lnanom[j,i]=float('NaN')
                 
    print('mean elnino signature',np.nanmean(avg_enanom))
    print('mean lanina signature',np.nanmean(avg_lnanom))
    print('mean absolute value elnino signature',np.nanmean(np.absolute(avg_enanom)))
    print('mean absolute value lanina signature',np.nanmean(np.absolute(avg_lnanom)))





    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_patterns_'+fieldreq+'.eps'

    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


    retdata=[enanom,lnanom,lon,lat]
    return retdata


#end def



#===NEW PROG=====================================
def plot_NINO34_freqspectra(exptnames):
# this program will plot the freqquency spectra of the NINO3.4 temperature


    nexpts=len(exptnames)

    allninotemp=[]
    allmonth=[]
    monthtemp=np.zeros(12)
    monthcount=np.zeros(12)
    titlename='power spectral density'



    for exptname in exptnames:

        filein='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/NINODATA/'+exptname+'_NINO3.4_temp.txt'
        f=open(filein,'r')
    # read first two lines and discard
        firstline=f.readline()
        firstline=f.readline()
        for line in f:
            # extract filename
            linesplit=line.split(';')
            filename=linesplit[0]
            month=int(float(linesplit[2]))
            nino34temp=float(linesplit[3])
            allninotemp.append(float(nino34temp))
            # stuff for removing average annual cycle
            allmonth.append(month)
            monthtemp[month]=monthtemp[month]+nino34temp
            monthcount[month]=monthcount[month]+1

        f.close()
        titlename=exptname+' '+titlename


    monthtemp=monthtemp/monthcount

 

    # remove annual cycle
    allninotemp=allninotemp-monthtemp[allmonth]

    titlename=titlename+' variance is ','%.2f' %np.var(allninotemp)


    # do a spectral analysis on the index
    Pxx_f, Pxx_den=sig.periodogram(allninotemp,1.0)
   
    Pxx_f=Pxx_f * 12. #  convert to cycles per year from cycles per month

    plt.subplot(2,1,1)
    nmonths=len(allninotemp)
    xarray=(np.arange(0,nmonths,1))/12.
    print('shapes')
    print(np.shape(xarray))
    print(np.shape(allninotemp))
    plt.plot(xarray,allninotemp) # raw data with restricted
    plt.title('NINO3.4 temp anomaly')
    plt.xlabel('year')
    plt.ylabel('nino3.4 temp')
    axes=plt.gca()
    axes.set_xlim([0,nmonths/12])
   


    plt.subplot(2,1,2)
    plt.plot(1.0/Pxx_f,Pxx_den) # plotting with period on y axis
    plt.title(titlename)
    axes=plt.gca()
    axes.set_xlim([0.5,150])
    axes.set_xscale('log')
    axes.set_xticks([1,2,5,10,20,40,80,160])
    axes.get_xaxis().set_major_formatter(mp.ticker.ScalarFormatter())
    plt.xlabel('period (years)')



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_NINOindex/'+exptname+'_NINO3.4_freqspectra.eps'

    plt.savefig(fileout, bbox_inches='tight')  
    plt.close()


    
   




#end def



################################
# main program

figureno=0
###############################
#get_NINO34_temperatures('xkvje')
#get_NINO34_temperatures('xkvjf')
#get_NINO34_temperatures('xkvjg')

##############################################
# get patterns associated with el nino for a chosen field

avg_pac_temp_PI=plot_NINO34_patterns('xkvje','temp')
avg_pac_temp_plio=plot_NINO34_patterns('xkvjf','temp')
avg_pac_temp_pliop2=plot_NINO34_patterns('xkvjg','temp')

precipdata=plot_NINO34_patterns('xkvje','precip_1')
# extract fields for anomalies
precip_enanom_pi=precipdata[0]
precip_lnanom_pi=precipdata[1]
lon=precipdata[2]
lat=precipdata[3]

precipdata=plot_NINO34_patterns('xkvjf','precip_1')
precip_enanom_plio=precipdata[0]
precip_lnanom_plio=precipdata[1]

precipdata=plot_NINO34_patterns('xkvjg','precip_1')
precip_enanom_pliop2=precipdata[0]
precip_lnanom_pliop2=precipdata[1]

plotdata(precip_enanom_pliop2-precip_enanom_pi,0,lon,lat,'diff in elnino precip (pliop2 and pi)',-100.,100,0.10,0,'a','mm/month')
plotdata(precip_enanom_plio-precip_enanom_pi,1,lon,lat,'diff in elnino precip (plio and pi)',-100.,100,0.10,0,'a','mm/month')
plotdata(precip_lnanom_pliop2-precip_lnanom_pi,2,lon,lat,'diff in lanina precip (pliop2 and pi)',-100.,100,0.10,0,'a','mm/month')
plotdata(precip_lnanom_pliop2-precip_lnanom_pi,3,lon,lat,'diff in lanina precip (plio and pi)',-100.,100,0.10,0,'a','mm/month')
plt.show()





#########################################
#plot_NINO34_temperatures('xkvje')
# the temperature anomaly needs to be obtained from plot_NINO34_patterns

#tempanomaly=avg_pac_temp_PI-avg_pac_temp_plio # for normalising control index
#print(tempanomaly)
#plot_NINO34_temperatures('xkvjf','xkvje',tempanomaly)
#tempanomaly=avg_pac_temp_PI-avg_pac_temp_pliop2 # for normalising control index
#plot_NINO34_temperatures('xkvjg','xkvje',tempanomaly)


###########################
# plot freqency spectra to see what freqency of NINO
#plot_NINO34_freqspectra(['xkvja','xkvje'])
#plot_NINO34_freqspectra(['xkvjb','xkvjf'])
#plot_NINO34_freqspectra(['xkvjc','xkvjg'])


sys.exit(0)

####

::::::::::::::
plot_ocean_heat_transport.py
::::::::::::::
 #!/usr/bin/env python2.7
#NAME
#    PLOT_OCEAN HEAT TRANSPORT
#PURPOSE
#    This program will do all the plots to do with ocean heat transport
#   
#    We want to see how much heat the THC transported in the pliocene and if 
#    if this is different from the modern
# search for 'main program' to find end of functions
# Julia 19/1/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)


   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata
#####################################
def plot_lat_dep(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,cbarname):
    lats, deps  = np.meshgrid(lat,dep)

    V=np.arange(minval,maxval,valinc)
    
    cs = plt.contourf(lats,deps,plotdata,V,extend="both",cmap='RdBu_r')
    plt.gca().invert_yaxis()

    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata

#  to check if a character is numeric
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

#============================
def Atlantic_heat_transport(expt_name):



#  get data from files

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pg2/'+expt_name+'o@pg*.nc')
    lat = f.variables['latitude_1'][:]
    lon = f.variables['longitude_1'][:]
    dep = f.variables['depth_1'][:]
    Vvel=f.variables['field704'][:]
    PotT=f.variables['temp'][:]
    Vvel=np.squeeze(Vvel)
    PotT=np.squeeze(PotT)
    f.close()

    ntimes,ndep,nlat,nlon=np.shape(Vvel)
    
    # calculate T(j)-T(j+1)  which is notthwards anomaly
    
    PotT_diff=np.zeros((ntimes,ndep,nlat,nlon))
    for j in range(0,nlat):
        PotT_diff[:,:,j,:]=PotT[:,:,j,:]-PotT[:,:,j+1,:] 

   
    vT=Vvel * PotT_diff
    mean_VT=np.mean(vT,axis=0)
    meanPotT_diff=np.mean(PotT_diff,axis=0)

  

   

#  get mask of Oceans
    filemask='/nfs/see-fs-02_users/earjcti/MOC/merid/basin_hadgom_216'
    f1=open(filemask,'r')
    # discard 3 title lines
    textline=f1.readline()
    textline=f1.readline()
    textline=f1.readline()
    # next line is details from basin
    nrows=nlat+1  # because it's on T grid not V grid
    Indian_d=np.zeros((nrows,4))
    Pacific_d=np.zeros((nrows,4))
    Atlantic_d=np.zeros((nrows,4))
    Combined_d=np.zeros((nrows,4))
    for line in f1:
        linesplit=line.split()  # split line by space
        if is_number(linesplit[0]):
            rowno=int(linesplit[0])
            Indian_d[rowno-1,:]=int(linesplit[1]),int(linesplit[2]),\
                int(linesplit[3]),int(linesplit[4])
            Pacific_d[rowno-1,:]=int(linesplit[5]),int(linesplit[6]),\
                int(linesplit[7]),int(linesplit[8])
            Atlantic_d[rowno-1,:]=int(linesplit[9]),int(linesplit[10]),\
                int(linesplit[11]),int(linesplit[12])
            Combined_d[rowno-1,:]=int(linesplit[13]),int(linesplit[14]),\
                int(linesplit[15]),int(linesplit[16])

    f1.close()

    # make some attempt to convert to V grid
    Atlantic_V=np.zeros((nlat,4))
    for j in range(0,nlat):
        Atlantic_V[j,:]=(Atlantic_d[j,:]+Atlantic_d[j+1,:])/2.0


    Atlantic_mask=np.ones((nlat,nlon),dtype=bool)
    for j in range(0,nlat):
        Atlantic_mask[j,Atlantic_V[j,0]:Atlantic_V[j,1]]=0
        Atlantic_mask[j,Atlantic_V[j,2]:Atlantic_V[j,3]]=0



    # get mean heat transport over Atlantic
    Atlantic_VT=np.ma.masked_array(mean_VT,mask=np.tile(Atlantic_mask,(mean_VT.shape[0],1)))


    Atlantic_VT=Atlantic_VT / 100. # convert from K cm/s to K m/s


    lontemp=lon
    PotT_diff,lon = shiftgrid(180.,PotT_diff,lon,start=False)
    lon=lontemp
    mean_VT,lon = shiftgrid(180.,mean_VT,lon,start=False)
    lon=lontemp
    Atlantic_VT, lon = shiftgrid(180.,Atlantic_VT,lon,start=False)
    lon=lontemp
    meanPotT_diff, lon = shiftgrid(180.,meanPotT_diff,lon,start=False)


    #plotmap(meanPotT_diff[0,:,:],0,lon,lat,'theta diff',-2,2,0.1,0.0,'n','degC')
    #plotmap(mean_VT[0,:,:],1,lon,lat,'meanvt',-2,2,0.1,0.0,'n','degC')
    #plt.show()
    
 
    #plotmap(Atlantic_VT[0,:,:],2,lon,lat,'atl_vt0',-2,2,0.1,0.0,'n','degC')
    #plotmap(Atlantic_VT[30,:,:],3,lon,lat,'atlvt30',-2,2,0.1,0.0,'n','degC')
    #plt.show()


    # we have extracted the data we want.  Now have a go at
    # calculating surfact heat transport.
    # (This is Cp * integral [(dens * VT)]dx


    dens=1029 # in reality this will change depending on temperature and 
              # saltiness  but mean value is 1029kg/m3
    cp = 3985      # This is seawater heat capacity 3985 J /kg / K

    Atl_qsurf=np.zeros((ndep,nlat))

    for k in range(0,ndep):
        for j in range(0,nlat):
            dx=(lon[1]-lon[0]) * 111000. * np.cos(np.radians(lat[j]))
            Atl_weight=Atlantic_VT[k,j,:]*cp*dens*dx
            Atl_qsurf[k,j]=np.sum(Atl_weight)
            if k == 0 and lat[j] < 5. and lat[j]> -5.:
                print(Atlantic_VT[k,j,:])
                print('pott',meanPotT_diff[k,j,:])
                print('vvel',np.mean(Vvel[:,k,j,:],axis=0))
                print(dx)
                sys.exit()

    # units of Atl_qsurf[j] are currently J/s/m.  This is because we have 
    # not accounted for depth.  To find the total heat transport we would 
    # multiply by the depth of the layer which would give the results in Watts

    dep_lay=np.zeros(ndep)
    dep_lay[0]=dep[0] * 2.0
    dep_lay[ndep-1]=dep[ndep-1] -dep[ndep-2]
    for k in range(1,ndep-1):
        dep_lay[k]=(dep[k+1]-dep[k-1])/2.0
   
   
    Atl_qsurf=Atl_qsurf / 10**15  # give results in petawatts
    Atl_qsurf=Atl_qsurf * dep_lay[:,None]
    print('shape',np.shape(Atl_qsurf))


    titlename='Atlantic Heat transport: '+expt_name
    plot_lat_dep(Atl_qsurf,0,lat,dep,titlename,-1.5,1.5,0.1,'Petawatts')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/'+expt_name+'_Atl_lat_depth.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    return(lat,dep,Atl_qsurf)
    

#end def Atlantic_salinity_depth_plot
#end def annmean

#========================================
def lat_heat_transport(expt_name1,expt_OHT1,expt_name2,expt_OHT2,lat,dep):
# this subroutine will do a plot of ocean heat transport integrated over all the ocean 

    print('in lat heat transport')
    allOHT1=np.nansum(expt_OHT1,axis=0)
    plt.plot(lat,allOHT1)
    plt.plot(lat,expt_OHT1[0,:],'b.')

    if expt_name2 != 'none':
        allOHT2=np.nansum(expt_OHT2,axis=0)
        plt.plot(lat,allOHT2,'r-')
        plt.plot(lat,expt_OHT2[0,:],'r.')




    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/'+expt_name1+'_'+expt_name2+'_Atl_lat.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    print('end lat heat transport')



#end def lat_heat_transport

################################
# main program

# annual mean salinity by depth

retdata=Atlantic_heat_transport('xkvjg')
lat=retdata[0]
dep=retdata[1]
xkvjg_OHT=retdata[2]

retdata=Atlantic_heat_transport('xkvjf')
xkvjf_OHT=retdata[2]

retdata=Atlantic_heat_transport('xkvje')
xkvje_OHT=retdata[2]

# do an anomaly plot

anomplot=xkvjg_OHT-xkvje_OHT
titlename='Atlantic Heat transport: xkvjg-xkvje'
plot_lat_dep(anomplot,0,lat,dep,titlename,-0.5,0.5,0.05,'Petawatts')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/xkvjg-xkvje_Atl_lat_depth.eps'
plt.savefig(fileout, bbox_inches='tight')  
plt.close()


anomplot=xkvjf_OHT-xkvje_OHT
titlename='Atlantic Heat transport: xkvjf-xkvje'
plot_lat_dep(anomplot,0,lat,dep,titlename,-0.5,0.5,0.05,'Petawatts')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_ocean_heat_transport/xkvjf-xkvje_Atl_lat_depth.eps'
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

# integrate over ocean depth and then plot
print('calling lat heat transport')

lat_heat_transport('xkvjg',xkvjg_OHT,'xkvje',xkvje_OHT,lat,dep)


sys.exit()



####

::::::::::::::
plot_precip_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFPRECIP
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='h')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def annmean(figureno,HadCM3):
    #==============
    # preindustrial


    # read in data from multiple files
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip'][:]
        titlepi='PI-Ann_HadCM3'
        titleplio='Plio-Ann_HadCM3'
        titlediff='Plio - preind  Ann_HadCM3'
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip_1'][:]
        titlepi='PI-Ann_HadGEM2'
        titleplio='Plio-Ann_HadGEM2'
        titlediff='Plio - preind Ann_HadGEM2'


    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_precip_ann=np.mean(aprecip,axis=0)
    print('new shape',np.shape(pi_precip_ann))
    
    pi_precip_ann=pi_precip_ann * 60. * 60. * 24. * 30.
    
    plt.figure(0)
    lonprecip=lon
    pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    
    plotdata(pi_precip_ann,0,lon,lat,titlepi,0,275,25.0,0.0,'n','mm/month')


     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*.nc')
        aprecip=f.variables['precip'][:]
        aprecip=np.squeeze(aprecip)
    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*.nc')
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

    plio_precip_ann=np.mean(aprecip,axis=0)
    plio_precip_ann=plio_precip_ann * 60. * 60. * 24. * 30.

    lon=lonprecip
    plio_precip_ann,lon = shiftgrid(180.,plio_precip_ann,lon,start=False)

    plotdata(plio_precip_ann,1,lon,lat,titleplio,0,275,25,0.0,'n','mm/month')


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*.nc')
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aprecip)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_precipp2_ann=np.mean(aprecip,axis=0)
        plio_precipp2_ann=plio_precipp2_ann * 60. * 60. * 24. * 30.
        lon=lonprecip
        plio_precipp2_ann,lon = shiftgrid(180.,plio_precipp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_precip_ann-pi_precip_ann

    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,titlediff,0,275,25,V,'n','mm/month')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_precipp2_ann-pi_precip_ann
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'n','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # Pliocene - preindustrial percentage change

    print(pi_precip_ann)
    plio_peranom=((plio_precip_ann-pi_precip_ann)/pi_precip_ann)*100.
    plotdata(plio_peranom,0,lon,lat,titlediff,-50,60,5,0,'a','%')

    if HadCM3 != 'y':
        plio_peranomp2=((plio_precipp2_ann-pi_precip_ann)/pi_precip_ann)*100.
        plotdata(plio_peranomp2,1,lon,lat,'Plio - PI Panom_HG2+2 %',-50,60,5,0,'a','%')

    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  



    plt.close()



#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*'+m3+'.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aprecip=fa.variables['precip'][:]
        bprecip=fb.variables['precip'][:]
        cprecip=fc.variables['precip'][:]
        pititle='PI HadCM3: '+seasname
        pliotitle='Plio HadCM3: '+seasname
        difftitle='Plio-PI HadCM3: '+seasname
        
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m3+'_precip.nc')
        lat = fa.variables['latitude'][:]
        lon = fa.variables['longitude'][:]
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]
        pititle='PI HadGEM2: '+seasname
        pliotitle='Plio HadGEM2: '+seasname
        difftitle='Plio-PI HadGEM2: '+seasname




    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    plotdata(pi_seasprecip,0,lon,lat,pititle,0,275,25,0.0,'n','mm/month')
    
     #==============
     # Pliocene

    if HadCM3 == 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m1+'.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m2+'.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*'+m3+'.nc')
        aprecip=fa.variables['precip'][:]
        bprecip=fb.variables['precip'][:]
        cprecip=fc.variables['precip'][:]
    else:
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m3+'_precip.nc')
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]

    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
    
    
    plotdata(plio_seasprecip,1,lon,lat,pliotitle,0,275,25,0.0,'n','mm/month')



     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m1+'_precip.nc')
        fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m2+'_precip.nc')
        fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m3+'_precip.nc')
        aprecip=fa.variables['precip_1'][:]
        bprecip=fb.variables['precip_1'][:]
        cprecip=fc.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        bprecip=np.squeeze(bprecip)
        cprecip=np.squeeze(cprecip)
        
        pliop2_aprecip_avg=np.mean(aprecip,axis=0)
        pliop2_bprecip_avg=np.mean(bprecip,axis=0)
        pliop2_cprecip_avg=np.mean(cprecip,axis=0)
        
        pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
        pliop2_seasprecip=pliop2_seasprecip * 60. * 60. * 30. * 24.
        
        lon=lonprecip
        pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seasprecip-pi_seasprecip
    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    plotdata(plio_anom,2,lon,lat,difftitle,0,275,25,V,'la','mm/month')
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=pliop2_seasprecip-pi_seasprecip
        V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month')


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom_HadCM3.eps' 
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    plotdata(plio_peranom,0,lon,lat,difftitle,-50,50,5,0,'a','%')


    if HadCM3 !='y':
        plio_peranomp2=((pliop2_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
        titlename='Plio+2-PI precip %'+seasname
        plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%')

    if HadCM3 =='y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  
    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    plt.close()




#end def seasmean

################################
# main program

# annual mean
figureno=0

HadCM3='n'
#plt.figure(figureno)
#annmean(figureno,HadCM3)
#figureno=figureno+1

#djf mean
plt.figure(figureno)
seasmean('dc','ja','fb',figureno,'djf',HadCM3)
figureno=figureno+1

#jja mean
plt.figure(figureno)
seasmean('jn','jl','ag',figureno,'jja',HadCM3)
figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_precip.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFPRECIP
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid, maskoceans


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()

    plotdata2=plotdata
    #plotdata=maskoceans(x,y,plotdata)
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
    plotdata=plotdata2
#end def plotdata

def annmean(figureno,preind_expt,plio_expt,pliop2_expt,extra):
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'+preind_expt+'a@pd'+extra+'[7-9]*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_precip_ann=np.mean(aprecip,axis=0)
    print('new shape',np.shape(pi_precip_ann))
    
    pi_precip_ann=pi_precip_ann * 60. * 60. * 24. * 30.
    
    plt.figure(0)
    lonprecip=lon
    pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    
    plotdata(pi_precip_ann,0,lon,lat,'PI-Ann_HadGEM2',0,275,25.0,0.0,'n','mm/month')


     #==============
     # Pliocene


    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'+plio_expt+'a@pd'+extra+'[7-9]*.nc')
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)

    plio_precip_ann=np.mean(aprecip,axis=0)
    plio_precip_ann=plio_precip_ann * 60. * 60. * 24. * 30.

    lon=lonprecip
    plio_precip_ann,lon = shiftgrid(180.,plio_precip_ann,lon,start=False)

    plotdata(plio_precip_ann,1,lon,lat,'Plio-PAnn_HG2',0,275,25,0.0,'n','mm/month')


     #==============
     # Pliocene+2


     # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*.nc')
    aprecip=f.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
    #average across the time dimension
    plio_precipp2_ann=np.mean(aprecip,axis=0)
    plio_precipp2_ann=plio_precipp2_ann * 60. * 60. * 24. * 30.
    lon=lonprecip
    plio_precipp2_ann,lon = shiftgrid(180.,plio_precipp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_precip_ann-pi_precip_ann

    print('plio_precip_ann',plio_precip_ann[20,:])
    print('pi_precip_ann',pi_precip_ann[20,:])
    print('plio_anom',plio_anom[20,:])


    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
    plotdata(plio_anom,2,lon,lat,'Plio - PI Panom_HG2',0,275,25,V,'la','mm/month')
    
    # Pliocene+2 - preindustrial

    pliop2_anom=plio_precipp2_ann-pi_precip_ann
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]

    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month')



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_precip_ann-pi_precip_ann)/pi_precip_ann)*100.
    plotdata(plio_peranom,0,lon,lat,'Plio - PI Panom_HG2 %',-50,60,5,0,'a','%')

    plio_peranomp2=((plio_precipp2_ann-pi_precip_ann)/pi_precip_ann)*100.
    plotdata(plio_peranomp2,1,lon,lat,'Plio - PI Panom_HG2+2 %',-50,60,5,0,'a','%')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()



#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/precip_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m3+'_precip.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    plotdata(pi_seasprecip,0,lon,lat,'PI HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month')
    
     #==============
     # Pliocene


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/precip_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m3+'_precip.nc')
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
    
    
    plotdata(plio_seasprecip,1,lon,lat,'PI HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month')



     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/precip_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m3+'_precip.nc')
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    
    pliop2_aprecip_avg=np.mean(aprecip,axis=0)
    pliop2_bprecip_avg=np.mean(bprecip,axis=0)
    pliop2_cprecip_avg=np.mean(cprecip,axis=0)
    
    pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
    pliop2_seasprecip=pliop2_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seasprecip-pi_seasprecip
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
   

    plotdata(plio_anom,2,lon,lat,'Plio - PI Panom_HG2',0,275,25,V,'la','mm/month')
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seasprecip-pi_seasprecip
    #V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]
    V=[-128,-64,-32,-16,-8,-4,0,4,8,16,32,64,128]
   

    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month')



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio-PI precip %'+seasname
    plotdata(plio_peranom,0,lon,lat,titlename,-50,50,5,0,'a','%')

    plio_peranomp2=((pliop2_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio+2-PI precip %'+seasname
    plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'_'+pliop2_expt+'_'+plio_expt+'_'+preind_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()




#end def seasmean

################################
# main program

# annual mean
figureno=0
preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'

plt.figure(figureno)
annmean(figureno,preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1

#djf mean
plt.figure(figureno)
seasmean('dc','ja','fb',figureno,'djf',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1

#jja mean
plt.figure(figureno)
seasmean('jn','jl','ag',figureno,'jja',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_radiation.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_RADIATION
#PURPOSE
#    This program will plot the radiation budget for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid
import subprocess


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal",)

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def annmean(switch,HadCM3,expt,extra):
    # switch is a dummy variable to allow the program to be called

    # we will plot a) incoming sw ra flux (toa) field200
    #              b) incoming sw ra flux (toa) field201
    #              c) outgoing lw rad flux (toa) olr
    # other things if the budgets don't balance

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        insw=f.variables['field200'][:]
        outsw=f.variables['field201'][:]
        outlw=f.variables['olr'][:]

        titlePI='PI-TAnn_HadCM3'
        titlediff='Plio - PI Tanom_HadCM3'
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/netcdf/'
        filename=expt+'a@pd'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename)
        os.system('ls '+dirname+filename+' | wc -l')
        nval=os.system('ls '+dirname+filename+' | wc -l')
        allfiles=subprocess.check_output('ls '+dirname+filename+' | wc -l',shell=True)
        print('number of files=',allfiles)
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        # net downward sw flux at the trop
        netsw=f.variables['solar_2'][:]
        # net downward lw flux at the trop
        netlw=f.variables['longwave_2'][:]

        # alternative 1
        insw=f.variables['field200'][:]
        outsw=f.variables['field201'][:]
        outlw=f.variables['olr'][:]
        netlw= (-1.0) *outlw
        netsw=insw-outsw


    netsw=np.squeeze(netsw)
    netlw=np.squeeze(netlw)
    ntimes,ny,nx=np.shape(netsw)
    print(ntimes,ny,nx)
    
#average across the time dimension
    netsw_ann=np.mean(netsw,axis=0)
    netlw_ann=np.mean(netlw,axis=0)
    
    
    plt.figure(0)
    wm2='w/m2'
    lontemp=lon
    titlename=expt+'net SW ann'
    netsw_ann,lon = shiftgrid(180.,netsw_ann,lon,start=False)    
    plotdata(netsw_ann,0,lon,lat,titlename,0,400,40.0,0.0,'n',wm2)


    lon=lontemp
    netlw_ann,lon = shiftgrid(180.,netlw_ann,lon,start=False)    
    plotdata(netlw_ann * (-1.0),1,lon,lat,' net lw ann',100,300,40.0,0.0,'n',wm2)

    # calculate residual and mean residual weighted by cos latitude

    residual=netsw_ann+ netlw_ann
  
    weights=np.cos(np.radians(lat))
    print('len weights',len(weights))
    resid_zon=np.average(residual,axis=0,weights=weights)
    average_residual=np.average(resid_zon)

    print(average_residual)
    titlename='residual, avg='+str(average_residual)+'(w/m2)'
    plotdata(residual,2,lon,lat,titlename,-100,100,20.0,0.0,'n',wm2)
    


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_radiation/annmean_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


#end def annmean



################################
# main program

# annual mean
figureno=0

HadCM3='n'
exptname='ximut'
extra='l'

#exptname='xkvjg'  #xkvje xkvjf xkvjg
#extra='n'

plt.figure(figureno)
annmean('y',HadCM3,exptname,extra)
figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf',HadCM3)
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3)
#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_regional_precip_indyear.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_regional_precip_indyear
#PURPOSE
#    This program will plot the precipitation (annual and seasonal) and
#    the precipitation anomaly (annual and seasonal) for each individual 
#    year for a specified region of the globe
#
# search for 'main program' to find end of functions
# Julia 9/2/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def get_annmean_precip
#  def get_seasmean_precip

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname,lonmin,lonmax,latmin,latmax,plotbox):
    lons, lats = np.meshgrid(lon,lat)
    if fileno != 99:
        plt.subplot(3,3,fileno+1)
    else:
        plt.subplot(2,1,1)

   # this is good for the globe
    map=Basemap(llcrnrlon=lonmin-20,urcrnrlon=lonmax+20,llcrnrlat=latmin-20,urcrnrlat=latmax+20,projection='cyl',resolution='c')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
#        cbar = plt.colorbar(cs,orientation="horizontal",extend='both')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu')
#            cbar = plt.colorbar(cs,orientation="horizontal",extend='both')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu',extend='both')
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
#                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)

    if plotbox =='y':  # overplot a box showing all the lats and lons
        plt.plot([lonmin,lonmin],[latmin,latmax],'white')
        plt.plot([lonmax,lonmax],[latmin,latmax],'white')
        plt.plot([lonmin,lonmax],[latmin,latmin],'white')
        plt.plot([lonmin,lonmax],[latmax,latmax],'white')
        

    if fileno == 99:  # single plot so add colorbar
        cbar = plt.colorbar(cs,orientation="horizontal")
        cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

##############################################
def get_annmean_precip(exptname,yearstart,yearend,lonmin,lonmax,latmin,latmax,regionname):


    # setup initial values before loop
    plotno=0
    fileform='/nfs/hera1/earjcti/um/HadGEM_data/'+exptname+'/precip_data/'+exptname

    # loop over each year and plot
    for year in range(yearstart,yearend):

        # get fileyear and extra value
        century=np.floor(year/100.)

        choices = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 
                   15: 'f', 16: 'g', 17: 'h', 18: 'i', 19: 'j', 
                   20: 'k', 21: 'l', 22: 'm', 23: 'n', 24: 'o', 
                   25: 'p', 26: 'q', 27: 'r', 28: 's', 29: 't', 
                   30: 'u', 31: 'v', 32: 'w', 33: 'x', 34: 'y', 
                   35: 'z'}

        extra=choices.get(century,99) # the second value is the default v
                                         # value for if it is not found in
                                         # the choices list
      
        yearuse=np.int(year-(century * 100))
        yearuse=str("%02d"%yearuse)
        
        fname=fileform+'a@pd'+extra+np.str(yearuse)+'*.nc'

        print(yearuse)
        print(fname)
        f=MFDataset(fname)
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        aprecip=f.variables['precip_1'][:]
        aprecip=np.squeeze(aprecip)
        ntimes,ny,nx=np.shape(aprecip)
        
        if ntimes !=12:
            print('you have not got 12 months in year ',year)
            print('you have',ntimes)
            sys.exit()
        
    
       #average across the time dimension
        pi_precip_ann=np.mean(aprecip,axis=0)
    
        pi_precip_ann=pi_precip_ann * 60. * 60. * 24. * 30.
       
      

        # shift grid
        lonprecip=lon
        pi_precip_ann,lon = shiftgrid(180.,pi_precip_ann,lon,start=False)
    

        # set up array with all data for averaging
        if year == yearstart:
            pi_precip_ann_allyears=np.zeros((yearend-yearstart,ny,nx))
            areamean_precip=np.zeros(yearend-yearstart)

            
        pi_precip_ann_allyears[year-yearstart,:,:]=pi_precip_ann


        # mask out latitudes required and get average over region

        ix1=(lon >=lonmin) & (lon <=lonmax)
        ix2=(lat >=latmin) & (lat <=latmax)
        lats_reg=lat[ix2]
        lons_reg=lon[ix1]
    
        mask_precip=pi_precip_ann[ix2]
        mask_precip=mask_precip[:,ix1]
        
        areamean_precip[year-yearstart]=np.mean(mask_precip)

        # plot the data and highlight the region of the average
       
        titlename=np.str(year)
        plotbox='y'
        plotdata(pi_precip_ann,plotno,lon,lat,titlename,0,300,1.0,0.0,'y','mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
        plotno=(plotno+1)%9

        if plotno ==0 or year==yearend:
            plt.subplots_adjust(bottom=0.2)
            cax=plt.axes([0.1,0.1,0.8,0.045])
            plt.colorbar(cax=cax,orientation='horizontal')
            axistitle='precip for '+exptname+ 'mm/month'
            plt.title(axistitle)
            
            fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_'+np.str(year)+'_'+regionname+'.eps'
            plt.savefig(fileout, bbox_inches='tight')  

            plt.close()

    # now plot average
    titlename=exptname+'_allavg_'+regionname
    plotdata(np.mean(pi_precip_ann_allyears,axis=0),99,lon,lat,titlename,0,300,1.0,0.0,'y','mm/month',lonmin,lonmax,latmin,latmax,plotbox)
        
    # plot average over region
    plt.subplot(2,1,2)
    plt.plot(areamean_precip)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_regional_precip_indyear/'+exptname+'_annaverage_'+regionname+'.eps'
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()




#end def annmean


def seasmean(m1,m2,m3,figureno,seasname):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/precip_data/xkvjaa@pdm[7-9]*'+m3+'_precip.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    ntimes,ny,nx=np.shape(aprecip)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_aprecip_avg=np.mean(aprecip,axis=0)
    pi_bprecip_avg=np.mean(bprecip,axis=0)
    pi_cprecip_avg=np.mean(cprecip,axis=0)
    
    pi_seasprecip=np.mean((pi_aprecip_avg,pi_bprecip_avg,pi_cprecip_avg),axis=0)
    pi_seasprecip=pi_seasprecip * 60. * 60. * 30. * 24.
    
    
    lonprecip=lon
    pi_seasprecip,lon = shiftgrid(180.,pi_seasprecip,lon,start=False)
    
    plotdata(pi_seasprecip,0,lon,lat,'PI HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month')
    
     #==============
     # Pliocene


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/precip_data/xkvjba@pdm[7-9]*'+m3+'_precip.nc')
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)

    # average across the time dimension    
    plio_aprecip_avg=np.mean(aprecip,axis=0)
    plio_bprecip_avg=np.mean(bprecip,axis=0)
    plio_cprecip_avg=np.mean(cprecip,axis=0)
    
    plio_seasprecip=np.mean((plio_aprecip_avg,plio_bprecip_avg,plio_cprecip_avg),axis=0)
    plio_seasprecip=plio_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    plio_seasprecip,lon = shiftgrid(180.,plio_seasprecip,lon,start=False)
    
    
    plotdata(plio_seasprecip,1,lon,lat,'PI HadGEM2: '+seasname,0,275,25,0.0,'n','mm/month')



     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m1+'_precip.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m2+'_precip.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/precip_data/xkvjca@pdm[7-9]*'+m3+'_precip.nc')
    aprecip=fa.variables['precip_1'][:]
    bprecip=fb.variables['precip_1'][:]
    cprecip=fc.variables['precip_1'][:]
    aprecip=np.squeeze(aprecip)
    bprecip=np.squeeze(bprecip)
    cprecip=np.squeeze(cprecip)
    
    pliop2_aprecip_avg=np.mean(aprecip,axis=0)
    pliop2_bprecip_avg=np.mean(bprecip,axis=0)
    pliop2_cprecip_avg=np.mean(cprecip,axis=0)
    
    pliop2_seasprecip=np.mean((pliop2_aprecip_avg,pliop2_bprecip_avg,pliop2_cprecip_avg),axis=0)
    pliop2_seasprecip=pliop2_seasprecip * 60. * 60. * 30. * 24.

    lon=lonprecip
    pliop2_seasprecip,lon = shiftgrid(180.,pliop2_seasprecip,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seasprecip-pi_seasprecip
    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

    plotdata(plio_anom,2,lon,lat,'Plio - PI Panom_HG2',0,275,25,V,'la','mm/month')
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seasprecip-pi_seasprecip
    V=[-64,-32,-16,-8,-4,-2,0,2,4,8,16,32,64]

    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Panom_HG2',0,275,25,V,'la','mm/month')



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_'+seasname+'anom.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    # Pliocene - preindustrial percentage change

    plio_peranom=((plio_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio-PI precip %'+seasname
    plotdata(plio_peranom,0,lon,lat,titlename,-50,50,5,0,'a','%')

    plio_peranomp2=((pliop2_seasprecip-pi_seasprecip)/pi_seasprecip)*100.
    titlename='Plio+2-PI precip %'+seasname
    plotdata(plio_peranomp2,1,lon,lat,titlename,-50,50,5,0,'a','%')

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surfprecip/MAP_anom_percent_'+seasname+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()




#end def seasmean

################################
# main program

# annual mean
figureno=0

plt.figure(figureno)
get_annmean_precip('xkvjf',2301,2400,-10.0,30.0,15.0,30.0,'Sahara')
figureno=figureno+1

#djf mean
#plt.figure(figureno)
#seasmean('dc','ja','fb',figureno,'djf')
#figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja')
#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_salinity.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SALINITY
#PURPOSE
#    This program will do all the plots to do with salinity
#    we will begin by plotting salinity by depth across the Atlantic
#    However we will move on to other things to do with satlinity
# search for 'main program' to find end of functions
# Julia 19/1/2017



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotmap(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)


   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V)
                cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata
#####################################
def plot_lat_dep(plotdata,fileno,lat,dep,titlename,minval,maxval,valinc,cbarname):
    lats, deps  = np.meshgrid(lat,dep)

    V=np.arange(minval,maxval,valinc)
    
    print(np.shape(plotdata))
    cs = plt.contourf(lats,deps,plotdata,V,extend="both")
    plt.gca().invert_yaxis()

    cbar = plt.colorbar(cs,orientation="horizontal")

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
 
#end def plotdata

#  to check if a character is numeric
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

#============================
def Atlantic_salinity_depth_plot(expt_name):



#  get data from files

    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+expt_name+'/pg2/'+expt_name+'o@pg*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    dep = f.variables['depth_1'][:]
    salin=f.variables['salinity'][:]
    salin=np.squeeze(salin)
    f.close()

    ntimes,ndep,nlat,nlon=np.shape(salin)
    print(ntimes,ndep,nlat,nlon)

    mean_salin=np.mean(salin,axis=0)


    print(np.shape(mean_salin))

#  get mask of Oceans
    filemask='/nfs/see-fs-02_users/earjcti/MOC/merid/basin_hadgom_216'
    f1=open(filemask,'r')
    # discard 3 title lines
    textline=f1.readline()
    textline=f1.readline()
    textline=f1.readline()
    # next line is details from basin
    nrows=nlat
    Indian_d=np.zeros((nrows,4))
    Pacific_d=np.zeros((nrows,4))
    Atlantic_d=np.zeros((nrows,4))
    Combined_d=np.zeros((nrows,4))
    for line in f1:
        linesplit=line.split()  # split line by space
        if is_number(linesplit[0]):
            rowno=int(linesplit[0])
            Indian_d[rowno-1,:]=int(linesplit[1]),int(linesplit[2]),\
                int(linesplit[3]),int(linesplit[4])
            Pacific_d[rowno-1,:]=int(linesplit[5]),int(linesplit[6]),\
                int(linesplit[7]),int(linesplit[8])
            Atlantic_d[rowno-1,:]=int(linesplit[9]),int(linesplit[10]),\
                int(linesplit[11]),int(linesplit[12])
            Combined_d[rowno-1,:]=int(linesplit[13]),int(linesplit[14]),\
                int(linesplit[15]),int(linesplit[16])

    f1.close()

    Indian_mask=np.ones((nlat,nlon),dtype=bool)
    Pacific_mask=np.ones((nlat,nlon),dtype=bool)
    Atlantic_mask=np.ones((nlat,nlon),dtype=bool)
    Combined_mask=np.ones((nlat,nlon),dtype=bool)
    for j in range(0,nrows):
        Indian_mask[j,Indian_d[j,0]:Indian_d[j,1]]=0
        Indian_mask[j,Indian_d[j,2]:Indian_d[j,3]]=0
        Pacific_mask[j,Pacific_d[j,0]:Pacific_d[j,1]]=0
        Pacific_mask[j,Pacific_d[j,2]:Pacific_d[j,3]]=0
        Atlantic_mask[j,Atlantic_d[j,0]:Atlantic_d[j,1]]=0
        Atlantic_mask[j,Atlantic_d[j,2]:Atlantic_d[j,3]]=0
        Combined_mask[j,Combined_d[j,0]:Combined_d[j,1]]=0
        Combined_mask[j,Combined_d[j,2]:Combined_d[j,3]]=0



    # get mean salinity over indian ocean
    Indian_salin=np.ma.masked_array(mean_salin,mask=np.tile(Indian_mask,(mean_salin.shape[0],1)))
    Pacific_salin=np.ma.masked_array(mean_salin,mask=np.tile(Pacific_mask,(mean_salin.shape[0],1)))
    Atlantic_salin=np.ma.masked_array(mean_salin,mask=np.tile(Atlantic_mask,(mean_salin.shape[0],1)))
    Combined_salin=np.ma.masked_array(mean_salin,mask=np.tile(Combined_mask,(mean_salin.shape[0],1)))

    lontemp=lon
    Indian_salin,lon = shiftgrid(180.,Indian_salin,lon,start=False)
    lon=lontemp
    Pacific_salin,lon = shiftgrid(180.,Pacific_salin,lon,start=False)
    lon=lontemp
    Atlantic_salin,lon = shiftgrid(180.,Atlantic_salin,lon,start=False)
    lon=lontemp
    Combined_salin,lon = shiftgrid(180.,Combined_salin,lon,start=False)


   # plotmap(Indian_salin[0,:,:]*1000.,0,lon,lat,'test Ind',-4,4,0.5,0.0,'n','psu')
   # plotmap(Pacific_salin[0,:,:]*1000.,1,lon,lat,'test Pac',-4,4,0.5,0.0,'n','psu')
   # plotmap(Atlantic_salin[0,:,:]*1000.,2,lon,lat,'test Atl',-4,4,0.5,0.0,'n','psu')
   # plotmap(Combined_salin[0,:,:]*1000.,3,lon,lat,'test Com',-4,4,0.5,0.0,'n','psu')
   # plt.show()


    # julia note - atlantic basin is fine - not sure about other ones


    # now average the salinity across the latitude over the Atlantic basin

    print('Atl Salin',np.shape(Atlantic_salin))
    Atlantic_sal_avg=np.mean(Atlantic_salin,axis=2)
    print('Atl salin mean',np.shape(Atlantic_sal_avg),np.shape(lat),np.shape(dep))
    

    titlename='Atlantic Salinity: '+expt_name
    plot_lat_dep((Atlantic_sal_avg*1000.)+35.0,0,lat,dep,titlename,33,36,0.2,'psu')


    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/'+expt_name+'_salinity.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()

    return(lat,dep,Atlantic_sal_avg)
    

#end def Atlantic_salinity_depth_plot
#end def annmean



################################
# main program

# annual mean salinity by depth

retdata=Atlantic_salinity_depth_plot('xkvjg')
lat=retdata[0]
dep=retdata[1]
xkvjg_salinity=retdata[2]

retdata=Atlantic_salinity_depth_plot('xkvjf')
xkvjf_salinity=retdata[2]

retdata=Atlantic_salinity_depth_plot('xkvje')
xkvje_salinity=retdata[2]


# plot lat depthanomalies
titlename='Atlantic Salinity xkvjg - xkvje'
sal_anom=xkvjg_salinity-xkvje_salinity
plot_lat_dep((sal_anom*1000.),0,lat,dep,titlename,-0.5,0.6,0.1,'psu')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/xkvjg-xkvje_salinity_anom.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()

titlename='Atlantic Salinity xkvjf - xkvje'
sal_anom=xkvjf_salinity-xkvje_salinity
plot_lat_dep((sal_anom*1000.),0,lat,dep,titlename,-0.5,0.6,0.1,'psu')
fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_salin/xkvjf-xkvje_salinity_anom.eps' 
plt.savefig(fileout, bbox_inches='tight')  
plt.close()



sys.exit(0)

####

::::::::::::::
plot_surftemp_incl_HadCM3.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFTEMP
#PURPOSE
#    This program will plot the temperature (annual and seasonal) and
#    the temperature anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='l')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.),extend="both")
        cbar = plt.colorbar(cs,orientation="horizontal")
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r',extend="both")
            cbar = plt.colorbar(cs,orientation="horizontal")

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r',extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend="both")
                cbar = plt.colorbar(cs,orientation="horizontal",)

    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)
#end def plotdata

def annmean(switch,HadCM3):
    # switch is a dummy variable to allow the program to be called
    #==============
    # preindustrial


    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]
        titlePI='PI-TAnn_HadCM3'
        titlediff='Plio - PI Tanom_HadCM3'
    else:
    # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/temp_data/xkvjaa@pdm[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp_1'][:]
        titlePI='PI-TAnn_HadGEM2'
        titlediff='Plio - PI Tanom_HadGEM2'

    

    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_temp_ann=np.mean(atemp,axis=0)
    print('new shape',np.shape(pi_temp_ann))
    
    
    plt.figure(0)
    degC=u'\N{DEGREE SIGN}'+'C'
    lontemp=lon
    pi_temp_ann,lon = shiftgrid(180.,pi_temp_ann,lon,start=False)
    
    plotdata(pi_temp_ann-273.15,0,lon,lat,titlePI,-50,50,5.0,0.0,'n',degC)


     #==============
     # Pliocene

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xibol_netcdf/xibola@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        atemp=f.variables['temp'][:]
        titlePlio='Plio-TAnn_HadCM3'

    else:
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/temp_data/xkvjba@pdm[7-9]*.nc')
        atemp=f.variables['temp_1'][:]
        titlePlio='Plio-TAnn_HadGEM2'


    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)

    plio_temp_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_temp_ann))

    lon=lontemp
    plio_temp_ann,lon = shiftgrid(180.,plio_temp_ann,lon,start=False)

    plotdata(plio_temp_ann-273.15,1,lon,lat,titlePlio,-50,50,5.0,0.0,'n',degC)


     #==============
     # Pliocene+2

    if HadCM3 != 'y':
        # read in data from multiple files
        f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/temp_data/xkvjca@pdm[7-9]*.nc')
        atemp=f.variables['temp_1'][:]
        atemp=np.squeeze(atemp)
        ntimes,ny,nx=np.shape(atemp)
        print(ntimes,ny,nx)
        
    #average across the time dimension
        plio_tempp2_ann=np.mean(atemp,axis=0)
        print('new shape plio',np.shape(plio_tempp2_ann))
        lon=lontemp
        plio_tempp2_ann,lon = shiftgrid(180.,plio_tempp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_temp_ann-pi_temp_ann

    #V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    plotdata(plio_anom,2,lon,lat,titlediff,0,10,1.0,0,'n',degC)
    
    # Pliocene+2 - preindustrial

    if HadCM3 != 'y':
        pliop2_anom=plio_tempp2_ann-pi_temp_ann
        #V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
        plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,0,'n',degC)


    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  


    
    plt.close()


#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,HadCM3):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/temp_data/xkvjaa@pdm[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/temp_data/xkvjaa@pdm[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvja/temp_data/xkvjaa@pdm[7-9]*'+m3+'_temp.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    ntimes,ny,nx=np.shape(atemp)
    
#average across the time dimension
    pi_atemp_avg=np.mean(atemp,axis=0)
    pi_btemp_avg=np.mean(btemp,axis=0)
    pi_ctemp_avg=np.mean(ctemp,axis=0)
    
    pi_seastemp=np.mean((pi_atemp_avg,pi_btemp_avg,pi_ctemp_avg),axis=0)
    print('seastemp',np.shape(pi_seastemp))
    
    
    degC=u'\N{DEGREE SIGN}'+'C'
    
    lontemp=lon
    pi_seastemp,lon = shiftgrid(180.,pi_seastemp,lon,start=False)

    lon=lontemp
    pi_atemp_avg,lon = shiftgrid(180.,pi_atemp_avg,lon,start=False)
    
    plotdata(pi_seastemp-273.15,0,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)

    plotdata(pi_atemp_avg-273.15,1,lon,lat,'PI HadGEM2: december ',-50,50,5.0,0.0,'n',degC)

    plt.show()
    sys.exit()

    
     #==============
     # Pliocene


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/temp_data/xkvjba@pdm[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/temp_data/xkvjba@pdm[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjb/temp_data/xkvjba@pdm[7-9]*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)

    # average across the time dimension    
    plio_atemp_avg=np.mean(atemp,axis=0)
    plio_btemp_avg=np.mean(btemp,axis=0)
    plio_ctemp_avg=np.mean(ctemp,axis=0)
    
    plio_seastemp=np.mean((plio_atemp_avg,plio_btemp_avg,plio_ctemp_avg),axis=0)
    print('seastemp',np.shape(plio_seastemp))

    lon=lontemp
    plio_seastemp,lon = shiftgrid(180.,plio_seastemp,lon,start=False)
    
    
    plotdata(plio_seastemp-273.15,1,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)



     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/temp_data/xkvjca@pdm[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/temp_data/xkvjca@pdm[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/xkvjc/temp_data/xkvjca@pdm[7-9]*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    
    pliop2_atemp_avg=np.mean(atemp,axis=0)
    pliop2_btemp_avg=np.mean(btemp,axis=0)
    pliop2_ctemp_avg=np.mean(ctemp,axis=0)
    
    pliop2_seastemp=np.mean((pliop2_atemp_avg,pliop2_btemp_avg,pliop2_ctemp_avg),axis=0)
    print('seastemp',np.shape(pliop2_seastemp))

    lon=lontemp
    pliop2_seastemp,lon = shiftgrid(180.,pliop2_seastemp,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    plotdata(plio_anom,2,lon,lat,'Plio - PI Tanom_HG2',-50,50,5.0,V,'la',degC)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',-50,50,5.0,V,'la',degC)



    if HadCM3 == 'y':
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom_HadCM3.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom_HadCM3.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    else:
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom.eps' 
        plt.savefig(fileout, bbox_inches='tight')  
        
        fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom.tiff' 
        plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    plt.figure(1)

#end def annmean

################################
# main program

# annual mean
figureno=0

HadCM3='y'

#plt.figure(figureno)
#annmean('y',HadCM3)
#figureno=figureno+1

#djf mean
plt.figure(figureno)
seasmean('dc','ja','fb',figureno,'djf',HadCM3)
figureno=figureno+1

#jja mean
#plt.figure(figureno)
#seasmean('jn','jl','ag',figureno,'jja',HadCM3)
#figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_surftemp.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_SURFTEMP
#PURPOSE
#    This program will plot the temperature (annual and seasonal) and
#    the temperature anomaly (annual and seasonal) for the final 30 years
#    of the HadGEM2 simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016



import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid


#functions are:
#  def plotdata
#  def annmean
#  def seasmean

# functions start here
def plotdata(plotdata,fileno,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)
    plt.subplot(2,2,fileno+1)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe

    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary

    x, y = map(lons, lats)

    map.drawcoastlines()
    if V == 0:
        V=np.arange(minval,maxval,valinc)
    if uselog =='y':
        cs = map.contourf(x,y,plotdata,V,norm=mp.colors.PowerNorm(gamma=1./3.))
        cbar = plt.colorbar(cs,orientation="horizontal",extend='max')
    else:
        if uselog =='la':
            cs = map.contourf(x,y,plotdata,V,norm=mp.colors.SymLogNorm(linthresh=2.0,linscale=2.0,vmin=-32,vmax=32),cmap='RdBu_r')
            cbar = plt.colorbar(cs,orientation="horizontal",extend='max')

        else:
            if uselog =='a':
                cs = map.contourf(x,y,plotdata,V,cmap='RdBu_r')
                cbar = plt.colorbar(cs,orientation="horizontal")
            else:
                print(np.shape(plotdata))
                cs = map.contourf(x,y,plotdata,V,extend='both')
                cbar = plt.colorbar(cs,orientation="horizontal")


    plt.title(titlename)
    cbar.set_label(cbarname,labelpad=-40)

#end def plotdata

def annmean(switch,preind_expt,plio_expt,pliop2_expt,extra):
    # switch is a dummy variable to allow the program to be called
    #==============
    # preindustrial


    # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[7-9]*.nc')
    lat = f.variables['latitude'][:]
    lon = f.variables['longitude'][:]
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_temp_ann=np.mean(atemp,axis=0)
    print('new shape',np.shape(pi_temp_ann))
    
    
    plt.figure(0)
    degC=u'\N{DEGREE SIGN}'+'C'
    lontemp=lon
    pi_temp_ann,lon = shiftgrid(180.,pi_temp_ann,lon,start=False)
    
    print('about to plot')

    plotdata(pi_temp_ann-273.15,0,lon,lat,'PI-Ann_HadGEM2',-50,50,5.0,0.0,'n',degC)
    print('plotted first')


     #==============
     # Pliocene


    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'[7-9]*.nc')
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)

    plio_temp_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_temp_ann))

    lon=lontemp
    plio_temp_ann,lon = shiftgrid(180.,plio_temp_ann,lon,start=False)

    plotdata(plio_temp_ann-273.15,1,lon,lat,'Plio-TAnn_HG2',-50,50,5.0,0.0,'n',degC)


     #==============
     # Pliocene+2


     # read in data from multiple files
    f=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*.nc')
    atemp=f.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
    #average across the time dimension
    plio_tempp2_ann=np.mean(atemp,axis=0)
    print('new shape plio',np.shape(plio_tempp2_ann))
    lon=lontemp
    plio_tempp2_ann,lon = shiftgrid(180.,plio_tempp2_ann,lon,start=False)




    # Pliocene - preindustrial

    plio_anom=plio_temp_ann-pi_temp_ann

    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(plio_anom,2,lon,lat,'Plio - PI Tanom_HG2',0,10,1.0,V,'n',degC)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=plio_tempp2_ann-pi_temp_ann
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,V,'n',degC)



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_anom'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()


#end def annmean


def seasmean(m1,m2,m3,figureno,seasname,preind_expt,plio_expt,pliop2_expt,extra):
    # m1 m2 m3 are the month neames needed to reproduce the seasonal mean
    #==============
    # preindustrial

   
    # read in data from multiple files
    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+preind_expt+'/temp_data/'+preind_expt+'a@pd'+extra+'[7-9]*'+m3+'_temp.nc')
    lat = fa.variables['latitude'][:]
    lon = fa.variables['longitude'][:]
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    ntimes,ny,nx=np.shape(atemp)
    print(ntimes,ny,nx)
    
#average across the time dimension
    pi_atemp_avg=np.mean(atemp,axis=0)
    pi_btemp_avg=np.mean(btemp,axis=0)
    pi_ctemp_avg=np.mean(ctemp,axis=0)
    
    pi_seastemp=np.mean((pi_atemp_avg,pi_btemp_avg,pi_ctemp_avg),axis=0)
    print('seastemp',np.shape(pi_seastemp))
    
    
    degC=u'\N{DEGREE SIGN}'+'C'
    
    lontemp=lon
    pi_seastemp,lon = shiftgrid(180.,pi_seastemp,lon,start=False)
    
    plotdata(pi_seastemp-273.15,0,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)
    
     #==============
     # Pliocene


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+plio_expt+'/temp_data/'+plio_expt+'a@pd'+extra+'[7-9]*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)

    # average across the time dimension    
    plio_atemp_avg=np.mean(atemp,axis=0)
    plio_btemp_avg=np.mean(btemp,axis=0)
    plio_ctemp_avg=np.mean(ctemp,axis=0)
    
    plio_seastemp=np.mean((plio_atemp_avg,plio_btemp_avg,plio_ctemp_avg),axis=0)
    print('seastemp',np.shape(plio_seastemp))

    lon=lontemp
    plio_seastemp,lon = shiftgrid(180.,plio_seastemp,lon,start=False)
    
    
    plotdata(plio_seastemp-273.15,1,lon,lat,'PI HadGEM2: '+seasname,-50,50,5.0,0.0,'n',degC)



     #==============
     # Pliocene+2


    fa=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m1+'_temp.nc')
    fb=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m2+'_temp.nc')
    fc=MFDataset('/nfs/hera1/earjcti/um/HadGEM_data/'+pliop2_expt+'/temp_data/'+pliop2_expt+'a@pd'+extra+'[7-9]*'+m3+'_temp.nc')
    atemp=fa.variables['temp_1'][:]
    btemp=fb.variables['temp_1'][:]
    ctemp=fc.variables['temp_1'][:]
    atemp=np.squeeze(atemp)
    btemp=np.squeeze(btemp)
    ctemp=np.squeeze(ctemp)
    
    pliop2_atemp_avg=np.mean(atemp,axis=0)
    pliop2_btemp_avg=np.mean(btemp,axis=0)
    pliop2_ctemp_avg=np.mean(ctemp,axis=0)
    
    pliop2_seastemp=np.mean((pliop2_atemp_avg,pliop2_btemp_avg,pliop2_ctemp_avg),axis=0)
    print('seastemp',np.shape(pliop2_seastemp))

    lon=lontemp
    pliop2_seastemp,lon = shiftgrid(180.,pliop2_seastemp,lon,start=False)
    
 

    # Pliocene - preindustrial

    plio_anom=plio_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(plio_anom,2,lon,lat,'Plio - PI Tanom_HG2',0,10,1.0,V,'n',degC)
    
    # Pliocene+2 - preindustrial

    pliop2_anom=pliop2_seastemp-pi_seastemp
    V=[-32,-16,-8,-4,-2,-1,-0.5,0,0.5,1,2,4,8,16,32]
    V=0
    plotdata(pliop2_anom,3,lon,lat,'PlioP2 - PI Tanom_HG2',0,10,1.0,V,'n',degC)



    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_surftemp/MAT_'+seasname+'anom'+pliop2_expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  

    plt.close()
    plt.figure(1)

#end def annmean

################################
# main program

# annual mean
figureno=0

preind_expt='xkvje'
plio_expt='xkvjf'
pliop2_expt='xkvjg'
extra='n'


plt.figure(figureno)
annmean('y',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1

#djf mean
plt.figure(figureno)
seasmean('dc','ja','fb',figureno,'djf',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1

#jja mean
plt.figure(figureno)
seasmean('jn','jl','ag',figureno,'jja',preind_expt,plio_expt,pliop2_expt,extra)
figureno=figureno+1


sys.exit(0)

####

::::::::::::::
plot_winds.py
::::::::::::::
#!/usr/bin/env python2.7
#NAME
#    PLOT_RADIATION
#PURPOSE
#    This program will plot the radiation budget for the pliocene simulations
#
# search for 'main program' to find end of functions
# Julia 22/11/2016


import os
import numpy as np
import scipy as sp
import matplotlib as mp
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from netCDF4 import Dataset, MFDataset
import sys
from mpl_toolkits.basemap import Basemap, shiftgrid

sys.path.append('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/COMMON')
from jumaps import contourglobe


#functions are:
#  def plotquiver
#  def annmean
#  def seasmean

# functions start here
def plotquiver(udata,vdata,lon,lat,titlename,minval,maxval,valinc,V,uselog,cbarname):
    lons, lats = np.meshgrid(lon,lat)

   # this is good for a tropical region
   # map=Basemap(llcrnrlon=10.0,urcrnrlon=70.0,llcrnrlat=10.0,urcrnrlat=55.0,projection='cyl',resolution='c')
   # this is good for the globe
    map=Basemap(llcrnrlon=-180.0,urcrnrlon=180.0,llcrnrlat=-90.0,urcrnrlat=90.0,projection='cyl',resolution='c')
    #map.drawmapboundary(fill_color='aqua')
    map.drawmapboundary
    x, y = map(lons, lats)
    map.drawcoastlines()
    # quiver plot every nth arrow
    n=5
    qv = map.quiver(x[::n,::n],y[::n,::n],udata[::n,::n],vdata[::n,::n],pivot='mid')
    plt.title(titlename)

#end def plotquiver

########################################################
def annmean(switch,HadCM3,expt,extra):
    # switch is a dummy variable to allow the program to be called

    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/netcdf/'
        filename=expt+'a@pd'+extra+'[7-9]*.nc'
        os.system('ls '+dirname+filename)
        os.system('ls '+dirname+filename+' | wc -l')
        nval=os.system('ls '+dirname+filename+' | wc -l')
        allfiles=subprocess.check_output('ls '+dirname+filename+' | wc -l',shell=True)
        print('number of files=',allfiles)
        f=MFDataset(dirname+filename)
        lat = f.variables['latitude_1'][:]
        lon = f.variables['longitude_1'][:]
        
        # we will plot 10 m winds (called u and v)
        
        u=f.variables['u'][:]
        v=f.variables['v'][:]


    u=np.squeeze(u)
    v=np.squeeze(v)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
#average across the time dimension
    u_ann=np.mean(u,axis=0)
    v_ann=np.mean(v,axis=0)
    
    
    plt.figure(0)
    ms='m/s'
    lontemp=lon
    titlename=expt+' winds'
    u_ann,lon = shiftgrid(180.,u_ann,lon,start=False)    
    lon=lontemp
    v_ann,lon = shiftgrid(180.,v_ann,lon,start=False)    
    plotquiver(u_ann,v_ann,lon,lat,titlename,0,400,40.0,0.0,'n',ms)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/annmean_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()


#end def annmean



########################################################
def seasmean(m1,m2,m3,seasname,HadCM3,expt,extra):
 
    if HadCM3 == 'y':
        f=MFDataset('/nfs/hera1/earjcti/um/netcdf/xiboi_netcdf/xiboia@pdy[7-9]*.nc')
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
        lat = f.variables['latitude'][:]
        lon = f.variables['longitude'][:]
    else:
    # read in data from multiple files
        dirname='/nfs/hera1/earjcti/um/HadGEM_data/'+expt+'/winds_data/'
        filea=expt+'a@pd*'+m1+'_winds.nc'
        fileb=expt+'a@pd*'+m2+'_winds.nc'
        filec=expt+'a@pd*'+m3+'_winds.nc'
        os.system('ls '+dirname+filea+' | wc -l')
        os.system('ls '+dirname+fileb+' | wc -l')
        os.system('ls '+dirname+filec+' | wc -l')
        print(dirname+filea)
        fa=MFDataset(dirname+filea)
        fb=MFDataset(dirname+fileb)
        fc=MFDataset(dirname+fileb)

        lat = fa.variables['latitude_1'][:]
        lon = fa.variables['longitude_1'][:]
        au=fa.variables['u'][:]
        bu=fb.variables['u'][:]
        cu=fc.variables['u'][:]
        au=np.squeeze(au)
        bu=np.squeeze(bu)
        cu=np.squeeze(cu)


        av=fa.variables['v'][:]
        bv=fb.variables['v'][:]
        cv=fc.variables['v'][:]
        av=np.squeeze(av)
        bv=np.squeeze(bv)
        cv=np.squeeze(cv)
        ntimes,ny,nx=np.shape(au)
        print(ntimes,ny,nx)
    
        print(np.shape(au),np.shape(bu),np.shape(cu))
        u=au+bu+cu
        v=av+bv+cv

    u=np.squeeze(u)
    v=np.squeeze(v)
    ntimes,ny,nx=np.shape(u)
    print(ntimes,ny,nx)
    
#average across the time dimension
    u_seas=np.mean(u,axis=0)
    v_seas=np.mean(v,axis=0)
    
    
    plt.figure(0)
    ms='m/s'
    lontemp=lon
    titlename=expt+' winds:'+seasname
    u_seas,lon = shiftgrid(180.,u_seas,lon,start=False)    
    lon=lontemp
    v_seas,lon = shiftgrid(180.,v_seas,lon,start=False)    
    plotquiver(u_seas,v_seas,lon,lat,titlename,0,400,40.0,0.0,'n',ms)

    fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+expt+'.eps' 
    plt.savefig(fileout, bbox_inches='tight')  
    
    plt.close()

    retdata=[u_seas, v_seas,lon,lat]

    return retdata

#end def seasmean



################################
# main program

# annual mean
figureno=0

HadCM3='n'
#exptname='ximuq'
#extra='l'

exptname='xkvjf'  #xkvje xkvjf xkvjg
extra='n'
controlname='xkvje'
controlextra='n'

#annmean('y',HadCM3,exptname,extra)
#figureno=figureno+1



#==================================
#
#  SEASONAL
#
#
#djf mean
seasname='djf'
retdata=seasmean('dc','ja','fb',seasname,HadCM3,exptname,extra)
u_seas=retdata[0]
v_seas=retdata[1]
lon=retdata[2]
lat=retdata[3]

# get djfmean from control
retdata=seasmean('dc','ja','fb',seasname,HadCM3,controlname,controlextra)
u_ctl=retdata[0]
v_ctl=retdata[1]
lon=retdata[2]
lat=retdata[3]

# plot djf anomaly
titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  
    
plt.close()


# do some contour plots of u and v for djf

titlename='u: '+exptname
contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='v: '+exptname
contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='u: '+controlname
contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='v: '+controlname
contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='uanom'
contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
titlename='vanom'
contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'u_and_v.eps' 
plt.savefig(fileout, bbox_inches='tight')  
    
plt.close()



#jja mean
seasname='jja'
retdata=seasmean('jn','jl','ag',seasname,HadCM3,exptname,extra)
u_seas=retdata[0]
v_seas=retdata[1]
lon=retdata[2]
lat=retdata[3]

# get jjamean from control
retdata=seasmean('jn','jl','ag',seasname,HadCM3,controlname,controlextra)
u_ctl=retdata[0]
v_ctl=retdata[1]
lon=retdata[2]
lat=retdata[3]

# plot jja anomaly
titlename=exptname+'-'+controlname+':'+seasname+': wind anomaly'
plotquiver(u_seas-u_ctl,v_seas-v_ctl,lon,lat,titlename,0,400,40.0,0.0,'n','m/s)')

fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_'+exptname+'-'+controlname+'.eps' 
plt.savefig(fileout, bbox_inches='tight')  
    
plt.close()


# do some contour plots of u and v for jja

titlename='u: '+exptname
contourglobe(u_seas,3,2,0,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='v: '+exptname
contourglobe(v_seas,3,2,1,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='u: '+controlname
contourglobe(u_ctl,3,2,2,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='v: '+controlname
contourglobe(v_ctl,3,2,3,lon,lat,titlename,-20,22,2,0,'n','m/s','c')
titlename='uanom'
contourglobe(u_seas-u_ctl,3,2,4,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')
titlename='vanom'
contourglobe(v_seas-v_ctl,3,2,5,lon,lat,titlename,-3,3.3,0.3,0,'n','m/s','c')


fileout='/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/HadGEM2/plot_winds/'+seasname+'_and_'+exptname+'-'+controlname+'u_and_v.eps' 
plt.savefig(fileout, bbox_inches='tight')  
    
plt.close()




#jja mean
#seasmean('jn','jl','ag','jja',HadCM3,exptname,extra)





sys.exit(0)

####

