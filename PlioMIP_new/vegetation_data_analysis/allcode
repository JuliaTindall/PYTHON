::::::::::::::
assess_CO2.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array


def get_single_model(model, latreq, lonreq, exptid):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + exptid + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_mean_array = np.zeros(nsites)
    plio_min_array = np.zeros(nsites)
    plio_max_array = np.zeros(nsites)
   
    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_array = plio_cube.data[:, lat_ix, lon_ix]
        plio_min_array[i] = np.min(plio_array)
        plio_max_array[i] = np.max(plio_array)
        plio_mean_array[i] = np.mean(plio_array)

   
    return plio_mean_array, plio_max_array, plio_min_array

 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns temperatures
    """

    dfs = pd.read_excel(LAND_DATAFILE)
    sites = []
    lats = []
    lons = []
    temps = []
    temp_modern = []
    temp_uncert = []

    row_locs = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12]
    for rl in row_locs:
        # if temp ne nan then move to array
        temp = dfs.iloc[rl, 9]
        
        print(temp,'julia')
        if np.isfinite(temp):
            sites.append(dfs.iloc[rl, 0])
            lats.append(dfs.iloc[rl, 2])
            lons.append(dfs.iloc[rl, 3])
            temp_modern.append(dfs.iloc[rl, 4])
            temp_uncert.append(dfs.iloc[rl,10])
            temps.append(temp)

    print(temp_uncert)
    for i, temp in enumerate(temp_uncert):
        if i > 0:
            temp2 = temp[2:]
        else:
            temp2=0.0
        print(temp, temp2)
        temp_uncert[i]=np.float(temp2)
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
        label = ''.join([c for c in site if c.isupper()])
        if lats[i] < 0:
            latstr = np.str(np.int(np.round(lats[i] * -1.0, 0))) + deg +  'S'
        else:
            latstr = np.str(np.int(np.around(lats[i], 0))) + deg + 'N'
        if lons[i] < 0:
            lonstr = np.str(np.int(np.round(lons[i] * -1.0, 0))) + deg +  'W'
        else:
            lonstr = np.str(np.int(np.around(lons[i], 0))) + deg + 'E'
        
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return lats, lons, temps, temp_modern, temp_uncert, labels

 

def plot_figure(plio_temp_obs, plio_model_400, plio_model_450, labels, ax, fig):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    #ax1 = ax.axes(frameon=False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
    #ax.axes.get_yaxis().set_visible(False)
    #ax.get_xaxis().tick_bottom()
   

    yarray = np.arange(1, len(plio_temp_obs) + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
   
    # plot individual models for pliocene
    model_400_anom = np.zeros(np.shape(plio_model_400))
    model_450_anom = np.zeros(np.shape(plio_model_450))
    colors = ['black','green','orange']
    for i, model in enumerate(MODELNAMES):
        model_400_anom[:, i] = plio_model_400[:, i] - plio_temp_obs  
        model_450_anom[:, i] = plio_model_450[:, i] - plio_temp_obs  
        plt.scatter(model_400_anom[:, i], yarray, marker = 'o', 
                        color = colors[i], s=30)
        plt.scatter(model_450_anom[:, i], yarray-0.2, marker = '^',
                       color = colors[i], s=30)
       
  
    # add site labels
    plt.text(-5.0, yarray[7], labels[7], ha='right')
    for j in range(0, 7):
        plt.text(np.min(model_400_anom[j, :]) - 1.0,
                 yarray[j], labels[j], ha='right')

    plt.xlabel('Temperature difference from observations (deg C)')
    #fig.legend(loc = 'center left')
    plt.title('a) Annual Mean Temperature', loc='left')

  
    plt.xlim(-25, 7.5)
    plt.ylim(9, 0)
   
def get_land_warm_cold():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle
    sitedata.append(['Meighen Island', 80, 261, 19.6, 20.5,
                     11.5, 13.5, -11.6, -11.4,
                     -33.0, -18.5])
    sitedata.append(['Beaver Pond', 79, 278, 18.4, 20.9,
                     np.nan, np.nan, -12.2, -11.5, np.nan, np.nan])
    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    np.nan, np.nan, np.nan, np.nan, np.nan, np.nan])
    sitedata.append(['Lost Chicken Mine', 64, 142, 12.0, 12.0, 
                     13.5, 16.0, -2.0, -2.0, -27.75, -19.25])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     np.nan, np.nan, -1.67, 1.07, np.nan, np.nan])
                     

    sites = []
    lats = []
    lons = []
    WMMT_veg_min = []
    WMMT_veg_max = []
    WMMT_beetle_min = []
    WMMT_beetle_max = []
    CMMT_veg_min = []
    CMMT_veg_max = []
    CMMT_beetle_min = []
    CMMT_beetle_max = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_veg_min.append(info[3])
        WMMT_veg_max.append(info[4])
        WMMT_beetle_min.append(info[5])
        WMMT_beetle_max.append(info[6])
        CMMT_veg_min.append(info[7])
        CMMT_veg_max.append(info[8])
        CMMT_beetle_min.append(info[9])
        CMMT_beetle_max.append(info[10])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_veg_min),
             np.asarray(WMMT_veg_max), np.asarray(WMMT_beetle_min),
             np.asarray(WMMT_beetle_max), np.asarray(CMMT_veg_min),
             np.asarray(CMMT_veg_max), np.asarray( CMMT_beetle_min),
             np.asarray(CMMT_beetle_max))


def plot_seas_fig(veg_temp, beetle_temp, plio_model_400,
                     plio_model_450, labels, ax, fig, wc_ind):
    """
    this subroutine tries to plot the figure for the paper which shows how 
    different values of CO2 affect the seasonal anomaly
    """

    nmods = len(veg_temp)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
   
    yarray = np.arange(1, nmods + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
    plt.hlines(y=8.95, xmin=-25, xmax=7.5, linewidth=0.5)
   
    # plot individual models for pliocene
    model_400_anom = np.zeros(np.shape(plio_model_400))
    model_450_anom = np.zeros(np.shape(plio_model_450))
    model_450_beetle_anom = np.zeros(np.shape(plio_model_450))
    colors = ['black','green','orange']
    for i, model in enumerate(MODELNAMES):
       
        model_400_anom[:, i] = plio_model_400[:, i] - veg_temp 
        model_450_anom[:, i] = plio_model_450[:, i] - veg_temp  
        model_450_beetle_anom[:, i] = plio_model_450[:, i] - beetle_temp
        ax.scatter(model_400_anom[:, i], yarray - 0.2, marker = 'o', 
                        color = colors[i], s=30, label=model + ' 400ppmv - vegdata')
        ax.scatter(model_450_anom[:, i], yarray, marker = '^',
                       color = colors[i], s=30, label = model + ' 450ppmv - vegdata')
        ax.scatter(model_450_beetle_anom[:, i], yarray + 0.2, marker = 's',
                    color = colors[i], s=30, label= model + ' 450ppmv - beetledata')
   
    # add site labels
    if wc_ind == 'c':
        for j in [0, 1, 3, 4]:
            plt.text(0.5,
                     yarray[j], labels[j], ha='left')
        plt.title('c) Cold Month Temperature', loc='left')
        print(labels[j], model_400_anom[j, :], model_450_anom[j, :], model_450_anom[j, :] -  model_400_anom[j, :], MODELNAMES)

    else:
        for j in range(0, 5):
            plt.text(-20, yarray[j], labels[j], ha='right')
        plt.title('b) Warm Month Temperature', loc='left')



        
    if wc_ind == 'c':
        plt.xlabel('Temperature difference from observations (deg C)')
        handles, labs = fig.gca().get_legend_handles_labels()
        order = [0, 3, 6, 1, 4, 7, 2, 5, 8, ]
        fig.legend([handles[i] for i in order], 
                   [labs[i] for i in order],
                   loc = 'center left')
       # fig.legend(loc='center left')
  
    plt.xlim(-35, 15)
    plt.ylim(nmods + 1, 0)
   
  

  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    """

   
    # get land observations and cru temperature at land points
    
    (land_lats, land_lons, land_temp, 
     modern_temp, plio_unc, land_labels)= get_land_obs()
   
    
    # get ind models data
    all_models_plio_400 = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_450 = np.zeros((len(land_lons), len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind400, ind400WMT, 
         ind400CMT) = get_single_model(model, land_lats, land_lons, 'EOI400')
        all_models_plio_400[:, i] = ind400
        
        (ind450, ind450WMT,
         ind450CMT) = get_single_model(model, land_lats, land_lons, 'EOI450')
        all_models_plio_450[:, i] = ind450
        

  
    # get warm month and cold month temperatures from data
    (sites, land_lats, land_lons, WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min,
     WMMT_beetle_max, CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min,
     CMMT_beetle_max) =  get_land_warm_cold()

    # get warm month and cold month temperatures from model
    allmod_plio_400_wmt = np.zeros((len(land_lons), len(MODELNAMES)))
    allmod_plio_450_wmt = np.zeros((len(land_lons), len(MODELNAMES)))
    allmod_plio_400_cmt = np.zeros((len(land_lons), len(MODELNAMES)))
    allmod_plio_450_cmt = np.zeros((len(land_lons), len(MODELNAMES)))
   
    for i, model in enumerate(MODELNAMES):
        (ind400, ind400WMT, 
         ind400CMT) = get_single_model(model, land_lats, land_lons, 'EOI400')
        allmod_plio_400_wmt[:, i] = ind400WMT
        allmod_plio_400_cmt[:, i] = ind400CMT
        
        (ind450, ind450WMT,
         ind450CMT) = get_single_model(model, land_lats, land_lons, 'EOI450')
        allmod_plio_450_wmt[:, i] = ind450WMT
        allmod_plio_450_cmt[:, i] = ind450CMT
  

    # plot figure annual mean
    fig1 = plt.figure(figsize=[12.0, 12.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=2, ncols=2)

    ax1 = fig1.add_subplot(gs[:,0])
    plot_figure(land_temp,  all_models_plio_400, all_models_plio_450, 
                land_labels, ax1, fig1) 

  
    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_veg_min + WMMT_veg_max) / 2.0, 
                  (WMMT_beetle_min + WMMT_beetle_max) / 2.0,
                  allmod_plio_400_wmt, allmod_plio_450_wmt, sites, 
                  ax2, fig1, 'w')

    ax3 = fig1.add_subplot(gs[1,1])
    plot_seas_fig((CMMT_veg_min + CMMT_veg_max) / 2.0, 
                  (CMMT_beetle_min + CMMT_beetle_max) / 2.0,
                  allmod_plio_400_cmt, allmod_plio_450_cmt, sites, ax3, 
                  fig1, 'c')

  
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/CO2_uncertainty.eps')
    plt.savefig(fileout)


##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'

MODELNAMES = ['COSMOS', 'HadCM3', 'MIROC4m']

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
assess_different_orbits_old.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs

import sys




def get_single_model(expt, latreq, lonreq):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    
    nsites = len(latreq)
    months = ['January','February','March','April','May','June','July','August','September','October','November','December']
    monthalt = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    seas_field = np.zeros((len(months), nsites))

    plio_mean_array = np.zeros(nsites)
    plio_min_array = np.zeros(nsites)
    plio_max_array = np.zeros(nsites)
   
  
 
    # can change this to calendar corrected files
    for j, month in enumerate(months):
        if expt in ('xozzb', 'xozzc','xozzd','xozzf','xibol'):
            filename = ('/nfs/hera1/earjcti/um/' + expt +
                        '/database_averages/' + expt + 
                        '_Monthly_Average_' + month 
                        + '_a@pd_Temperature.nc')
            cubetemp = iris.load_cube(filename)
      
        else:
            filename = ('/nfs/hera1/earjcti/um/'+ expt + 
                        '/cal_cor/' + expt + 'a@pa_avg'+ monthalt[j] + '.nc')
            cube2 = iris.load_cube(filename, 
                                      'SURFACE TEMPERATURE AFTER TIMESTEP')
            cubetemp = cube2.collapsed(['t'], iris.analysis.MEAN)
        cube = iris.util.squeeze(cubetemp)
       
        for i in range(0,nsites):
            # modellon is whole numbers from 0-360
            # lat is half numbers from -89.5 to 89.5

            modlon = np.around(lonreq[i])
            if modlon < 0: modlon = modlon + 360.

            lat_ix = ((np.abs(cube.coord('latitude').points 
                              - latreq[i])).argmin())
            lon_ix = ((np.abs(cube.coord('longitude').points 
                         - modlon)).argmin())

            seas_field[j, i] = cube.data[lat_ix, lon_ix]
    
    for i in range(0, nsites):
        plio_min_array[i] = np.min(seas_field[:, i]) - 273.15
        plio_max_array[i] = np.max(seas_field[:, i]) - 273.15
        plio_mean_array[i] = np.mean(seas_field[:, i]) - 273.15

   
    return plio_mean_array, plio_max_array, plio_min_array

 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns temperatures
    """

    dfs = pd.read_excel(LAND_DATAFILE)
    sites = []
    lats = []
    lons = []
    temps = []
    temp_modern = []
    temp_uncert = []

    row_locs = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12]
    for rl in row_locs:
        # if temp ne nan then move to array
        temp = dfs.iloc[rl, 9]
        
        print(temp,'julia')
        if np.isfinite(temp):
            sites.append(dfs.iloc[rl, 0])
            lats.append(dfs.iloc[rl, 2])
            lons.append(dfs.iloc[rl, 3])
            temp_modern.append(dfs.iloc[rl, 4])
            temp_uncert.append(dfs.iloc[rl,10])
            temps.append(temp)

    print(temp_uncert)
    for i, temp in enumerate(temp_uncert):
        if i > 0:
            temp2 = temp[2:]
        else:
            temp2=0.0
        print(temp, temp2)
        temp_uncert[i]=np.float(temp2)
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
        label = ''.join([c for c in site if c.isupper()])
        if lats[i] < 0:
            latstr = np.str(np.int(np.round(lats[i] * -1.0, 0))) + deg +  'S'
        else:
            latstr = np.str(np.int(np.around(lats[i], 0))) + deg + 'N'
        if lons[i] < 0:
            lonstr = np.str(np.int(np.round(lons[i] * -1.0, 0))) + deg +  'W'
        else:
            lonstr = np.str(np.int(np.around(lons[i], 0))) + deg + 'E'
        
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return lats, lons, temps, temp_modern, temp_uncert, labels

 

def plot_figure(plio_temp_obs, plio_model, labels, ax, fig):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    #ax1 = ax.axes(frameon=False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
    #ax.axes.get_yaxis().set_visible(False)
    #ax.get_xaxis().tick_bottom()
   

    yarray = np.arange(1, len(plio_temp_obs) + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_model))
    colors = ['blue','orange','green', 'red', 'black','purple']
  
    for i, model in enumerate(EXPTNAMES):
        model_anom[:, i] = plio_model[:, i] - plio_temp_obs  
        plt.scatter(model_anom[:, i], yarray - (0.01 * i), marker = 'o', 
                    color=colors[i],s=30)
       
  
    # add site labels
    plt.text(-5.0, yarray[7], labels[7], ha='right')
    for j in range(0, 7):
        plt.text(np.min(model_anom[j, :]) - 1.0,
                 yarray[j], labels[j], ha='right')

    plt.xlabel('Temperature difference from observations (deg C)')
    #fig.legend(loc = 'center left')
    plt.title('a) Annual Mean Temperature', loc='left')

    
    plt.xlim(-25, 7.5)
    plt.ylim(9, 0)
   
def get_land_warm_cold():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle
    sitedata.append(['Meighen Island', 80, 261, 19.6, 20.5,
                     11.5, 13.5, -11.6, -11.4,
                     -33.0, -18.5])
    sitedata.append(['Beaver Pond', 79, 278, 18.4, 20.9,
                     np.nan, np.nan, -12.2, -11.5, np.nan, np.nan])
    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    np.nan, np.nan, np.nan, np.nan, np.nan, np.nan])
    sitedata.append(['Lost Chicken Mine', 64, 142, 12.0, 12.0, 
                     13.5, 16.0, -2.0, -2.0, -27.75, -19.25])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     np.nan, np.nan, -1.67, 1.07, np.nan, np.nan])
                     

    sites = []
    lats = []
    lons = []
    WMMT_veg_min = []
    WMMT_veg_max = []
    WMMT_beetle_min = []
    WMMT_beetle_max = []
    CMMT_veg_min = []
    CMMT_veg_max = []
    CMMT_beetle_min = []
    CMMT_beetle_max = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_veg_min.append(info[3])
        WMMT_veg_max.append(info[4])
        WMMT_beetle_min.append(info[5])
        WMMT_beetle_max.append(info[6])
        CMMT_veg_min.append(info[7])
        CMMT_veg_max.append(info[8])
        CMMT_beetle_min.append(info[9])
        CMMT_beetle_max.append(info[10])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_veg_min),
             np.asarray(WMMT_veg_max), np.asarray(WMMT_beetle_min),
             np.asarray(WMMT_beetle_max), np.asarray(CMMT_veg_min),
             np.asarray(CMMT_veg_max), np.asarray( CMMT_beetle_min),
             np.asarray(CMMT_beetle_max))


def plot_seas_fig(veg_temp, beetle_temp, plio_model,
                     labels, ax, fig, wc_ind):
    """
    this subroutine tries to plot the figure for the paper which shows how 
    different values of orbit affect the seasonal anomaly
    """
    print(plio_model[4,:],labels[4],wc_ind)

    nmods = len(veg_temp)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
   
    yarray = np.arange(1, nmods + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
    plt.hlines(y=8.95, xmin=-25, xmax=7.5, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_model))
    model_beetle_anom = np.zeros(np.shape(plio_model))
    colors = ['blue','green','orange', 'red', 'black','purple']
    for i, model in enumerate(EXPTNAMES):
       
        model_anom[:, i] = plio_model[:, i] - veg_temp 
        model_beetle_anom[:, i] = plio_model[:, i] - beetle_temp
        if wc_ind == 'c':
            ax.scatter(model_anom[:, i], yarray - 0.2 - (0.01 * i) , 
                       marker = 'o', 
                       color = colors[i],
                       s=30, label=PERIOD.get(model))
        else:
            ax.scatter(model_anom[:, i], yarray - 0.2- (0.01 * i),
                       marker = 'o', 
                       color = colors[i], s=30)
        ax.scatter(model_beetle_anom[:, i], yarray + 0.2- (0.01 * i),
                   marker = 's',
                   color = colors[i], 
                   s=30)
   
    # add site labels
    if wc_ind == 'c':
        for j in [0, 1, 3, 4]:
            plt.text(0.5,
                     yarray[j], labels[j], ha='left')
        plt.title('c) Cold Month Temperature', loc='left')
        print(labels[j], model_anom[j, :],  EXPTNAMES)


    else:
        for j in range(0, 5):
            plt.text(-20, yarray[j], labels[j], ha='right')
        plt.title('b) Warm Month Temperature', loc='left')

        
    


        
    if wc_ind == 'c':
        plt.xlabel('Temperature difference from observations (deg C)')
        #handles, labs = fig.gca().get_legend_handles_labels()
        #order = [0, 3, 6, 1, 4, 7, 2, 5, 8, ]
        #fig.legend([handles[i] for i in order], 
        #           [labs[i] for i in order],
        #           loc = 'center left')
        fig.legend(loc='center left')
  
    #plt.xlim(-35, 15)
    plt.ylim(nmods + 1, 0)
   
  

  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    """

   
    # get land observations and cru temperature at land points
    
    (land_lats, land_lons, land_temp, 
     modern_temp, plio_unc, land_labels)= get_land_obs()
   
    
    # get ind models data
    all_models_plio = np.zeros((len(land_lons), len(EXPTNAMES)))
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT) = get_single_model(model, land_lats, land_lons)
        all_models_plio[:, i] = ind
        
        

  
    # get warm month and cold month temperatures from data
    (sites, land_lats, land_lons, WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min,
     WMMT_beetle_max, CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min,
     CMMT_beetle_max) =  get_land_warm_cold()

    # get warm month and cold month temperatures from model
    allmod_plio_wmt = np.zeros((len(land_lons), len(EXPTNAMES)))
    allmod_plio_cmt = np.zeros((len(land_lons), len(EXPTNAMES)))
   
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT) = get_single_model(model, land_lats, land_lons)
        allmod_plio_wmt[:, i] = indWMT
        allmod_plio_cmt[:, i] = indCMT
        
     

    # plot figure annual mean
    fig1 = plt.figure(figsize=[12.0, 12.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=2, ncols=2)

    ax1 = fig1.add_subplot(gs[:,0])
    plot_figure(land_temp,  all_models_plio, 
                land_labels, ax1, fig1) 

   
    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_veg_min + WMMT_veg_max) / 2.0, 
                  (WMMT_beetle_min + WMMT_beetle_max) / 2.0,
                  allmod_plio_wmt, sites, 
                  ax2, fig1, 'w')

    ax3 = fig1.add_subplot(gs[1,1])
    plot_seas_fig((CMMT_veg_min + CMMT_veg_max) / 2.0, 
                  (CMMT_beetle_min + CMMT_beetle_max) / 2.0,
                  allmod_plio_cmt, sites, ax3, 
                  fig1, 'c')

  
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_uncertainty.eps')
    plt.savefig(fileout)


##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'

EXPTNAMES = ['xibol', 'xozzf', 'xozzd', 'xozze', 'xozzc']

#EXPTNAMES = ['xogzc', 'xogzb']
PERIOD = {'xiboi' : 'pi (old)',
          'xibol' : 'Km5c(old)',
          'xozzc' : 'K1 (3.0560)',
          'xozzd' : 'G17 (2.950)',
          'xozze' : 'KM3 (3.155)',
          'xozzf' : '    (3.053)'}


LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
assess_different_orbits.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs

import sys




def get_single_model(expt, latreq, lonreq):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    
    nsites = len(latreq)
    months = ['January','February','March','April','May','June','July','August','September','October','November','December']
    monthalt = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    seas_field = np.zeros((len(months), nsites))

    plio_mean_array = np.zeros(nsites)
    plio_min_array = np.zeros(nsites)
    plio_max_array = np.zeros(nsites)
   
  
 
    # can change this to calendar corrected files
    for j, month in enumerate(months):
        if expt in ('xibol', 'xozzb', 'xozzd'):
            filename = ('/nfs/hera1/earjcti/um/' + expt +
                        '/database_averages/' + expt + 
                        '_Monthly_Average_' + month 
                        + '_a@pd_Temperature.nc')
            cubetemp = iris.load_cube(filename)
      
        else:
            filename = ('/nfs/hera1/earjcti/um/'+ expt + 
                        '/cal_cor/' + expt + 'a@pa_avg'+ monthalt[j] + '.nc')
            cube2 = iris.load_cube(filename, 
                                      'SURFACE TEMPERATURE AFTER TIMESTEP')
            cubetemp = cube2.collapsed(['t'], iris.analysis.MEAN)
        cube = iris.util.squeeze(cubetemp)
       
        for i in range(0,nsites):
            # modellon is whole numbers from 0-360
            # lat is half numbers from -89.5 to 89.5

            modlon = np.around(lonreq[i])
            if modlon < 0: modlon = modlon + 360.

            lat_ix = ((np.abs(cube.coord('latitude').points 
                              - latreq[i])).argmin())
            lon_ix = ((np.abs(cube.coord('longitude').points 
                         - modlon)).argmin())

            seas_field[j, i] = cube.data[lat_ix, lon_ix]
    
    for i in range(0, nsites):
        plio_min_array[i] = np.min(seas_field[:, i]) - 273.15
        plio_max_array[i] = np.max(seas_field[:, i]) - 273.15
        plio_mean_array[i] = np.mean(seas_field[:, i]) - 273.15

   
    return plio_mean_array, plio_max_array, plio_min_array

 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns temperatures
    """

    dfs = pd.read_excel(LAND_DATAFILE)
    sites = []
    lats = []
    lons = []
    temps = []
    temp_modern = []
    temp_uncert = []

    row_locs = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12]
    for rl in row_locs:
        # if temp ne nan then move to array
        temp = dfs.iloc[rl, 9]
        
        print(temp,'julia')
        if np.isfinite(temp):
            sites.append(dfs.iloc[rl, 0])
            lats.append(dfs.iloc[rl, 2])
            lons.append(dfs.iloc[rl, 3])
            temp_modern.append(dfs.iloc[rl, 4])
            temp_uncert.append(dfs.iloc[rl,10])
            temps.append(temp)

    print(temp_uncert)
    for i, temp in enumerate(temp_uncert):
        if i > 0:
            temp2 = temp[2:]
        else:
            temp2=0.0
        print(temp, temp2)
        temp_uncert[i]=np.float(temp2)
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
        label = ''.join([c for c in site if c.isupper()])
        if lats[i] < 0:
            latstr = np.str(np.int(np.round(lats[i] * -1.0, 0))) + deg +  'S'
        else:
            latstr = np.str(np.int(np.around(lats[i], 0))) + deg + 'N'
        if lons[i] < 0:
            lonstr = np.str(np.int(np.round(lons[i] * -1.0, 0))) + deg +  'W'
        else:
            lonstr = np.str(np.int(np.around(lons[i], 0))) + deg + 'E'
        
            label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return lats, lons, temps, temp_modern, temp_uncert, labels

 

def plot_figure(plio_temp_obs, plio_model, labels, ax, fig):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    #ax1 = ax.axes(frameon=False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
    #ax.axes.get_yaxis().set_visible(False)
    #ax.get_xaxis().tick_bottom()
   

    yarray = np.arange(1, len(plio_temp_obs) + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_model))
    colors = ['blue','orange','green', 'red', 'black','purple']
  
    for i, model in enumerate(EXPTNAMES):
        model_anom[:, i] = plio_model[:, i] - plio_temp_obs  
        plt.scatter(model_anom[:, i], yarray - (0.01 * i), marker = 'o', 
                    color=colors[i],s=30)
       
  
    # add site labels
    print(EXPTNAMES)
    plt.text(-5.0, yarray[7], labels[7], ha='right')
    for j in range(0, 7):
        plt.text(np.min(model_anom[j, :]) - 1.0,
                 yarray[j], labels[j], ha='right')
        print(labels[j], model_anom[j, :])

    plt.xlabel('Temperature difference from observations (deg C)')
    #fig.legend(loc = 'center left')
    plt.title('a) Annual Mean Temperature', loc='left')
    #sys.exit(0)
    
    plt.xlim(-25, 7.5)
    plt.ylim(9, 0)
   
def get_land_warm_cold():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle
    sitedata.append(['Near Meighen Island', 77.5, 261, 19.6, 20.5,
                     11.5, 13.5, -11.6, -11.4,
                     -33.0, -18.5])
    sitedata.append(['Beaver Pond', 79, 278, 18.4, 20.9,
                     np.nan, np.nan, -12.2, -11.5, np.nan, np.nan])
    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    np.nan, np.nan, np.nan, np.nan, np.nan, np.nan])
    sitedata.append(['Lost Chicken Mine', 64, 142, 12.0, 12.0, 
                     13.5, 16.0, -2.0, -2.0, -27.75, -19.25])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     np.nan, np.nan, -1.67, 1.07, np.nan, np.nan])
                     

    sites = []
    lats = []
    lons = []
    WMMT_veg_min = []
    WMMT_veg_max = []
    WMMT_beetle_min = []
    WMMT_beetle_max = []
    CMMT_veg_min = []
    CMMT_veg_max = []
    CMMT_beetle_min = []
    CMMT_beetle_max = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_veg_min.append(info[3])
        WMMT_veg_max.append(info[4])
        WMMT_beetle_min.append(info[5])
        WMMT_beetle_max.append(info[6])
        CMMT_veg_min.append(info[7])
        CMMT_veg_max.append(info[8])
        CMMT_beetle_min.append(info[9])
        CMMT_beetle_max.append(info[10])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_veg_min),
             np.asarray(WMMT_veg_max), np.asarray(WMMT_beetle_min),
             np.asarray(WMMT_beetle_max), np.asarray(CMMT_veg_min),
             np.asarray(CMMT_veg_max), np.asarray( CMMT_beetle_min),
             np.asarray(CMMT_beetle_max))


def plot_seas_fig(veg_temp, beetle_temp, plio_model,
                     labels, ax, fig, wc_ind, beetle_ind):
    """
    this subroutine tries to plot the figure for the paper which shows how 
    different values of orbit affect the seasonal anomaly
    """

    OFFSET = {'xiboi' : 0.0,
          'xibol' : 0.0,
          'xozzb' : 0.2,
          'xozzc' : 0.0,
          'xozzd' : 0.0,
          'xozze' : 0.0,
          'xozzf' : 0.0}
    SIZE = {'xiboi' : 30,
          'xibol' : 30,
          'xozzb' : 50,
          'xozzc' : 30,
          'xozzd' : 30,
          'xozze' : 30,
          'xozzf' : 30}
    SYMBOL = {'xiboi' : 'o',
          'xibol' : 'o',
          'xozzb' : 's',
          'xozzc' : 'v',
          'xozzd' : '^',
          'xozze' : '^',
          'xozzf' : 'v'}


    print(plio_model[4,:],labels[4],wc_ind)

    nmods = len(veg_temp)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
   
    yarray = np.arange(1, nmods + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
    plt.hlines(y=8.95, xmin=-25, xmax=7.5, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_model))
    model_beetle_anom = np.zeros(np.shape(plio_model))
    colors = ['blue','green','orange', 'red', 'black','purple']
    for i, model in enumerate(EXPTNAMES):
       
        model_anom[:, i] = plio_model[:, i] - veg_temp 
        model_beetle_anom[:, i] = plio_model[:, i] - beetle_temp
        if wc_ind == 'c':
            ax.scatter(model_anom[:, i], yarray - OFFSET.get(model) , 
                       marker = SYMBOL.get(model), 
                       color = colors[i],
                       s=SIZE.get(model), label=PERIOD.get(model))
        else:
            ax.scatter(model_anom[:, i], yarray - OFFSET.get(model),
                       marker = SYMBOL.get(model), 
                       color = colors[i], s=SIZE.get(model))
        if beetle_ind == 'y':
            ax.scatter(model_beetle_anom[:, i], yarray + 0.2- (0.01 * i),
                       marker = 's',
                       color = colors[i], 
                       s=30)
   
    # add site labels
    if wc_ind == 'c':
        for j in [0, 1, 3, 4]:
            plt.text(0.5,
                     yarray[j], labels[j], ha='left')
        plt.title('a) Cold Month Temperature', loc='left')
        print(labels[j], model_anom[j, :],  EXPTNAMES)


    else:
        for j in range(0, 5):
            plt.text(-20, yarray[j], labels[j], ha='right')
        plt.title('b) Warm Month Temperature', loc='left')

        
    


    plt.xlabel('Temperature difference from observations (deg C)')
          
    if wc_ind == 'c':
        #handles, labs = fig.gca().get_legend_handles_labels()
        #order = [0, 3, 6, 1, 4, 7, 2, 5, 8, ]
        #fig.legend([handles[i] for i in order], 
        #           [labs[i] for i in order],
        #           loc = 'center left')
        fig.legend(loc='best')
  
    plt.xlim(-45, 30)
    plt.ylim(nmods + 1, 0)
   
   
  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    """

   
    # get land observations and cru temperature at land points
    
    (land_lats, land_lons, land_temp, 
     modern_temp, plio_unc, land_labels)= get_land_obs()
   
    
    # get ind models data
    all_models_plio = np.zeros((len(land_lons), len(EXPTNAMES)))
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT) = get_single_model(model, land_lats, land_lons)
        all_models_plio[:, i] = ind
        
        

  
    # get warm month and cold month temperatures from data
    (sites, land_lats, land_lons, WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min,
     WMMT_beetle_max, CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min,
     CMMT_beetle_max) =  get_land_warm_cold()

    # get warm month and cold month temperatures from model
    allmod_plio_wmt = np.zeros((len(land_lons), len(EXPTNAMES)))
    allmod_plio_cmt = np.zeros((len(land_lons), len(EXPTNAMES)))
   
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT) = get_single_model(model, land_lats, land_lons)
        allmod_plio_wmt[:, i] = indWMT
        allmod_plio_cmt[:, i] = indCMT
        
     

    # plot figure annual mean, warm month and cold month
    fig1 = plt.figure(figsize=[12.0, 12.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=2, ncols=2)

    ax1 = fig1.add_subplot(gs[:,0])
    plot_figure(land_temp,  all_models_plio, 
                land_labels, ax1, fig1) 

   
    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_veg_min + WMMT_veg_max) / 2.0, 
                  (WMMT_beetle_min + WMMT_beetle_max) / 2.0,
                  allmod_plio_wmt, sites, 
                  ax2, fig1, 'w','y')

    ax3 = fig1.add_subplot(gs[1,1])
    plot_seas_fig((CMMT_veg_min + CMMT_veg_max) / 2.0, 
                  (CMMT_beetle_min + CMMT_beetle_max) / 2.0,
                  allmod_plio_cmt, sites, ax3, 
                  fig1, 'c','y')

  
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_uncertainty.eps')
    plt.savefig(fileout)


     # plot figure  cold month and warm month
    fig1 = plt.figure(figsize=[12.0, 8.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=1, ncols=2)

   
  
    ax1 = fig1.add_subplot(gs[0,0])
    plot_seas_fig((CMMT_veg_min + CMMT_veg_max) / 2.0, 
                  (CMMT_beetle_min + CMMT_beetle_max) / 2.0,
                  allmod_plio_cmt, sites, ax1, 
                  fig1, 'c','n')

    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_veg_min + WMMT_veg_max) / 2.0, 
                  (WMMT_beetle_min + WMMT_beetle_max) / 2.0,
                  allmod_plio_wmt, sites, 
                  ax2, fig1, 'w','n')

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_uncertainty_WMMT_CMMT.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_uncertainty_WMMT_CMMT.png')
    plt.savefig(fileout)


##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'

EXPTNAMES = ['xozzd', 'xozze', 'xozzb', 'xozzc', 'xozzf']

#EXPTNAMES = ['xogzc', 'xogzb']
PERIOD = {'xiboi' : 'pi (old)',
          'xibol' : 'KM5c',
          'xozzb' : 'KM5c',
          'xozzc' : 'K1 (3.0560Ma)',
          'xozzd' : 'G17 (2.950Ma)',
          'xozze' : 'KM3 (3.155Ma)',
          'xozzf' : '3.053Ma'}


LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
assess_diff_orb_plus_models.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys


###########################
def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm



def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3


def get_single_orbit(expt, latreq, lonreq):
    """
    obtain the modelled temperature at each orbit return the temperatures
    at the list of sites
    """
    
    nsites = len(latreq)
    months = ['January','February','March','April','May','June','July','August','September','October','November','December']
    monthalt = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
    seas_field = np.zeros((len(months), nsites))

    plio_mean_array = np.zeros(nsites)
    plio_min_array = np.zeros(nsites)
    plio_max_array = np.zeros(nsites)
   
  
 
    # can change this to calendar corrected files
    for j, month in enumerate(months):
        if expt in ('xibol', 'xozzb', 'xozzd', 'xozzc'):
            filename = ('/nfs/hera1/earjcti/um/' + expt +
                        '/database_averages/' + expt + 
                        '_Monthly_Average_' + month 
                        + '_a@pd_Temperature.nc')
            cubetemp = iris.load_cube(filename)
      
        else:
            filename = ('/nfs/hera1/earjcti/um/'+ expt + 
                        '/cal_cor/' + expt + 'a@pa_avg'+ monthalt[j] + '.nc')
            cube2 = iris.load_cube(filename, 
                                      'SURFACE TEMPERATURE AFTER TIMESTEP')
            cubetemp = cube2.collapsed(['t'], iris.analysis.MEAN)
        cube = iris.util.squeeze(cubetemp)
       
        for i in range(0,nsites):
            # modellon is whole numbers from 0-360
            # lat is half numbers from -89.5 to 89.5

            modlon = np.around(lonreq[i])
            if modlon < 0: modlon = modlon + 360.

            lat_ix = ((np.abs(cube.coord('latitude').points 
                              - latreq[i])).argmin())
            lon_ix = ((np.abs(cube.coord('longitude').points 
                         - modlon)).argmin())

            seas_field[j, i] = cube.data[lat_ix, lon_ix]
    
    for i in range(0, nsites):
        plio_min_array[i] = np.min(seas_field[:, i]) - 273.15
        plio_max_array[i] = np.max(seas_field[:, i]) - 273.15
        plio_mean_array[i] = np.mean(seas_field[:, i]) - 273.15
        if i == 1:
            print(expt, i,seas_field[:,i]-273.15,plio_min_array[i],
                  plio_max_array[i],plio_mean_array[i])
        
   
    return plio_mean_array, plio_max_array, plio_min_array

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)
    plio_MAT_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
        plio_MAT_array[i] = np.mean(plio_array)
      
    return plio_MAT_array, plio_minval_array, plio_maxval_array


 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns temperatures
    """

    dfs = pd.read_excel(LAND_DATAFILE)
    sites = []
    lats = []
    lons = []
    temps = []
    temp_modern = []
    temp_uncert = []

    row_locs = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12]
    for rl in row_locs:
        print(dfs.iloc[rl,0])
        # if temp ne nan then move to array
        temp = dfs.iloc[rl, 9]
        
        if np.isfinite(temp):
            sites.append(dfs.iloc[rl, 0])
            lats.append(dfs.iloc[rl, 2])
            lons.append(dfs.iloc[rl, 3])
            temp_modern.append(dfs.iloc[rl, 4])
            temp_uncert.append(dfs.iloc[rl,10])
            temps.append(temp)

    for i, temp in enumerate(temp_uncert):
        if i > 0:
            temp2 = temp[2:]
        else:
            temp2=0.0
        temp_uncert[i]=np.float(temp2)
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
        label = ''.join([c for c in site if c.isupper()])
        if lats[i] < 0:
            latstr = np.str(np.int(np.round(lats[i] * -1.0, 0))) + deg +  'S'
        else:
            latstr = np.str(np.int(np.around(lats[i], 0))) + deg + 'N'
        if lons[i] < 0:
            lonstr = np.str(np.int(np.round(lons[i] * -1.0, 0))) + deg +  'W'
        else:
            lonstr = np.str(np.int(np.around(lons[i], 0))) + deg + 'E'
        
            label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return lats, lons, temps, temp_modern, temp_uncert, labels

 

def plot_figure(plio_temp_obs, plio_model_orb, labels, ax, fig):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    #ax1 = ax.axes(frameon=False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
    #ax.axes.get_yaxis().set_visible(False)
    #ax.get_xaxis().tick_bottom()
   

    yarray = np.arange(1, len(plio_temp_obs) + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_model_orb))
    colors = ['orange','blue','green', 'red', 'black','purple']
  
    for i, model in enumerate(EXPTNAMES):
        model_anom[:, i] = plio_model_orb[:, i] - plio_temp_obs  
        plt.scatter(model_anom[:, i], yarray - (0.01 * i), marker = 'o', 
                    color=colors[i],s=30)
       
  
    # add site labels
    plt.text(-5.0, yarray[7], labels[7], ha='right')
    for j in range(0, 7):
        plt.text(np.min(model_anom[j, :]) - 1.0,
                 yarray[j], labels[j], ha='right')

    plt.xlabel('Temperature difference from observations (deg C)')
    #fig.legend(loc = 'center left')
    plt.title('a) Annual Mean Temperature', loc='left')
    #sys.exit(0)
    
    plt.xlim(-25, 7.5)
    plt.ylim(9, 0)
   
def get_land_km5c_lp():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min MAT veg, max MAT veg
    # modern obs WMMT, modern obs CMMT
    # reference and date

    # lake baikal is from what ulrich sent me.
    # Lake E from Brigette-greeme mean july temp of +8 and average winter lows of 35degC

    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    -36.8, -30.4, -11.85, -8.0,
                     8.0, np.nan,'CMMT 3.199Ma - 3.209Ma; Pavel Tarasov (pers. comm) \n WMMT Brigham-Grette et al. 2013'])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     -1.67, 1.07, 6.65,8.65,
                     15.3, -17.4,'Km5c - unpublished (Method of Klage et al 2020)'])
  
    
    sitedata.append(['Mirny', 55, 82, 18.8, 24.6, -0.3, 0.7,9.9,12.5,
                     np.nan, np.nan,'Popova et al 2012'])
    sitedata.append(['Merkutlinskiy', 56, 72, 17.3, 23.8, -3.8, 6.2,7.3,16.2,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Kabinet', 55, 80, 21.6, 24.4, -4.4, 4.6,6.6,7.3,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Delyankir', 63, 133, 18.9, 24.9, -6.9, 1.3,6.9,7.8,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Chernoluche', 55, 73, 19.6, 20.3, -5.9, 0.7,5.4,7.3,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Blizkiy', 64, 162, 15.6, 23.3, -12.8, 5.2,-0.6,11.1,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['42km', 55, 80, 21.6, 23.3, -4.4, 0.7,6.6,11.1,
                     np.nan, np.nan,' --"--'])
  
    sitedata.append(['Lost Chicken Mine', 64, 218, 12.0, 12.0, 
                     -2.0, -2.0, 2.5,2.5,15.3, -25.1, '2.9 +/- 0.4Ma: Ager et al. 1994'])


        
    sites = []
    lats = []
    lons = []
    WMMT_data_min = []
    WMMT_data_max = []
    WMMT_modern_obs = []
    CMMT_data_min = []
    CMMT_data_max = []
    MAT_data_min = []
    MAT_data_max = []
    CMMT_modern_obs = []
    refs = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_data_min.append(info[3])
        WMMT_data_max.append(info[4])
        CMMT_data_min.append(info[5])
        CMMT_data_max.append(info[6])
        MAT_data_min.append(info[7])
        MAT_data_max.append(info[8])
        WMMT_modern_obs.append(info[9])
        CMMT_modern_obs.append(info[10])
        refs.append(info[11])
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + ' (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)

  
    return (labels, lats, lons, np.asarray(WMMT_data_min), 
            np.asarray(WMMT_data_max),  np.asarray(CMMT_data_min), 
            np.asarray(CMMT_data_max), 
            np.asarray(MAT_data_max), np.asarray(MAT_data_min),
            np.asarray(WMMT_modern_obs),
            np.asarray(CMMT_modern_obs),refs)

   


def plot_seas_fig(veg_temp, plio_model_orb, plio_model_p2,
                     labels, ax, fig, wc_ind):
    """
    this subroutine tries to plot the figure for the paper which shows how 
    different values of orbit affect the seasonal anomaly
    """

    OFFSET = {'xiboi' : 0.0,
          'xibol' : 0.0,
          'xozzb' : 0.2,
          'xozzc' : 0.0,
          'xozzd' : 0.0,
          'xozze' : 0.0,
          'xozzf' : 0.0}
    SIZE = {'xiboi' : 30,
          'xibol' : 30,
          'xozzb' : 50,
          'xozzc' : 30,
          'xozzd' : 30,
          'xozze' : 30,
          'xozzf' : 30}
    SYMBOL = {'xiboi' : 'o',
          'xibol' : 'o',
          'xozzb' : 's',
          'xozzc' : 'v',
          'xozzd' : '^',
          'xozze' : '^',
          'xozzf' : 'v'}


 
    nmods = len(veg_temp)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_yaxis().set_ticks([])
   
    yarray = np.arange(1, nmods + 1, 1)

 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=11, linewidth=0.5)
   # plt.hlines(y=8.95, xmin=-25, xmax=7.5, linewidth=0.5)
   
    # plot individual models for pliocene
    model_anom_orb = np.zeros(np.shape(plio_model_orb))
    model_anom_p2 = np.zeros(np.shape(plio_model_p2))
    colors = ['orange','green','blue', 'red', 'black','purple']
    for i, model in enumerate(EXPTNAMES):
        model_anom_orb[:, i] = plio_model_orb[:, i] - veg_temp 
        if wc_ind == 'c' or wc_ind =='m':
            ax.scatter(model_anom_orb[:, i], yarray - OFFSET.get(model) , 
                       marker = SYMBOL.get(model), 
                       color = colors[i],
                       s=SIZE.get(model), label=PERIOD.get(model))
        else:
            ax.scatter(model_anom_orb[:, i], yarray - OFFSET.get(model),
                       marker = SYMBOL.get(model), 
                       color = colors[i], s=SIZE.get(model))
  

    for i, model in enumerate(MODELNAMES):
        model_anom_p2[:, i] = plio_model_p2[:, i] - veg_temp 
        if i == 0 :
            ax.scatter(model_anom_p2[:, i], yarray+0.2,
                       marker = 'o', edgecolors='black', linewidths=0.5, 
                       color = 'tab:red', s=15, label='KM5c (other models)')
        else:
            ax.scatter(model_anom_p2[:, i], yarray+0.2,
                       marker = 'o', edgecolors='black', linewidths=0.5,
                       color = 'tab:red', s=15)
      
    # add site labels
    if wc_ind == 'c':
        plt.title('a) Cold Month Temperature', loc='left')
    if wc_ind == 'w':
        for j in range(0, nmods):
            plt.text(-60, yarray[j], labels[j], ha='left')
        plt.title('b) Warm Month Temperature', loc='left')
    if wc_ind == 'm':
        for j in range(0, nmods):
            plt.text(11, yarray[j], labels[j], ha='left',fontsize=8)
        plt.title('Annual mean Temperature', loc='left')
        fig.subplots_adjust(bottom=0.25)


      
        
    


    plt.xlabel('Temperature difference from palaeodata (deg C)')
          
    if wc_ind == 'c':
        #handles, labs = fig.gca().get_legend_handles_labels()
        #order = [0, 3, 6, 1, 4, 7, 2, 5, 8, ]
        #fig.legend([handles[i] for i in order], 
        #           [labs[i] for i in order],
        #           loc = 'center left')
        fig.legend(loc='best')
  
    if wc_ind == 'm':
        plt.legend(loc='lower center', bbox_to_anchor=(0.5, -0.3), ncol=3)
  
    if wc_ind == 'm':
        plt.xlim(-18, 20)
    else:
        plt.xlim(-40, 30)
    
    plt.ylim(nmods + 1, 0)
   
   
  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    """

   
    # get land observations and cru temperature at land points
    
    (land_lats, land_lons, land_temp, 
     modern_temp, plio_unc, land_labels)= get_land_obs()
   


    # get different orbit from HadCM3
    all_orbits_plio = np.zeros((len(land_lons), len(EXPTNAMES)))
   
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT) = get_single_orbit(model, land_lats, land_lons)
        all_orbits_plio[:, i] = ind
       
        
        
    
  
    # get warm month and cold month temperatures from data
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, MAT_data_min, MAT_data_max,
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_km5c_lp()


     # get warm month and cold month temperatures from model
    allorb_plio_wmt = np.zeros((len(land_lons), len(EXPTNAMES)))
    allorb_plio_cmt = np.zeros((len(land_lons), len(EXPTNAMES)))
    allorb_plio_mat = np.zeros((len(land_lons), len(EXPTNAMES)))
   
    for i, model in enumerate(EXPTNAMES):
        (ind, indWMT, 
         indCMT,) = get_single_orbit(model, land_lats, land_lons)
        allorb_plio_wmt[:, i] = indWMT
        allorb_plio_cmt[:, i] = indCMT
        allorb_plio_mat[:, i] = ind
        print(model, indWMT[1], indCMT[1], ind[1])
    
  
    # get output from all models in the Pliomip2 ensemble
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_MAT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_MAT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_MAT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_MAT, ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT
        all_models_plio_MAT[:, i] = ind_MAT

        (ind_MAT, ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT
        all_models_pi_MAT[:, i] = ind_MAT

        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])

        all_models_MAT_anom[:, i] = (all_models_plio_MAT[:, i] -
                                      all_models_pi_MAT[:, i])
  

    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)
    mmm_MAT = np.nanmean(all_models_plio_MAT, axis=1)
   
    mmm_WMT_pi = np.nanmean(all_models_pi_WMT, axis=1)
    mmm_CMT_pi = np.nanmean(all_models_pi_CMT, axis=1)
    mmm_MAT_pi = np.nanmean(all_models_pi_MAT, axis=1)


    # plot figure annual mean, warm month and cold month
    fig1 = plt.figure(figsize=[12.0, 12.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=2, ncols=2)

    ax1 = fig1.add_subplot(gs[:,0])
    print('j1')
    plot_figure(land_temp,  all_orbits_plio, 
                land_labels, ax1, fig1) 

    print('j2', np.shape(allorb_plio_wmt), np.shape(WMMT_data_min))
   
    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_data_min + WMMT_data_max) / 2.0, 
                  allorb_plio_wmt, all_models_plio_WMT, sites, 
                  ax2, fig1, 'w')

    print('j3')
    ax3 = fig1.add_subplot(gs[1,1])
    plot_seas_fig((CMMT_data_min + CMMT_data_max) / 2.0, 
                  allorb_plio_cmt, all_models_plio_CMT, sites, ax3, 
                  fig1, 'c')

    print('j4')
  
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_plus_mod_uncert.eps')
    plt.savefig(fileout)


     # plot figure  cold month and warm month
    fig1 = plt.figure(figsize=[12.0, 8.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=1, ncols=2)

   
  
    ax1 = fig1.add_subplot(gs[0,0])
    plot_seas_fig((CMMT_data_min + CMMT_data_max) / 2.0, 
                  allorb_plio_cmt, all_models_plio_CMT, sites, ax1, 
                  fig1, 'c')

    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_data_min + WMMT_data_max) / 2.0, 
                  allorb_plio_wmt, all_models_plio_WMT, sites, 
                  ax2, fig1, 'w')

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_plus_mod_uncert_WMMT_CMMT.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orb_plus_mod_uncert_WMMT_CMMT.png')
    plt.savefig(fileout)


   # alternative plot.  Where the individual model is the
   # plio_model - pi_model + mmm_pi
    fig1 = plt.figure(figsize=[12.0, 8.0], constrained_layout=True)
    gs = gridspec.GridSpec(nrows=1, ncols=2)

  
    ax1 = fig1.add_subplot(gs[0,0])
    plot_seas_fig((CMMT_data_min + CMMT_data_max) / 2.0, 
                  allorb_plio_cmt,  
                  np.add(all_models_CMMT_anom,
                       np.transpose(np.tile(mmm_CMT_pi, (len(MODELNAMES),1)))),
                  sites, ax1, 
                  fig1, 'c')

    ax2 = fig1.add_subplot(gs[0,1])
    plot_seas_fig((WMMT_data_min + WMMT_data_max) / 2.0, 
                  allorb_plio_wmt, 
                  np.add(all_models_WMMT_anom,
                       np.transpose(np.tile(mmm_WMT_pi, (len(MODELNAMES),1)))),
                  sites,ax2, fig1, 'w')

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_plus_mod_uncert_WMMT_CMMT_alternative.eps')
    plt.savefig(fileout)


   # alternative plot - annual mean.  Where the individual model is the
   # plio_model - pi_model + mmm_pi
    fig1 = plt.figure(figsize=[12.0, 8.0])
    ax=fig1.add_subplot(1,1,1)
  
  
    plot_seas_fig((MAT_data_min + MAT_data_max) / 2.0, 
                  allorb_plio_mat,  
                  np.add(all_models_MAT_anom,
                       np.transpose(np.tile(mmm_MAT_pi, (len(MODELNAMES),1)))),
                  sites, ax, 
                  fig1,'m')

   
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/orbital_plus_mod_uncert_annmean_alternative.eps')
    plt.savefig(fileout)
  

##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'


EXPTNAMES = ['xozzb', 'xozzd', 'xozzf', 'xozzc', 'xozze']
#EXPTNAMES = ['xibol', 'xozzb','xozzd', 'xozzf', 'xozzc', 'xozze']

PERIOD = {'xiboi' : 'pi (old)',
          'xibol' : 'KM5c',
          'xozzb' : 'KM5c',
          'xozzc' : 'K1 (3.0560Ma)',
          'xozzd' : 'G17 (2.950Ma)',
          'xozze' : 'KM3 (3.155Ma)',
          'xozzf' : '3.053Ma'}


MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 
#              'GISS2.1G', 
              'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
#             ,  'MRI2.3'
              ]
#MODELNAMES = ['HadCM3']

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
basic_dmc_plot.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array


def get_single_model(model, latreq, lonreq):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/EOI400.NearSurfaceTemperature.allmean.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_array = np.zeros(nsites)
   
    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_array[i] = plio_cube.data[lat_ix, lon_ix]
   
    return plio_array

 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns temperatures
    """

    dfs = pd.read_excel(LAND_DATAFILE)
    sites = []
    lats = []
    lons = []
    temps = []
    temp_modern = []
    temp_uncert = []

    row_locs = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12]
    for rl in row_locs:
        # if temp ne nan then move to array
        temp = dfs.iloc[rl, 9]
        
        print(temp,'julia')
        if np.isfinite(temp):
            sites.append(dfs.iloc[rl, 0])
            lats.append(dfs.iloc[rl, 2])
            lons.append(dfs.iloc[rl, 3])
            temp_modern.append(dfs.iloc[rl, 4])
            temp_uncert.append(dfs.iloc[rl,10])
            temps.append(temp)

    print(temp_uncert)
    for i, temp in enumerate(temp_uncert):
        if i > 0:
            temp2 = temp[2:]
        else:
            temp2=0.0
        print(temp, temp2)
        temp_uncert[i]=np.float(temp2)
     
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
        label = ''.join([c for c in site if c.isupper()])
        if lats[i] < 0:
            latstr = np.str(np.int(np.round(lats[i] * -1.0, 0))) + deg +  'S'
        else:
            latstr = np.str(np.int(np.around(lats[i], 0))) + deg + 'N'
        if lons[i] < 0:
            lonstr = np.str(np.int(np.round(lons[i] * -1.0, 0))) + deg +  'W'
        else:
            lonstr = np.str(np.int(np.around(lons[i], 0))) + deg + 'E'
        
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return lats, lons, temps, temp_modern, temp_uncert, labels

def get_cru_temp(lats, lons):
    """
    get's the cru temperature at the given latitude and longitude
    """
    
    crufile = ('/nfs/hera1/earjcti/regridded/CRUTEMP/' + 
               'E280.NearSurfaceTemperature.allmean.nc')
    cube = iris.load_cube(crufile)
    print(cube.coord('latitude').points)
    
    cru_temp = np.zeros(len(lats))
    for i, lat in enumerate(lats):
        lat_ix = (np.abs(cube.coord('latitude').points - lat)).argmin()
        lon_ix = (np.abs(cube.coord('longitude').points - lons[i])).argmin()
        
        print(lat, cube.coord('latitude').points[lat_ix],
              lons[i], cube.coord('longitude').points[lon_ix] )


        cru_temp[i] = cube.data[lat_ix, lon_ix]
        if np.isfinite(cru_temp[i]):
            pass
        else:
            # get an average of surrounding ones
            surround = [cube.data[lat_ix + 1, lon_ix],
                        cube.data[lat_ix - 1, lon_ix],
                        cube.data[lat_ix, lon_ix + 1],
                        cube.data[lat_ix, lon_ix -1],
                        ]
            cru_temp[i] = np.nanmean(surround)
           
    return cru_temp


def plot_figure(plio_temp_obs, plio_temp_unc, pi_temp_obs, plio_mmm, pi_mmm,
                crutemp, plio_ind_models, labels):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    fig1 = plt.figure(figsize=[6.0, 8.0])
    ax1 = plt.axes(frameon=False)
    #ax1.get_xaxis().tick_bottom()
    ax1.axes.get_yaxis().set_visible(False)

    yarray = np.arange(1, len(plio_temp_obs) + 1, 1)
 
   # try plotting model data anomaly
    plt.vlines(x=0, ymin=-0, ymax=9, linewidth=0.5)
    plt.hlines(y=8.95, xmin=-25, xmax=7.5, linewidth=0.5)
    plt.scatter(plio_mmm - plio_temp_obs, yarray-0.2, color='black', s=50)
    plt.scatter(plio_mmm - plio_temp_obs, yarray-0.2, color='red', 
                s=25, label='mPWP MMM')
    plt.scatter(pi_mmm - pi_temp_obs, yarray, color='blue', label='PI MMM')

   
    # plot individual models for pliocene
    model_anom = np.zeros(np.shape(plio_ind_models))
    for i in range(0, len(MODELNAMES)):
        model_anom[:, i] = plio_ind_models[:, i] - plio_temp_obs  
        if i == 0:
            plt.scatter(model_anom[:, i], yarray-0.2, color='red', marker = 'x',
                    s=10, label='mPWP models')
        else:
            plt.scatter(model_anom[:, i], yarray-0.2, color='red', marker = 'x',
                    s=10)
    
    # add uncertainty on modern due to difference with CRU and uncert on plio data
    cruanom = crutemp - pi_temp_obs   
    for j in range(0,len(pi_temp_obs)):
    #    valmin = np.min([0, cruanom[j]])
    #    valmax = np.max([0, cruanom[j]]) 
        if j == 0:
            #plt.hlines(y = j+1, xmin = valmin, xmax=valmax, linestyle='dotted',
            #           color='blue', label='PI data \n uncertainty')
            plt.hlines(y = j+0.9, xmin = plio_temp_unc[j] * -1.0, 
                       xmax=plio_temp_unc[j], color='red', linestyle='dotted',
                       label='mPWP data \n uncertainty') 
        else:
            #plt.hlines(y = j+1, xmin = valmin, xmax=valmax, linestyle='dotted',
            #           color='blue')
            plt.hlines(y = j+0.9, xmin = plio_temp_unc[j] * -1.0, 
                   xmax=plio_temp_unc[j], color='red', linestyle='dotted') 
       

    # plot MMM again so it is on the top of the figure
    plt.scatter(plio_mmm - plio_temp_obs, yarray-0.2, color='black', s=50)
    plt.scatter(plio_mmm - plio_temp_obs, yarray-0.2, color='red', 
                s=25)
    plt.scatter(pi_mmm - pi_temp_obs, yarray, color='blue')
    # plot cruanom
    plt.scatter(cruanom,yarray+0.2,color='blue',marker='^',label='CRU 1901-1930')

 
    # add site labels
    plt.text(-5.0, yarray[7], labels[7], ha='right')
    for j in range(0, 7):
        plt.text(np.min(model_anom[j, :]) - 1.0,
                 yarray[j], labels[j], ha='right')

    plt.xlabel('Difference between modelled/reanalysis \n and observed/reconstructed temperatures (deg C)')
    plt.legend(loc = 'lower left')
  
    plt.xlim(-25, 7.5)
    plt.ylim(9, 0)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/basic_dmc_plot.eps')
    plt.savefig(fileout)
  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    """

   
    # get land observations and cru temperature at land points
    
    (land_lats, land_lons, land_temp, 
     modern_temp, plio_unc, land_labels)= get_land_obs()
    cru_land_temp = get_cru_temp(land_lats, land_lons)

    
    # get model data
    MMM_plio, MMM_pi = get_MMM_data(land_lats, land_lons)

    # get ind models data
    all_models_plio = np.zeros((len(land_lons), len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        ind = get_single_model(model, land_lats, land_lons)
        all_models_plio[:, i] = ind

    # plot data
    plot_figure(land_temp, plio_unc, modern_temp, MMM_plio,
                MMM_pi, cru_land_temp, all_models_plio, land_labels) 


##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'

MODELNAMES = [
              'CESM2', 'HadGEM3',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'MRI2.3', 'NorESM1-F'
              ]

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
extract_CRU.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on September 2020
# 
#  This program will extract the cru temperatures for all of the sites  
#1
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

 
def get_land_obs(SITE_REQUIRED):
    """
    reads in the spredsheet from ulrich and returns 
    the field, latitude and longitude from the required site. 
    """

    if SITE_REQUIRED == 'Meighen Island':
        fielddata = 10.0
        lat = 80.0
        lon = -99.0

    if SITE_REQUIRED == 'Beaver Pond':
        fielddata = 1.0
        lat = 79.0
        lon = -82.0
   
    if SITE_REQUIRED == 'Flyes Leaf Bed':
        fielddata = 1.0
        lat = 79.0
        lon = -83.0

    if SITE_REQUIRED == 'Lake Elgygytgyn':
        fielddata = 16.0
        lat = 67.0
        lon = -172.0
    
    if SITE_REQUIRED == 'Alpes-Maritimes N':
        lat = 44.0
        lon = -7.19
        fielddata = 1.0
   
    
    if SITE_REQUIRED == 'Alpes-Maritimes S':
        lat = 43.5
        lon = -7.0
        fielddata = 1.0
   
    dfs = pd.read_excel(LAND_DATAFILE)
    found = 'n'
    
    colreq = 9
    
    
    for index, row in dfs.iterrows():
        if row[0] == SITE_REQUIRED:
            found = 'y'
            fielddata = row[colreq]
            lat = row[2]
            lon = row[3]
            pass
            
    
    if found == 'n' and SITE_REQUIRED != 'Meighen Island':
        print('couldnot find site in Ulrichs file')
   #     sys.exit(0)
        
    
   
    return fielddata, lat, lon





  
def main():
    """
    calling structure
    a) put cru data into an iris cube
    b) get lat and long from from Ulrichs spreadsheet
    c) get cru temperature at nearest lat and long
    c) printout
    """
    
    cru_cube = iris.load_cube(FILENAME, 'near-surface temperature')

 
    for site in SITES_REQUIRED:
        #    # get data from Ulrichs spreadsheet
    
        proxy_temperature, proxy_lat, proxy_lon = get_land_obs(site)
    
       
        lat_ix = (np.abs(cru_cube.coord('latitude').points - proxy_lat)).argmin()
        lon_ix = (np.abs(cru_cube.coord('longitude').points - proxy_lon)).argmin()
    
        crutemp = cru_cube.data[lat_ix, lon_ix]
   
        print(site, proxy_lat, proxy_lon, 
              cru_cube.coord('latitude').points[lat_ix],
              cru_cube.coord('longitude').points[lon_ix], crutemp)
 #########################################################
# main program


LINUX_WIN = 'l'
EXPTNAME = 'EOI400'

if LINUX_WIN == 'l':
    FILESTART = '/nfs/hera1/earjcti/' 
    FILENAME = (FILESTART + 'regridded/CRUTEMP/' + 
                'E280.NearSurfaceTemperature.allmean.nc')
    LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE = '_' + EXPTNAME + '.eps'
else:
    FILESTART = 'C:\\Users\\julia\\OneDrive\\WORK\\DATA\\'
    LAND_DATAFILE = (FILESTART + '/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE = '_' + EXPTNAME + '.png'
 


SITES_REQUIRED = ['Lake Baikal', 'Lake Elgygytgyn', 'Meighen Island',
                  'Beaver Pond',
                  'Flyes Leaf Bed', 'Lost Chicken Mine',
                  'James Bay Lowland',
                  'Pula Maar',
                  'Alpes-Maritimes',
                  'Tarragona',
                  'Rio Maior',
                  'Yallalie, Perth',
                  'Alpes-Maritimes N', 'Alpes-Maritimes S']

main()
::::::::::::::
extract_data_at_site.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on October 2021
# 
#  This program will extract the temperature cycle at a given site
#1
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

 
def get_land_obs(SITE_REQUIRED):
    """
    reads in the spredsheet from ulrich and returns 
    the field, latitude and longitude from the required site. 
    """

    if SITE_REQUIRED == 'Meighen Island':
        fielddata = 10.0
        lat = 80.0
        lon = -99.0

    if SITE_REQUIRED == 'Beaver Pond':
        fielddata = 1.0
        lat = 79.0
        lon = -82.0
   
    if SITE_REQUIRED == 'Flyes Leaf Bed':
        fielddata = 1.0
        lat = 79.0
        lon = -83.0

    if SITE_REQUIRED == 'Lake Elgygytgyn':
        fielddata = 16.0
        lat = 67.0
        lon = -172.0
    
    if SITE_REQUIRED == 'Alpes-Maritimes N':
        lat = 44.0
        lon = -7.19
        fielddata = 1.0
   
    
    if SITE_REQUIRED == 'Alpes-Maritimes S':
        lat = 43.5
        lon = -7.0
        fielddata = 1.0
   
   
    return  lat, lon





  
def main():
    """
    get temperatures from mmm
    get temperatures from individual models
    
    write out annual temperatures
    write out monthly temperatures
    write out seasonal temperatures
    """
    
    proxy_lat, proxy_lon = get_land_obs(SITE_REQUIRED)
    if proxy_lon < 0: proxy_lon = proxy_lon + 360.
    
    field = 'NearSurfaceTemperaturemean_plio'
    mmm_cube = iris.load_cube(NSAT_MMM_FILE,field)
  
    lat_ix = (np.abs(mmm_cube.coord('latitude').points - proxy_lat)).argmin()
    lon_ix = (np.abs(mmm_cube.coord('longitude').points - proxy_lon)).argmin()
    
    mmmtemp = mmm_cube.data[:, lat_ix, lon_ix]
    mmmtemp_avg = np.mean(mmmtemp)
    mmmtemp_djf = (mmmtemp[0] + mmmtemp[1] + mmmtemp[11]) / 3.0
    mmmtemp_mam = (mmmtemp[2] + mmmtemp[3] + mmmtemp[4]) / 3.0
    mmmtemp_jja = (mmmtemp[5] + mmmtemp[6] + mmmtemp[7]) / 3.0
    mmmtemp_son = (mmmtemp[8] + mmmtemp[9] + mmmtemp[10]) / 3.0
   
    print(proxy_lat, proxy_lon, 
          mmm_cube.coord('latitude').points[lat_ix],
          mmm_cube.coord('longitude').points[lon_ix])

    print('mean annual temp = ',mmmtemp_avg)
    print('mean annual djf = ',mmmtemp_djf)
    print('mean annual mam = ',mmmtemp_mam)
    print('mean annual jja = ',mmmtemp_jja)
    print('mean annual son = ',mmmtemp_son)

    allmodel_summer = []
    allmodel_mean = []
    for model in MODELNAMES:
        filename = (FILESTART + 'regridded100/' + model +  
                    '/EOI400.NearSurfaceTemperature.mean_month.nc')
        model_cube = iris.load_cube(filename)
  
        lat_ix = (np.abs(model_cube.coord('latitude').points - proxy_lat)).argmin()
        lon_ix = (np.abs(model_cube.coord('longitude').points - proxy_lon)).argmin()
        modeltemp = model_cube.data[:, lat_ix, lon_ix]
  
    
        modeltemp_jja = (modeltemp[5] + modeltemp[6] + modeltemp[7]) / 3.0
        modeltemp_mean = np.mean(modeltemp)
        allmodel_summer.append(modeltemp_jja)
        allmodel_mean.append(modeltemp_mean)
      #  print('jja temp for ',model,' = ',modeltemp_jja)
        print('ann temp for ',model,' = ',modeltemp_mean)
  
   # print('these models median jja',np.median(np.asarray(allmodel_summer)))
   # print('these models 20th percentile jja',np.percentile(np.asarray(allmodel_summer),20))
   # print('these models 80th percentile jja',np.percentile(np.asarray(allmodel_summer),90))
  
    print('these models median ann',np.median(np.asarray(allmodel_mean)))
    print('these models 20th percentile ann',np.percentile(np.asarray(allmodel_mean),20))
    print('these models 80th percentile ann',np.percentile(np.asarray(allmodel_mean),80))

 #########################################################
# main program


LINUX_WIN = 'l'
EXPTNAME = 'EOI400'

LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 
               'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
            ,  'MRI2.3'
              ]


NSAT_MMM_FILE = (FILESTART + 'regridded100/' + 
                 'NearSurfaceTemperature_multimodelmean_month.nc')


SITE_REQUIRED= 'Beaver Pond'

main()
::::::::::::::
Land_DMC_growing_season_analysis_2.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on September 2020
# 
#  This program produces additional of figures to assess
#  the DMC in various ways.  
#
#  The ultimate aim is to do a better DMC by comparing the model
#  to the times when the proxy represents.  
#
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
#from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

class GetMeteodata:
    """
    This class is everything to do with 
    getting the meteorological data.

    """
    def __init__(self):
        
        # sel.nearsites = [sitename, sitelat, sitelon]
        if SITE_REQUIRED == 'Lake Baikal':
            self.nearsites = [['Krasnojarsk', 56.0, 92.3],
                              ['Nizneudinsk', 54.9, 99.0],
                              ['Zigalovo', 54.8, 105.2],
                              ['Nizneangarsk', 55.8, 109.6],
                              ['Kalakan', 55.1, 116.8]
                              ]
            self.nearest = 'Nizneangarsk'
            
        if SITE_REQUIRED == 'Lake Baikal 19501970':
            self.nearsites = [['Zigalovo_1950_1970', 54.8, 105.2],
                              ['Nizneangarsk_1950_1970', 55.8, 109.6],
                              ['Kalakan_1950_1970', 55.1, 116.8]
                              ]
            self.nearest = 'Nizneangarsk_1950_1970'
            
    def get_meteoanncycle(self):
        
        anncycle = {
            "Krasnojarsk" : [-16.7575, -14.9292, -7.16471, 1.79832,    
                             9.57983, 16.3615, 19.0419, 15.8119,
                             9.34746, 1.61453, -8.17542, -15.3414], 
            "Nizneudinsk": [-21.3235, -19.0240, -9.20600, 0.672549,
                            7.95306, 14.5939, 17.0184, 14.1551,
                            7.68367, -0.253061, -10.9122, -19.0490],  
            "Nizneangarsk": [-22.2907, -21.3667,  -12.8852, -3.03148,
                             4.41731, 11.7189, 15.5906, 14.5269, 
                             7.85741, -1.11481, -11.3630, -17.8389],
            "Kalakan" : [-34.8708, -27.9969, -16.5879, -3.28750, 
                         6.24923, 13.7091, 16.6369, 13.5492,  
                         5.68438,  -5.90909, -22.3375, -32.9889],
            "Zigalovo" : [-27.9258, -24.3152, -12.6881, -0.409091,  
                          7.56562, 14.8478,  17.5433, 14.2940, 
                          6.71912, -2.14118, -15.0515, -24.7530],
            "Kalakan_1950_1970" : [-35.7381, -29.6000,   -17.4048,
                                   -4.49500,   5.98571,   13.4190, 
                                   16.4429,    13.5048,  5.23333,
                                    -6.30952,   -23.4200, -33.8190],     
            "Nizneangarsk_1950_1970" :[-22.3842,  -21.9474,  -13.5684,
                                       -3.92632,   3.93684,  10.6421,
                                        14.9789, 14.2000,  7.21000,
                                        -0.935000,  -12.5700,  -18.4150],
            "Zigalovo_1950_1970" : [-28.3476,  -25.6952,  -14.0571, 
                                    -1.68571,  7.35714,  14.5143,
                                    17.5952,  14.4571,  6.22857,
                                     -2.30476, -16.6238,  -25.5000]
                }
        
        monthnames = ['ja','fb','mr','ar','my','jn',
                       'jl','ag','sp','ot','nv','dc']
        allseascyc = []
        allseascyc_anom = []
         
        fig = plt.figure(figsize=(11.0, 8.5))
        ax=plt.subplot(2,1,1)
         
        for siteinfo in self.nearsites:
            sitename = siteinfo[0]
            sitelon = np.str(np.round(siteinfo[2])) + ' deg E'
            site_anncycle = anncycle.get(sitename)
            print(sitename, np.mean(site_anncycle))
            allseascyc.append(site_anncycle)
            if sitename == self.nearest:
                ann_cycle_nearest = site_anncycle
            ax.plot(monthnames, site_anncycle,label=sitename + ' ' + sitelon)
            if (sitename[0:7]) == 'Zigalov':
                ann_cycle_zigalov = np.array(site_anncycle)
                lon_zigalov = siteinfo[2]
            if (sitename[0:7]) == 'Kalakan':
                ann_cycle_kalakan = np.array(site_anncycle)
                lon_kalakan = siteinfo[2]
                anom = ((ann_cycle_zigalov - ann_cycle_kalakan) 
                                         * (109.0 - lon_kalakan)
                                         / (lon_zigalov - lon_kalakan))
                est_ann_cycle_Baikal = ann_cycle_kalakan + anom
                print('est cycle',est_ann_cycle_Baikal)
                print('est mean baikal',np.mean(est_ann_cycle_Baikal))
               
        print('anomalous annual cycle', est_ann_cycle_Baikal - ann_cycle_nearest)   
    
      
       
        box = ax.get_position()
        ax.set_position([box.x0, box.y0+(0.3*box.height), box.width * 0.8, (0.8*box.height)])
        ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
        plt.title('annual cycle for sites near ' + SITE_REQUIRED)
        
        ax=plt.subplot(2,1,2)
        for siteinfo in self.nearsites:
            sitename = siteinfo[0]
            sitelon = np.str(np.round(siteinfo[2])) + ' deg E'

            anncyc_anom = np.array(anncycle.get(sitename)) - np.array(ann_cycle_nearest)
            allseascyc_anom.append(anncyc_anom)
            if sitename != self.nearest:
                ax.plot(monthnames, anncyc_anom, label= sitename + ' ' + sitelon)
              
        ax.axhline(y=0)
        box = ax.get_position()
        ax.set_position([box.x0, box.y0+(0.3*box.height), box.width * 0.8, (0.8*box.height)])
        ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
        plt.title('annual cycle anomaly from ' + self.nearest)
        
        
        plt.savefig(FILESTART + '/Growing_seas/Meteorological_data/seas_cyc_near_' + SITE_REQUIRED + PLOTTYPE)
        plt.close()
        
        return (self.nearsites, allseascyc, allseascyc_anom,
                est_ann_cycle_Baikal)
        





def get_model_data(period, modelname, lat, lon):
    """
    gets the model data for each month of the year for the site.
    """
    
    lonreq=lon
    if lonreq < 0.:
        lonreq=lonreq + 360.
   
    filename = (FILESTART + '/regridded/' + modelname + '/'+ period + '.'
                + FIELD + '.mean_month.nc')
    
    
    fieldname = FIELD
   
    if modelname == 'GISS2.1G' or modelname == 'IPSLCM6A':
        if fieldname == 'NearSurfaceTemperature':
            fieldname = 'air_temperature'
        if fieldname == 'TotalPrecipitation':
            fieldname = 'precipitation_flux'
    
  
    field_cube = iris.load_cube(filename,
                              fieldname)
    
    
    lat_ix = (np.abs(field_cube.coord('latitude').points - lat)).argmin()
    lon_ix = (np.abs(field_cube.coord('longitude').points - lonreq)).argmin()
    
    seas_field = field_cube.data[:, lat_ix, lon_ix]
   
   
    return seas_field.data



def plot_seascyc_vs_data(proxyT, models_Tseas, siteinfo, period):
    """
    plots the temperature from the data vs the modelled seasonal cycle.

    """
    
    ylab = {'NearSurfaceTemperature': 'degC',
            'TotalPrecipitation': 'mm/day'}
    
    ax = plt.subplot(111)
    
    print(siteinfo[0])
    for i, mod_data in enumerate(models_Tseas):
        if i > 6:
            ax.plot(mod_data, linestyle='dashed', label=MODELNAMES[i])
        else:
            ax.plot(mod_data, label=MODELNAMES[i])
        MAT = np.mean(mod_data)
        ax.plot([-1.0,0], [MAT, MAT], color='blue')
        print(MODELNAMES[i],
              np.around(np.sqrt(((mod_data - proxyT) ** 2).mean())))
        
        
       # print('mean=',np.around(np.mean(mod_data),2), 
       #       ' median=', np.around(np.median(mod_data),2),
       #       ' avg wam/cold=', np.around((np.max(mod_data) + np.min(mod_data)) / 2.0, 2))
        
    
    ax.plot(proxyT, label=siteinfo[0], color='black', linewidth=2)
    title = (siteinfo[0] + ' lat=' + np.str(np.around(siteinfo[1])), 
        ' lon='+np.str(np.around(siteinfo[2])))
    plt.title(title)
    plt.xlabel('month')
    plt.ylabel(ylab.get(FIELD))
    
    
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
    ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
    
    plt.savefig(FILESTART + '/Growing_seas/Meteorological_data/seas_cyc_' + siteinfo[0] +  '_' + period + PLOTTYPE)
    plt.close()


def plot_model_near_site(lons, all_month_pi, all_month_plio, monthname):
    """
    plots the modelled temperature at the site and for some nearby
    gridboxes
    lons = list of longitudes
    all_seascyc = seasonal cycle at (list of longs (list of models))
    """
    
    fig = plt.figure(figsize=(11.0, 11.0))
    fig.suptitle(monthname + 'temperature gradient: pi (blue), plio (red)', fontsize=20)
    fig.text(0, 0.5, 'temperature deg C', rotation=90, fontsize=20, verticalalignment = 'center')
    fig.text(0.6, 0.0, 'longitude deg E', fontsize=20, horizontalalignment = 'center')
    for i, model in enumerate(MODELNAMES):
        ax = plt.subplot(4,4,i+1)
        plt.title(model)
        monthtemp = all_month_pi[:, i] - all_month_pi[0, i]
        monthtemp_plio = all_month_plio[:, i] - all_month_plio[0, i]
        ax.plot(lons, monthtemp, color='blue')
        ax.plot(lons, monthtemp_plio, color='red')
    
       
    plt.subplots_adjust(left=0.05, bottom=0.05, right=1.00, top=0.9,
                        wspace=0.3, hspace=0.3)
       
    plt.savefig(FILESTART + '/Growing_seas/' + monthname + '_near_' + SITE_REQUIRED + PLOTTYPE, bbox_inches='tight')
    plt.close()
        




  
def main():
    """
    calling structure
    a) get modern meteorological data seasonal cycle
    b) get modern data at the location of interest
    """

#    #########################################
#    # get data for modern sites.  
    
    siteinfo = GetMeteodata() # get data for t1 timeslice
    (sitenames, seascyc, seascyc_anom,
     est_ann_cycle_Baikal_nolake)  = siteinfo.get_meteoanncycle()
       
    sitenames.append(['Estimated Lake Baikal (without lake)', 
                      55.0, 108.0])
    seascyc.append(est_ann_cycle_Baikal_nolake)
    
    #################################################
    # get PI model data for each month of the year.
    for siteno, sitedetails in enumerate(sitenames):
        sitelat = sitedetails[1]
        sitelon = sitedetails[2]
        allmodel_TseascycPI = []
   
        for i, model in enumerate(MODELNAMES):
            T_seascyc = get_model_data('E280', model, sitelat, sitelon)
            allmodel_TseascycPI.append(T_seascyc)
      
        plot_seascyc_vs_data(seascyc[siteno], allmodel_TseascycPI,
                          sitedetails, 'E280')
        
    #############################################
    # look and see if the modelled seasonal cycle
    # at the location is different from nearby gridboxes
        
    lons_list = []
    PI_Jan = []
    Plio_Jan = []
    PI_Jul = []
    Plio_Jul = []
   
    for lon in range(np.int(np.floor(sitelon)) - 5, 
                     np.int(np.ceil(sitelon)) + 5):
        lons_list.append(lon)
        allmodel_Jan = []
        allmodel_Jan_plio = []
        allmodel_Jul = []
        allmodel_Jul_plio = []
        for model in MODELNAMES:
            T_seascyc = get_model_data('E280', model, sitelat, lon)
            T_seascyc_plio = get_model_data('EOI400', model, sitelat, lon)
            allmodel_Jan.append(T_seascyc[0])
            allmodel_Jan_plio.append(T_seascyc_plio[0])
            allmodel_Jul.append(T_seascyc[6])
            allmodel_Jul_plio.append(T_seascyc_plio[6])
            
            
        PI_Jan.append(allmodel_Jan)
        Plio_Jan.append(allmodel_Jan_plio)
        PI_Jul.append(allmodel_Jul)
        Plio_Jul.append(allmodel_Jul_plio)
        
    plot_model_near_site(lons_list, np.asarray(PI_Jan),
                         np.asarray(Plio_Jan),
                         'January')
    plot_model_near_site(lons_list, np.asarray(PI_Jul),
                         np.asarray(Plio_Jul),
                         'July')
            
  
    
 
       
##########################################################
# main program


LINUX_WIN = 'w'


if LINUX_WIN == 'l':
    FILESTART = '/nfs/hera1/earjcti/'   
    LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE = '.eps'
else:
    FILESTART = 'C:\\Users\\julia\\OneDrive\\WORK\\DATA\\'
    LAND_DATAFILE = (FILESTART + '/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE = '.png'
 

MODELNAMES = ['CESM2', 
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L', 'MRI2.3', 'NorESM1-F'
              ]

#MODELNAMES = ['CESM2','IPSLCM6A']

ABSOLUTE_ANOMALY_IND = 'absolute' # do we want to compare the absolute value or the anomaly value.
FIELD = 'NearSurfaceTemperature'
#FIELD = 'TotalPrecipitation'

SITE_REQUIRED = 'Lake Baikal'
#SITE_REQUIRED = 'Lake Baikal 19501970'
#SITE_REQUIRED = 'Lake Elgygytgyn'
#SITE_REQUIRED = 'Meighen Island'
#SITE_REQUIRED = 'Lost Chicken Mine'
#SITE_REQUIRED = 'James Bay Lowland'
#SITE_REQUIRED = 'Pula Maar'
#SITE_REQUIRED = 'Alpes-Maritimes'
#SITE_REQUIRED = 'Tarragona'
#SITE_REQUIRED = 'Rio Maior'
#SITE_REQUIRED = 'Yallalie, Perth'

main()
::::::::::::::
Land_DMC_growing_season.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on September 2020
# 
#  This program will look at the temperature data provided by Ulrich.
#  It will assess whether the temperature agrees better with a particular
#  time of year. 
#
#  The ultimate aim is to do a better DMC by comparing the model
#  to the times when the proxy represents.  
#
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

 
def get_land_obs():
    """
    reads in the spredsheet from ulrich and returns 
    the field, latitude and longitude from the required site. 
    """

    if SITE_REQUIRED == 'Meighen Island':
        fielddata = 3.6
        lat = 77.5
        lon = -99.0

    if SITE_REQUIRED == 'Beaver Pond':
        fielddata = 1.1
        lat = 79.0
        lon = -82.0
   
    if SITE_REQUIRED == 'Flyes Leaf Bed':
        fielddata = 1.0
        lat = 79.0
        lon = -83.0

    if SITE_REQUIRED == 'Lake Elgygytgyn':
        fielddata = 16.0
        lat = 67.0
        lon = -172.0
    dfs = pd.read_excel(LAND_DATAFILE)
    found = 'n'
    
    if FIELD == 'NearSurfaceTemperature':
        colreq = 9
    if FIELD == 'TotalPrecipitation':
        colreq = 11
   
    
    for index, row in dfs.iterrows():
        if row[0] == SITE_REQUIRED:
            found = 'y'
            fielddata = row[colreq]
            lat = row[2]
            lon = row[3]
            pass
            
    
    if found == 'n' and SITE_REQUIRED != 'Meighen Island':
        print('couldnot find site in Ulrichs file')
   #     sys.exit(0)
        
    if FIELD == 'TotalPrecipitation':
       fielddata = fielddata / 365.
    
   
    return fielddata, lat, lon




def get_model_data(period, modelname, lat, lon, field):
    """
    gets the model data for each month of the year for the site.
    """
    
    fielduse = {'T' : 'NearSurfaceTemperature',
                'P' : 'TotalPrecipitation'}
    lonreq=lon
    if lonreq < 0.:
        lonreq=lonreq + 360.
    filename = (FILESTART + '/regridded100/' + modelname + '/'+ period + '.'
                + fielduse.get(field) + '.mean_month.nc')
    
    fieldname = fielduse.get(field)
   
    if modelname == 'GISS2.1G' or modelname == 'IPSLCM6A':
        if fieldname == 'NearSurfaceTemperature':
            fieldname = 'air_temperature'
        if fieldname == 'TotalPrecipitation':
            fieldname = 'precipitation_flux'
    if modelname == 'HadGEM3_TEMPORARY':
        if fieldname == 'NearSurfaceTemperature':
            fieldname = 'temp'
    
  
    field_cube = iris.load_cube(filename,
                              fieldname)
    
    
    lat_ix = (np.abs(field_cube.coord('latitude').points - lat)).argmin()
    lon_ix = (np.abs(field_cube.coord('longitude').points - lonreq)).argmin()
    
    seas_field = field_cube.data[:, lat_ix, lon_ix]
   
   
    return seas_field.data



def plot_seascyc_vs_proxy(proxyT, models_Tseas, lat, lon, period):
    """
    plots the temperature from the data vs the modelled seasonal cycle.

    """
    
    ylab = {'NearSurfaceTemperature': 'degC',
            'TotalPrecipitation': 'mm/day'}
    
    ax = plt.subplot(111)
    for i, mod_data in enumerate(models_Tseas):
        if i > 6:
            ax.plot(mod_data, linestyle='dashed', label=MODELNAMES[i])
        else:
            ax.plot(mod_data, label=MODELNAMES[i])
        MAT = np.mean(mod_data)
        ax.plot([-1.0,0], [MAT, MAT], color='blue')
        
        
        
    if proxyT > -100:
        ax.axhline(y=proxyT)
    title = SITE_REQUIRED + ' lat=' + np.str(np.around(lat)), ' lon='+np.str(np.around(lon))
    plt.title(title)
    plt.xlabel('month')
    plt.ylabel(ylab.get(FIELD))
    
    
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
    ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
   

    if period == 'anom':
        periodwrite = EXPTNAME + '-' + PI_EXPT
    else:
        periodwrite = period
        
    plt.savefig(FILEOUTSTART + 'seas_cyc_' + FIELD + '_' + periodwrite + '_' + SITE_REQUIRED.replace(' ','_') + PLOTTYPE)
    plt.close()
   
    

def get_lsm_for_cube(cube):
    """
    get's the PI land sea mask and checks it is on the same grid as cube

    """
    LSMfile = (FILESTART + 'regridded/PlioMIP2_Boundary_conds/Modern_std' 
            + '/Modern_std/Modern_std_LSM_v1.0.nc')
    lsm_pi_cube = iris.load_cube(LSMfile)
    if LINUX_WIN == 'l':
        cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    else:
        cubegrid = iris.load_cube('C:\\Users\\julia\\OneDrive\\WORK\\PROGRAMS\\one_lev_one_deg.nc')

    regrid_lsm_cube = lsm_pi_cube.regrid(cubegrid, iris.analysis.Linear())
    
    for i, lsm in enumerate(regrid_lsm_cube.coord('longitude').points):
        if lsm != cube.coord('longitude').points[i]:
            print('lsm lon error')
            print(lsm, cube.coord('longitude').points[i])
            sys.exit(0)
       
    for j, lsm in enumerate(regrid_lsm_cube.coord('latitude').points):
         if lsm != cube.coord('latitude').points[j]:
            print('lsm lat error')
            print(lsm, cube.coord('latitude').points[i])
            sys.exit(0)
            
   
        
    return regrid_lsm_cube
        
#####################################################        
  
def locate_PI_with_plioJulyT(model, temp_req, lonreq, proxy_lat):
    """
    this subroutine will find locations in the preindustrial MAT file 
    which have July temperature of temp_req
    The site must be land and within 30deg of lonreq
    temperature

    """
    
    def get_near_tempreq(cube, errormargin, mask, lsm):
        
        indexes= []
        cube_loc = cube.copy(data = np.zeros(np.shape(cube.data)))
        for index, temp in np.ndenumerate(cube.data):
            if (temp_req - errormargin < temp < temp_req + errormargin):
                if mask.data[index] == 1.0:
                    cube_loc.data[index] = 1.0
                    indexes.append(index)
                   
        
    
        return indexes
    
    def get_mean_min(): 
        """
        gets the july temperature and the january temperature
        from the pi cube for each index
        """
        jan_temps = []
        mean_rain = []
        lons = []
        lats = []
        
        for ix in indexes:
            jan = cube.data[0, ix[0], ix[1]]
            mean = cubeprecip_annmean.data[ix[0], ix[1]]
            jan_temps.append(jan)
            mean_rain.append(mean)
            lons.append(cubeprecip_annmean.coord('longitude').points[ix[1]])
            lats.append(cubeprecip_annmean.coord('latitude').points[ix[0]])
            
        
        return jan_temps, mean_rain, lons, lats
    
    # get data and LSM 
    if model == 'MMM':
        filename = (FILESTART + 'regridded100/' + 
                    'NearSurfaceTemperature_multimodelmean_month.nc')
        cube = iris.load_cube(filename, 'NearSurfaceTemperaturemean_pi')
        filename = (FILESTART + 'regridded100/' + 
                    'TotalPrecipitation_multimodelmean_month.nc')
        cubeprecip = iris.load_cube(filename, 'TotalPrecipitationmean_pi')
    else:
        filename = (FILESTART + 'regridded100/' + model + 
                    '/E280.NearSurfaceTemperature.mean_month.nc')
        if model == 'GISS2.1G' or model == 'IPSLCM6A':
            fieldname = 'air_temperature'
        else:
            fieldname = 'NearSurfaceTemperature'    
        cube = iris.load_cube(filename, fieldname)
        filename = (FILESTART + 'regridded100/' + model + 
                    '/E280.TotalPrecipitation.mean_month.nc')
        if model == 'GISS2.1G' or model == 'IPSLCM6A':
            fieldname = 'precipitation_flux'
        else:
            fieldname = 'TotalPrecipitation'    
        cubeprecip = iris.load_cube(filename, fieldname)
        
 
    if model == 'HadGEM3' or model == 'MMM':
        cube_julymean =  cube.extract(iris.Constraint(time=7))
    else:
        cube_julymean =  cube.extract(iris.Constraint(month=7))
    cubeprecip_annmean =  cubeprecip.collapsed(['time'], iris.analysis.MEAN)
    
    lsm = get_lsm_for_cube(cube)
    mask = get_lsm_for_cube(cube)
    for i, lon in enumerate(lsm.coord('longitude').points):
        if lon < lonreq - 10.:
            mask.data[:,i] = 0
        if lon > lonreq + 10.:
            mask.data[:,i] = 0
    for j, lat in enumerate(lsm.coord('latitude').points):
        if lat < proxy_lat - 50.:
            mask.data[j,:] = 0
       
    
    indexes = get_near_tempreq(cube_julymean, 2.0, mask, lsm)
    mintemps, meanrain,  lons, lats  = get_mean_min()
    
    return mintemps, meanrain, lons, lats


def locate_PI_with_plioMAT(model, temp_req, lonreq, proxy_lat):
    """
    this subroutine will find locations in the preindustrial MAT file 
    which have MAT of temp_req
    The site must be land and within 45deg of lonreq
    temperature

    """
    
    def get_near_tempreq(cube, tempreq, errormargin, mask, lsm):
        
        indexes= []
        cube_loc = cube.copy(data = np.zeros(np.shape(cube.data)))
        for index, temp in np.ndenumerate(cube.data):
            if (tempreq - errormargin < temp < tempreq + errormargin):
                if mask.data[index] == 1.0:
                    cube_loc.data[index] = 1.0
                    indexes.append(index)
                  
        #qplt.contourf(cube_loc)  
        #iplt.contour(lsm, colors='black', linewidths=0.1)
        #plt.scatter(lonreq, proxy_lat, color='red',transform=ccrs.Geodetic())
        #plt.show()
        
    
        return indexes
    
    def get_max_min():
        """
        gets the july temperature and the january temperature
        from the pi cube for each index
        """
        jan_temps = []
        july_temps = []
        range_temps = []
       
        for ix in indexes:
            jan = cube.data[0, ix[0], ix[1]]
            jul = cube.data[6, ix[0], ix[1]]
            jan_temps.append(jan)
            july_temps.append(jul)
            range_temps.append(jul - jan)
            
           
      
        return jan_temps, july_temps, range_temps
    
    # get data and LSM 
    filename = FILESTART + 'regridded100/' + model + '/E280.NearSurfaceTemperature.mean_month.nc'
    if model == 'GISS2.1G' or model == 'IPSLCM6A':
        fieldname = 'air_temperature'
    else:
        fieldname = 'NearSurfaceTemperature'
        
    cube = iris.load_cube(filename, fieldname)
    cube_annmean =  cube.collapsed(['time'],
                                    iris.analysis.MEAN)
    
    lsm = get_lsm_for_cube(cube)
    mask = get_lsm_for_cube(cube)
    for i, lon in enumerate(lsm.coord('longitude').points):
        if lon < lonreq - 30.:
            mask.data[:,i] = 0
        if lon > lonreq + 30.:
            mask.data[:,i] = 0
    for j, lat in enumerate(lsm.coord('latitude').points):
        if lat < 0.:
            mask.data[j,:] = 0
       
    
   
    indexes = get_near_tempreq(cube_annmean, temp_req, 1.0, mask, lsm)
    maxtemps, mintemps, temprange = get_max_min()
    
    
    return maxtemps, mintemps, temprange
  
def plot_scatter_temperatures(temp_xaxis, temp_yaxis, modelname, i,
                              temp_xplio, temp_yplio, titlename,
                              yaxistitle, xaxistitle,
                              fileout):
    """
    does a scatter plot of the temperatures on a multi subplot figure
    temp_xaxis and temp_yaxis is the preindustrial temperatures that 
    will be plotted in blue
    temp_xplio and temp_yplio is the pliocene temperature at the site that 
    will be plotted in red

    """
    
    if i == 0:
        fig = plt.figure(figsize=(11.0, 11.0))
        fig.suptitle(titlename, fontsize=20)
        fig.text(0, 0.5, yaxistitle, rotation=90, fontsize=20, verticalalignment = 'center')
        fig.text(0.6, 0.0, xaxistitle, fontsize=20, horizontalalignment = 'center')
    
    if modelname == 'MMM':
        xplot = 1
        yplot = 1
        plotpos = 1
    else:
        xplot = 4
        yplot = 5
        plotpos = np.mod(i, xplot * yplot) + 1

    plt.subplot(xplot, yplot, plotpos)
    plt.scatter(temp_xaxis, temp_yaxis)
    plt.scatter(temp_xplio, temp_yplio, color='red')
    plt.title(modelname)
        
    if (plotpos == (xplot * yplot)
        or i == len(MODELNAMES) - 1
        or modelname == 'MMM'):
       
        plt.subplots_adjust(left=0.05, bottom=0.05, right=1.00, top=0.9,
                            wspace=0.3, hspace=0.3)
        plt.savefig(fileout, bbox_inches='tight')
        plt.close()
      
def plot_locations_match(modellons, modellats, proxylon, proxylat, 
                         modeltemps, fileout, modelnames, jandata,
                         janplio):
    """
    this will plot the locations where the model has pi data the same as the 
    pliocene site
    """
    def get_minmax(proxydata, modeldata):
        """
        gets the minimum or maximum of the model data or the proxy data
        """
        minval = proxydata
        maxval = proxydata
        for lons in modeldata:
            minval = np.min([minval, np.min(lons)])
            maxval = np.max([maxval, np.max(lons)])

        return minval, maxval
      
        
    if len(modelnames) > 1:
        fig = plt.figure(figsize=(11.0, 11.0))
        fig.suptitle(SITE_REQUIRED + 'All sites have same july temperature: pliocene (red) matches pi (blue)', fontsize=15)
      
    lonmin, lonmax = get_minmax(proxylon, modellons)
    latmin, latmax = get_minmax(proxylat, modellats)


    for i, model in enumerate(modelnames):
        lons = modellons[i]
        lats = modellats[i]
       
        left = False
        right = False
        top = False
        bottom = False

        if np.mod(i, 4) == 0:
           left = True
        if np.mod(i, 4) == 3:
           tight = True
        if i > 12:
           bottom = True

        if len(modelnames) == 1:
            plt.subplot(1,1,1)
        else:
            plt.subplot(4,5,i+1)
        #m=Basemap(llcrnrlon=lonmin-5.,urcrnrlon=lonmax+5.,
        #          llcrnrlat=latmin -5.,
        #          urcrnrlat=latmax+5.,projection='cyl',resolution='c')
        #m.drawmapboundary
        #m.drawcoastlines()
        #parallels=np.arange(-90.,90.,20.)
        #m.drawparallels(parallels,labels=[left,right,top,bottom],fontsize=10) # labels right
        #meridians=np.arange(-180.,180.,20.)
        #m.drawmeridians(meridians,labels=[left,right,top,bottom],fontsize=10)
    
        #ax = plt.axes(projection=ccrs.Robinson(central_longitude=0))
        ax = plt.axes(projection=ccrs.PlateCarree())
        ax.set_extent([lonmin-5., lonmax + 5., latmin-5., latmax+5.])
        ax.coastlines()
        gl = ax.gridlines(draw_labels=True)
        gl.xlabels_top = False
        gl.left_labels = False

       
        if model == 'MMM':
            V = np.arange(np.min(jandata), np.max(jandata), 2)
            #V = np.arange(-40, 10, 5)
            #mycmap = 'gist_earth'
            mycmap = plt.get_cmap('gist_earth')
            #rgb_cm = cmap.colors  # returns array-like color
            norm = colors.BoundaryNorm(boundaries=V, ncolors=mycmap.N)
  
            print(jandata)
            scatter = plt.scatter(lons, lats, c=jandata,  marker='o', s=20,
                               norm = norm , cmap=mycmap, 
                                transform=ccrs.Geodetic())

           # plt.scatter(proxylon, proxylat, c=janplio,marker='s', s=50,
           #                    norm = norm , cmap=mycmap, 
           #                     transform=ccrs.Geodetic())
            print(lons,lats)
            print(proxylon, proxylat)
            plt.text(proxylon, proxylat, 'x', fontsize=30, 
                                transform=ccrs.Geodetic())
            
            plt.text(proxylon+2.0, proxylat - 0.5, SITE_REQUIRED, 
                                transform=ccrs.Geodetic())
           
            cbar = plt.colorbar(scatter, orientation = 'horizontal')
            cbar.set_label('cold month temperature (degC)')
        else:
            plt.scatter(proxylon, proxylat, c='red',marker='s', s=50)
            plt.scatter(lons, lats, c='blue',  marker='o', s=10)
       


        if model == 'MMM':
            plt.title('PI Locations with WMMT the same as' + 
                      ' mPWP ' + SITE_REQUIRED)
        else:
            plt.title(model + ' ' + np.str(np.around(modeltemps[i])))


    plt.subplots_adjust(left=0.05, bottom=0.05, right=1.00, top=0.9,
                            wspace=0.3, hspace=0.3)
    plt.savefig(fileout, bbox_inches='tight')
    plt.close()

  
def main():
    """
    calling structure
    a) get data from Ulrichs spreadsheet
    b) get's proxy data
    c) plots model data with proxy data on top
    """
 
#    #########################################
#    # get data from Ulrichs spreadsheet
    
    proxy_temperature, proxy_lat, proxy_lon = get_land_obs()
    
    #################################################
    # get Pliocene model data for each month of the year.
    allmodel_Tseascyc = []
    allmodel_Pseascyc = []
    for model in MODELNAMES:
        T_seascyc = get_model_data(EXPTNAME, model, proxy_lat, proxy_lon,'T')
        P_seascyc = get_model_data(EXPTNAME, model, proxy_lat, proxy_lon,'P')
        allmodel_Tseascyc.append(T_seascyc)
        allmodel_Pseascyc.append(P_seascyc)
       

        
    plot_seascyc_vs_proxy(proxy_temperature, allmodel_Tseascyc,
                          proxy_lat, proxy_lon,EXPTNAME)
        
    
    #################################################
    # get PI model data for each month of the year.
    allmodel_TseascycPI = []
    allmodel_Tseascycanom = []
    for i, model in enumerate(MODELNAMES):
        T_seascyc = get_model_data(PI_EXPT, model, proxy_lat, proxy_lon,'T')
        allmodel_TseascycPI.append(T_seascyc)
       
        allmodel_Tseascycanom.append(allmodel_Tseascyc[i] - T_seascyc)
    
   
       
    plot_seascyc_vs_proxy(-3.61, allmodel_TseascycPI,
                          proxy_lat, proxy_lon, PI_EXPT)
    plot_seascyc_vs_proxy(-999.999, allmodel_Tseascycanom,
                          proxy_lat, proxy_lon, 'anom')
    
    ##############################################################
    # find the PI locations which have the same MAT as the
    # Pliocene temperature for our site.  
    
    titlename = ('Red - Pliocene Jan/july temperatures at ' + SITE_REQUIRED +  
                 ', \n Blue - Preindustrial Jan/July temperatures for preindustrial sites which have the' + 
                 ' same MAT as ' + SITE_REQUIRED)
    fileout = (FILEOUTSTART + SITE_REQUIRED.replace(' ','_')  + 
               '_Jan_July_T_for_this_MAT' + EXPTNAME + PLOTTYPE)
    if proxy_lon < 0: proxy_lon = proxy_lon + 360.
    for i, model in enumerate(MODELNAMES):
        mean_plio_temp = np.mean(allmodel_Tseascyc[i])
        

        janT, julyT, T_seascyc_amp = locate_PI_with_plioMAT(model, mean_plio_temp, proxy_lon, proxy_lat)

        plot_scatter_temperatures(janT, julyT, model, i,
                                  allmodel_Tseascyc[i][0],
                                  allmodel_Tseascyc[i][6],
                                  titlename, 'July temperature',
                                  'January temperature', fileout)
        
    
    ##############################################################
    # find the PI locations which have the same July as the
    # Pliocene temperature for our site.  
    
    titlename = ('Red - Pliocene Jan/MAT temperatures at ' + SITE_REQUIRED +  
                 ', \n Blue - Preindustrial Jan/MAT for PI sites which have the' + 
                 ' same July temperature as ' + SITE_REQUIRED)
    fileout = (FILEOUTSTART + SITE_REQUIRED.replace(' ','_')  + 
               '_JanT_MAT_for_this_JulyT' + EXPTNAME + PLOTTYPE)
    modellons = []
    modellats = []
    julytemp = []
    modelpi_janT = []
    for i, model in enumerate(MODELNAMES):
        july_plio_temp = allmodel_Tseascyc[i][6]
        mean_plio_precip = np.mean(allmodel_Pseascyc[i])
        print(allmodel_Pseascyc[i])
     
        julytemp.append(july_plio_temp)
        
        janT, MAP, lons, lats = locate_PI_with_plioJulyT(model, july_plio_temp, proxy_lon, proxy_lat)
        modellons.append(lons)
        modellats.append(lats)
        modelpi_janT.append(janT)
       
        plot_scatter_temperatures(janT, MAP, model, i,
                                  allmodel_Tseascyc[i][0],
                                  mean_plio_precip,
                                  titlename, 'MAP',
                                  'January temperature', fileout)

    plt.close()
    # plot the locations where pi is same as plio.
    fileout =  FILEOUTSTART + SITE_REQUIRED.replace(' ','_') + 'locations_with_same_julyT' + EXPTNAME + PLOTTYPE
       
    plot_locations_match(modellons, modellats, proxy_lon, proxy_lat, julytemp, 
                         fileout, MODELNAMES, modelpi_janT,'0')
                        

    ###################################################################
    #  CHECK WHERE THE JULY TEMPERATURES IN PLIOCENE MATCH THE PI IN
    #  THE MULTIMODELMEAN

    MAPplio = np.mean(allmodel_Pseascyc)
    print(MAPplio)
#    sys.exit(0)
    janplio = np.mean(allmodel_Tseascyc, axis=0)[0]
    julplio = np.mean(allmodel_Tseascyc, axis=0)[6]
    julplio = 19.0
    (janTpi, MAPpi, 
     lonspi, latspi) = locate_PI_with_plioJulyT('MMM', julplio, 
                                                proxy_lon, proxy_lat)

    fileout = (FILEOUTSTART + SITE_REQUIRED.replace(' ','_')  + 
               '_MMM_analogies_' + EXPTNAME + PLOTTYPE)

    plot_scatter_temperatures(janTpi, MAPpi, 'MMM', 0,
                               janplio, MAPplio, 
                               titlename, 'MAP (mm/day)',
                               'January temperature', fileout)
    plt.close()
    fileout =  (FILEOUTSTART + SITE_REQUIRED.replace(' ','_') + 
                 'locations_with_MMM_julyT' + EXPTNAME + PLOTTYPE)
  
    plot_locations_match([lonspi], [latspi], proxy_lon, 
                          proxy_lat, [julplio], fileout, ['MMM'],
                         janTpi, janplio)
  #                       proxy_lat, [19.0], fileout, ['MMM'])
 




    #########################
    # some printouts for adding to paper

    
    allmeans = np.zeros(len(MODELNAMES))
    coldmeans = np.zeros(len(MODELNAMES))
    warmmeans = np.zeros(len(MODELNAMES))
    for i, model in enumerate(MODELNAMES):
        print('Jan, Jul mean', model, allmodel_Tseascyc[i][0],
              allmodel_Tseascyc[i][6], np.mean(allmodel_Tseascyc[i][:]))
        allmeans[i] = np.mean(allmodel_Tseascyc[i][:])
        coldmeans[i] = np.min(allmodel_Tseascyc[i][:])
        warmmeans[i] = np.max(allmodel_Tseascyc[i][:])
  
    print(SITE_REQUIRED, 'multmodelmean mean stdev',np.mean(allmodel_Tseascyc), np.mean(allmeans), np.std(allmeans))
    print(np.shape(allmodel_Tseascyc))
    print('mean annual cycle pliocene', np.mean(allmodel_Tseascyc, axis=0))
    print('mean annual cycle pi', np.mean(allmodel_TseascycPI, axis=0))
    print('standard deviation pliocene', np.std(allmodel_Tseascyc, axis=0))
    #print('max annual cycle pliocene', np.max(allmodel_Tseascyc, axis=0))
    #print('min annual cycle pliocene', np.min(allmodel_Tseascyc, axis=0))

    datameanmin = 6.65
    datameanmax = 7.65

    datacoldmin = -9.47
    datacoldmax = -6.73

    datawarmmin = 15.3
    datawarmmax = 20.5

    correctcold = 0
    correctwarm = 0
    correctmean = 0
    for i, model in enumerate(MODELNAMES):
        if datameanmin - 2.0  < allmeans[i] < datameanmax + 2.0:
            correctmean = correctmean + 1
        if datacoldmin - 2.0 < coldmeans[i] < datacoldmax + 2.0:
            correctcold = correctcold + 1
        if datawarmmin - 2.0 < warmmeans[i] < datawarmmax + 2.0:
            correctwarm = correctwarm + 1
            print('correctwarm',model)

    print('correct models', correctmean, correctwarm, correctcold)
    print('mean annual cycle pliocene', np.mean(allmodel_Tseascyc))
    print('mean annual cycle pi', np.mean(allmodel_TseascycPI))

    print('got to end of program')
##########################################################
# main program


LINUX_WIN = 'l'
EXPTNAME = 'EOI400'
PI_EXPT = 'E280'

if LINUX_WIN == 'l':
    FILESTART = '/nfs/hera1/earjcti/' 
    FILEOUTSTART = '/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/'
    LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE =  '.eps'
else:
    FILESTART = 'C:\\Users\\julia\\OneDrive\\WORK\\DATA\\'
    LAND_DATAFILE = (FILESTART + '/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')
    PLOTTYPE = '.png'
 

MODELNAMES = [
              'CESM2', 'HadGEM3',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'MRI2.3', 'NorESM1-F'
              ]

#MODELNAMES = [
#              'CESM2', 'HadGEM3',
#              'IPSLCM6A', 'CCSM4',
#              'COSMOS', 
#              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
#              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
#              'CCSM4-Utr', 'CCSM4-UoT', 
#              'NorESM-L',  'NorESM1-F'
#              ]

#MODELNAMES = ['COSMOS', 'HadCM3', 'MIROC4m']
#
ABSOLUTE_ANOMALY_IND = 'absolute' # do we want to compare the absolute value or the anomaly value
FIELD = 'NearSurfaceTemperature'
#FIELD = 'TotalPrecipitation'

#SITE_REQUIRED = 'Lake Baikal'
#SITE_REQUIRED = 'Lake Elgygytgyn'
SITE_REQUIRED = 'Meighen Island'
#SITE_REQUIRED = 'Beaver Pond'
#SITE_REQUIRED = 'Flyes Leaf Bed'
#ITE_REQUIRED = 'Lost Chicken Mine'
#SITE_REQUIRED = 'James Bay Lowland'
#SITE_REQUIRED = 'Pula Maar'
#SITE_REQUIRED = 'Alpes-Maritimes'
#SITE_REQUIRED = 'Tarragona'
#SITE_REQUIRED = 'Rio Maior'
#SITE_REQUIRED = 'Yallalie, Perth'

main()
::::::::::::::
map_seas_cyc.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on December 2020
# 
#  This program will plot a map showing the amplitude of the seasonal cycle 
#  over Land for the pliocene and the preindustrial
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

 




def mask_ocean_for_cube(cube, lsmfile):
    """
    get's the land sea mask and sets the cube value to missing where the  
    lsm is 0

    """
    lsm_cube = iris.load_cube(lsmfile)
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    
    regrid_lsm_cube = lsm_cube.regrid(cubegrid, iris.analysis.Linear())
    
    for i, lsm in enumerate(regrid_lsm_cube.coord('longitude').points):
        if lsm != cube.coord('longitude').points[i]:
            print('lsm lon error')
            print(lsm, cube.coord('longitude').points[i])
            sys.exit(0)
       
    for j, lsm in enumerate(regrid_lsm_cube.coord('latitude').points):
         if lsm != cube.coord('latitude').points[j]:
            print('lsm lat error')
            print(lsm, cube.coord('latitude').points[i])
            sys.exit(0)
    
    masked_cube = iris.util.mask_cube(cube, np.where(regrid_lsm_cube.data == 0))
    
    print(masked_cube.data)
        
    return masked_cube
        
  

def get_max_seascyc(fieldname):
    """
    gets the warm month temperature minus the cold month temperature
    """

    temp_cube = iris.load_cube(FILENAME, fieldname)
    warm_cube = temp_cube.collapsed(['time'], iris.analysis.MAX)
    cold_cube = temp_cube.collapsed(['time'], iris.analysis.MIN)

    ann_mean_cube = temp_cube.collapsed(['time'], iris.analysis.MEAN)
    seas_cyc_cube = warm_cube - cold_cube


    return seas_cyc_cube, ann_mean_cube, warm_cube, cold_cube

def plotcube(cube, period, outname, V, ax):
    """
    plots the cube to a file
    """

    ax.coastlines()
    ax.set_extent([-180, 180, 30, 80], ccrs.PlateCarree())
   
    cs = iplt.contourf(cube, V, extend = 'both')
    plt.title(period + ': ' + outname)
    if period == 'mPWP':
        cbar = plt.colorbar(cs, orientation = 'horizontal')
        cbar.set_label('degC')
        
   

def plot_locations2(match_cube, alt_seasoncube, precip_cube,
                    matchno, subscript):
    """
    we have a cube (match_cube) where the temperature has to match the matchno.
    This could be the warm_cube matching 20degC, or the cold_cube matching -10degC
    We find all the locations in match_cube which are close to match number
    We then plot all the locations (and their temperatures in the alt_seasoncube).  The alternative-season_cube could be either the warmcube or the cold cube
    """  

    lons = {'Lake Baikal' : 108., 'Lake Baikal M' : 108.,
            'Lost Chicken Mine' : -142., 'Lost Chicken Mine M' : -142.,
            'Lost Chicken Mine B' : -142.}
    lats = {'Lake Baikal' : 56., 'Lake Baikal M' : 56.,
            'Lost Chicken Mine' : 64., 'Lost Chicken Mine M' : 64.,
            'Lost Chicken Mine B' : 64.}
  
    
    
    lon = lons.get(SITE)
    lat = lats.get(SITE)
    lonalt = lon
    if lonalt > 180: lonalt = lon - 360.
   

    treqmin = matchno - 1.0
    treqmax = matchno + 1.0
    
  
    cube2 = match_cube.copy()
    cube3 = alt_seasoncube.copy()
    for index, point in np.ndenumerate(cube2.data):
        if treqmax < point  or treqmin > point:
            cube2.data[index] = 0
    for i, loncube in enumerate(cube2.coord('longitude').points):
        if lon  < loncube  or loncube < lon - 50:
            cube2.data[:, i] = 0
    for j, latcube in enumerate(cube2.coord('latitude').points):
        if 85 < latcube  or latcube < lat - 30:
            cube2.data[j, :] = 0
       
    masked_cube = iris.util.mask_cube(cube2, 
                                      np.where(cube2.data == 0))   
    masked_alt = iris.util.mask_cube(cube3, 
                                      np.ma.where(masked_cube.data.mask == 1))
            
    
    # plot locations and winter temperatures.
    
    ax1 = plt.subplot(221, projection = ccrs.PlateCarree())
    ax1.coastlines()
    ax1.set_extent([np.max([-180., lonalt - 50.]), lonalt + 50., lat-30., 85.], ccrs.PlateCarree())
    cs=iplt.contourf(masked_alt, extend='both')
    cbar = plt.colorbar(cs, orientation = 'horizontal')
    plt.text(lonalt, lat, 'x', fontsize=20)
    plt.text(lon+5.0, lat, SITE)        
    plt.title(subscript)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/' + SITE.replace(' ','_') + '_' + subscript + '.eps')
    
    # plot an histogram of the temperatures
    allvals = []
    precipvals = []
    for index, point in np.ndenumerate(masked_alt.data):
        val = masked_alt.data[index]
        if np.isfinite(val):
            allvals.append(val)
            precipvals.append(precip_cube.data[index] * 360.)
    ax2 = plt.subplot(222)
    num_bins = 10
    n, bins, patches = plt.hist(allvals, num_bins, alpha=0.5)
   
    # plot a scatter plot of the cold month temperatures vs the precip
    ax3 = plt.subplot(223)
    plt.scatter(allvals,precipvals)
    plt.xlabel('cold month temperature')
    plt.ylabel('precipitation')
   
    plt.tight_layout()
    plt.savefig(fileout)
    plt.close()



def plot_locations_bothmatch(warm_cube, cold_cube):
    """
    Is there a location where the warm temperature matches the warm cube
    and the cold temperature matches the cold cube
    """  

    lons = {'Lake Baikal' : 108., 'Lake Baikal M' : 108.,
            'Lost Chicken Mine' : -142., 'Lost Chicken Mine M' : -142.,
            'Lost Chicken Mine B' : -142.}
    lats = {'Lake Baikal' : 56., 'Lake Baikal M' : 56.,
            'Lost Chicken Mine' : 64., 'Lost Chicken Mine M' : 64.,
            'Lost Chicken Mine B' : 64.}
  
    
    lon = lons.get(SITE)
    lat = lats.get(SITE)
    lonalt = lon
    if lonalt > 180: lonalt = lon - 360.
   
    precision = 3.0
    locs_lon = []
    locs_lat = []
    warm_temp = []
    cold_temp = []
    
    cube2 = warm_cube.copy()
    data2 = cube2.data
    cube3 = cold_cube.copy()
    data3 = cube3.data
    for index, point_warm in np.ndenumerate(data2):
        point_cold = data3[index]
        
        if ((WARM_TEMP_REQ + precision  > point_warm 
        and WARM_TEMP_REQ - precision  < point_warm
        and COLD_TEMP_REQ + precision > point_cold
        and COLD_TEMP_REQ - precision < point_cold) and not data2.mask[index]):
            locs_lon.append(cube2.coord('longitude').points[index[1]])
            locs_lat.append(cube2.coord('latitude').points[index[0]])
            warm_temp.append(point_warm)
            cold_temp.append(point_cold)
        else:
            cube2.data[index] = 0
    
    for i, loncube in enumerate(cube2.coord('longitude').points):
        if lon  < loncube  or loncube < lon - 50:
            cube2.data[:, i] = 0
    for j, latcube in enumerate(cube2.coord('latitude').points):
        if 85 < latcube  or latcube < lat - 30:
            cube2.data[j, :] = 0
       
    for i, lon in enumerate(locs_lon):
        print(lon, locs_lat[i], warm_temp[i], cold_temp[i])
    print('MEAN', np.mean(np.asarray(warm_temp)), np.mean(np.asarray(cold_temp)), np.mean(np.asarray(warm_temp) - np.asarray(cold_temp)))
  
    # plot locations and winter temperatures.
    
    ax1 = plt.subplot(111, projection = ccrs.PlateCarree())
    ax1.coastlines()
    #ax1.set_extent([np.max([-180., lonalt - 50.]), lonalt + 50., lat-30., 85.], ccrs.PlateCarree())
    ax1.set_extent([-180, 180, -90, 90], ccrs.PlateCarree())
    #cs=iplt.contourf(masked_alt, extend='both')
    plt.scatter(locs_lon, locs_lat)
    #cbar = plt.colorbar(cs, orientation = 'horizontal')
    plt.text(lonalt, lat, 'x', fontsize=20)
    plt.text(lonalt-20.0, lat-5, SITE)        
   # plt.title(subscript)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/' + SITE.replace(' ','_') + '_bothmatch.eps')
    
    plt.tight_layout()
    plt.savefig(fileout)
    plt.close()

  
                                      

def plot_locations(cube, warm_cube, cold_cube):
    """
    we have a value for the required annual cycle.  We will plot all locations
    which have this annual cycle
    """  

    lons = {'Lake Baikal' : 108., 'Lake Baikal M' : 108.,
            'Lost Chicken Mine' : -142., 'Lost Chicken Mine M' : -142.,
            'Lost Chicken Mine B' : -142.}
    lats = {'Lake Baikal' : 56., 'Lake Baikal M' : 56.,
            'Lost Chicken Mine' : 64., 'Lost Chicken Mine M' : 64.,
            'Lost Chicken Mine B' : 64.}
    treqmin = ANN_CYC_REQ - 1.0
    treqmax = ANN_CYC_REQ + 1.0
    
  
    cube2 = cube.copy()
    for index, point in np.ndenumerate(cube2.data):
        if treqmax < point  or treqmin > point:
            cube2.data[index] = 0
           
    masked_cube = iris.util.mask_cube(cube2, 
                                      np.where(cube2.data == 0))
    masked_warm = iris.util.mask_cube(warm_cube, 
                                      np.ma.where(cube2.data.mask == 1))
    masked_cold = iris.util.mask_cube(cold_cube, 
                                      np.ma.where(cube2.data.mask == 1))
    
    # plot
    lon = lons.get(SITE)
    lat = lats.get(SITE)

    ax1 = plt.subplot(221, projection = ccrs.PlateCarree())
    ax1.coastlines()
    ax1.set_extent([np.max([lon - 50., -180.]), lon + 50., lat-50., 85.], ccrs.PlateCarree())
    #V = np.arange(13, 28, 3)
    cs=iplt.contourf(masked_warm)
    cbar = plt.colorbar(cs, orientation = 'horizontal')
    plt.text(lon, lat, 'x', fontsize=20)
    plt.text(lon+5.0, lat, SITE)
   
    ax2 = plt.subplot(222, projection = ccrs.PlateCarree())
    ax2.coastlines()
    ax2.set_extent([lon - 50, lon + 50, lat-50, 85], ccrs.PlateCarree())
    #V = np.arange(-15, 10, 5)
    cs=iplt.contourf(masked_cold)
    cbar = plt.colorbar(cs, orientation = 'horizontal')
    plt.text(lon, lat, 'x', fontsize=20)
    plt.text(lon+5.0, lat, SITE)
           
    plt.title('Annual cycle amplitude ~ ' + np.str(np.int(ANN_CYC_REQ)) + 'degC')
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/' + SITE.replace(' ','_') + '_same_seas_cyc.eps')

    plt.show()
    plt.close()
                                      

  
def main():
    """
    calling structure
    1. read in data
    2. get amplitude(warm month T - cold month T) and annual mean temperature 
    3. filter out land sea mask
    4. plot amplitude and annmeantemp
    """

    # get pliocene stuff
    (plio_amplitude_cube,
     plio_mean_cube,
     plio_warm_cube,
     plio_cold_cube)= get_max_seascyc('NearSurfaceTemperaturemean_plio')
    lsmfile = BCSTART + '/Plio_enh/Plio_enh/Plio_enh_LSM_v1.0.nc'
    plio_landamp_cube  = mask_ocean_for_cube(plio_amplitude_cube, lsmfile)
    plio_landmean_cube = mask_ocean_for_cube(plio_mean_cube, lsmfile)
   
    # get pi stuff
    (pi_amplitude_cube,
     pi_mean_cube,
     pi_warm_cube,
     pi_cold_cube)= get_max_seascyc('NearSurfaceTemperaturemean_pi')
    pi_precip_cube = iris.load_cube(PRECIPFILE, 'TotalPrecipitationmean_pi')
    lsmfile = BCSTART + '/Modern_std/Modern_std/Modern_std_LSM_v1.0.nc'
    pi_landamp_cube= mask_ocean_for_cube(pi_amplitude_cube, lsmfile)
    pi_landmean_cube = mask_ocean_for_cube(pi_mean_cube, lsmfile)
    pi_warm_cube = mask_ocean_for_cube(pi_warm_cube, lsmfile)
    pi_cold_cube = mask_ocean_for_cube(pi_cold_cube, lsmfile)
   

    #fig1 = plt.figure(figsize=[8.0, 4.0], constrained_layout=True)
   
    fig1 = plt.figure(figsize=[8.0, 4.0])
    gs = gridspec.GridSpec(nrows=2, ncols=2)

    ax1 = fig1.add_subplot(gs[0,0], projection=ccrs.PlateCarree())
    plotcube(pi_landmean_cube, 'PI', 'mean', np.arange(-20, 20, 5), ax1)
    ax2 = fig1.add_subplot(gs[0,1], projection=ccrs.PlateCarree())
    plotcube(pi_landamp_cube, 'PI','amplitude', np.arange(20, 50, 5), ax2)
    ax3 = fig1.add_subplot(gs[1,0], projection=ccrs.PlateCarree())
    plotcube(plio_landmean_cube, 'mPWP', 'mean', np.arange(-20, 20, 5), ax3)
    ax4 = fig1.add_subplot(gs[1,1], projection=ccrs.PlateCarree()) 
    plotcube(plio_landamp_cube, 'mPWP', 'amplitude', np.arange(20, 50, 5), ax4)
  
   
    
    plt.tight_layout()
    #plt.subplots_adjust(bottom=0.1, top=0.9, hspace=None)
    
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/map_seas_cyc.eps')
   
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/map_seas_cyc.png')
   
    plt.savefig(fileout)
    plt.close()
  


    # anomalies
    #plotcube(plio_landamp_cube - pi_landamp_cube, 'mPWP-PI','amplitude',
    #         np.arange(-5, 5, 1))
    #plotcube(plio_landmean_cube - pi_landmean_cube, 'mPWP-PI','mean',
    #         np.arange(-5, 5, 1))

    # plot all pi locations which have an annual cycle within 1 deg of 
    # ann_cyc_req

    # note that I think this is a bit misleading.
    #  all it shows are that these temperatures can exist in the preindustrial
    plot_locations_bothmatch(pi_warm_cube, pi_cold_cube)

    plot_locations2(pi_warm_cube, pi_cold_cube, pi_precip_cube,
                    WARM_TEMP_REQ, 'warm_match')
    plot_locations2(pi_cold_cube, pi_warm_cube, pi_precip_cube,
                    COLD_TEMP_REQ, 'cold_match')
    plot_locations(pi_landamp_cube, pi_warm_cube, pi_cold_cube)
      

##########################################################
# main program

LINUX_WIN = 'l'
EXPTNAME = 'EOI400'
PI_EXPT = 'E280'

FILENAME= ('/nfs/hera1/earjcti/regridded100/' + 
                    'NearSurfaceTemperature_multimodelmean_month.nc')
PRECIPFILE  = ('/nfs/hera1/earjcti/regridded100/' + 
                    'TotalPrecipitation_multimodelmean.nc')

BCSTART = '/nfs/hera1/earjcti/regridded/PlioMIP2_Boundary_conds/'

ANN_CYC = {'Lake Baikal' : 17.0, 'Lake Baikal M': 46.0,
           'Lost Chicken Mine' : 14.0, 'Lost Chicken Mine M' : 35.0,
           'Lost Chicken Mine B' : 39.0}
#WARM_TEMP = {'Lake Baikal' : 22.4, 'Lost Chicken Mine' : 15.4, 
#             'James Bay Lowland' : 22.6}
WARM_TEMP = {'Lake Baikal' : 16.4, 'Lake Baikal M' : 20.0, 
             'Lost Chicken Mine' : 12.0, 'Lost Chicken Mine M': 15.4,
             'Lost Chicken Mine B' : 15.0}
COLD_TEMP = {'Lake Baikal' : -0.3, 'Lake Baikal M' : -15.0,
             'Lost Chicken Mine' : -2.0, 'Lost Chicken Mine M': -20,
             'Lost Chicken Mine B' : -24.0}

SITE = 'Lake Baikal M'  #'James Bay Lowland' #'Lost Chicken Mine' #'Lake Baikal' # Lost Chicken Mine B (beetle) Lake Baikal M (model

ANN_CYC_REQ = ANN_CYC.get(SITE)
WARM_TEMP_REQ = WARM_TEMP.get(SITE)
COLD_TEMP_REQ = COLD_TEMP.get(SITE)
main()
::::::::::::::
map_sites.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#Created on December 2020
# 
#  This program will plot a map showing the amplitude of the seasonal cycle 
#  over Land for the pliocene and the preindustrial
#
#
#import os
import numpy as np
import pandas as pd
#import scipy as sp
#import cf
import iris
#import iris.util
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.gridspec as gridspec
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#import netCDF4
from mpl_toolkits.basemap import Basemap, shiftgrid
#from netCDF4 import Dataset, MFDataset
#import iris.analysis.cartography
#import iris.coord_categorisation
import iris.quickplot as qplt
import iris.plot as iplt
#import cf_units as unit
#from iris.experimental.equalise_cubes import equalise_attributes
import cartopy
import cartopy.crs as ccrs
#import matplotlib.ticker as mticker
#from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
#from mpl_toolkits.basemap import Basemap

import sys

 



    

  
def main():
    """
    plot map with all sites on.
    """

    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, 
    sitedata.append(['MI', 77.5, 261])
    sitedata.append(['BP', 79, 278])
    sitedata.append(['LE', 67, 172])
    sitedata.append(['LCM', 64, -142])
    sitedata.append(['Lake Baikal', 56, 108])
             

    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.coastlines()
    ax.set_global()
    for data in sitedata:
        plt.plot(data[2],data[1], color='red',marker='o', 
                    linewidth=2, transform = ccrs.Geodetic())
  
    
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/map_sites.eps')
   
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/map_sites.png')
   
    plt.savefig(fileout)
    plt.close()
  

##########################################################
# main program

main()
::::::::::::::
plot_biome4_output.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created February 2021 by Julia

This program will plot the biomes in a nice way

; tropical evergreen broadleaf forest                = 1
; tropical semi-evergreen broadleaf forest           = 2
; tropical deciduous broadleaf forest & woodland     = 3
; temperate deciduous broadleaf forest               = 4
; temperate evergreen needleleaf forest              = 5
; warm-temperate evergreen broadleaf & mixed forest  = 6
; cool mixed forest                                  = 7
; cool evergreen needleleaf forest                   = 8
; cool-temperate evergreen needleleaf & mixed forest = 9
; cold evergreen needleleaf forest                   = 10
; cold deciduous forest                              = 11
; tropical savanna                                   = 12
; tropical xerophytic shrubland                      = 13
; temperate xerophytic shrubland                     = 14
; temperate sclerophyll woodland and shrubland       = 15
; temperate deciduous broadleaf savanna              = 16
; temperate evergreen needleleaf open woodland       = 17
; cold parkland                                      = 18
; tropical grassland                                 = 19
; temperate grassland                                = 20
; desert                                             = 21
; graminoid and forb tundra                          = 22
; low and high shrub tundra                          = 23
; erect dwarf-shrub tundra                           = 24
; prostrate dwarf-shrub tundra                       = 25
; cushion-forb tundra                                = 26
; barren                                             = 27
; ice                                                = 28


"""
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import iris
import iris.plot as iplt
import iris.quickplot as qplt
import cartopy.crs as ccrs
import sys

def make_cmap(colors, position=None, bit=False):
    '''
    I didn't write this I found it on the web.
    make_cmap takes a list of tuples which contain RGB values. The RGB
    values may either be in 8-bit [0 to 255] (in which bit must be set to
    True when called) or arithmetic [0 to 1] (default). make_cmap returns
    a cmap with equally spaced colors.
    Arrange your tuples so that the first color is the lowest value for the
    colorbar and the last is the highest.
    position contains values from 0 to 1 to dictate the location of each color.
    '''
    bit_rgb = np.linspace(0,1,256)
    if position == None:
        position = np.linspace(0,1,len(colors))
    else:
        if len(position) != len(colors):
            sys.exit("position length must be the same as colors")
        elif position[0] != 0 or position[-1] != 1:
            sys.exit("position must start with 0 and end with 1")
    if bit:
        for i in range(len(colors)):
            colors[i] = (bit_rgb[colors[i][0]],
                         bit_rgb[colors[i][1]],
                         bit_rgb[colors[i][2]])
    cdict = {'red':[], 'green':[], 'blue':[]}
    for pos, color in zip(position, colors):
        cdict['red'].append((pos, color[0], color[0]))
        cdict['green'].append((pos, color[1], color[1]))
        cdict['blue'].append((pos, color[2], color[2]))

    cmap = mpl.colors.LinearSegmentedColormap('my_colormap',cdict,256)
    return cmap

def get_biome_details():
    """
    gets the biome names and colormap.  These are hard coded
    """
    
    names = ["Tropical evergreen forest",    
             "Tropical semi-deciduous forest",
             "Tropical decididous forest",
             "Temperate deciduous forest",
             "Temperate conifer forest",
             "warm mixed forest",
             "cool mixed forest",
             "cool conifer forest",  
             "cool-temperate mixed forest",
             "Evergreen taiga/montane forest",                  
             "Deciduous taiga/montane forest",                           
             "Tropical savanna",                            
             "Tropical xerophytic shrubland",                  
             "Temperate xerophytic shrubland",                   
             "Temperate sclerophyll woodland",     
             "Temperate broadleaf savanna",              
             "Open conifer woodland",     
             "Boreal parkland",                                  
             "Tropical grassland",                              
             "Temperate grassland",                              
             "Desert",                                           
             "Steppe tundra",                         
             "Shrub tundra",                         
             "Dwarf-shrub tundra",                          
             "Prostrate shrub tundra",                      
             "Cushion-forb tundra",                               
             "Barren",                                           
             "Land ice"] 

    colors = [ #( 1.000, 1.000, 1.000), 
            # ( 0.000, 0.000, 0.000 ),
             ( 0.110, 0.333, 0.063 ),
             ( 0.396, 0.573, 0.031 ),
             ( 0.682, 0.490, 0.125 ),
             ( 0.333, 0.922, 0.286 ),
             ( 0.094, 0.510, 0.443 ),
             ( 0.000, 0.000, 0.396 ),
             ( 0.792, 1.000, 0.792 ),
             ( 0.000, 0.604, 0.094 ),
             ( 0.443, 0.141, 0.208 ),
             ( 0.000, 0.125, 0.792 ),
             ( 0.396, 0.698, 1.000 ),
             ( 0.729, 1.000, 0.208 ),
             ( 1.000, 0.729, 0.604 ),
             ( 1.000, 0.875, 0.792 ),
             ( 0.557, 0.635, 0.157 ),
             ( 0.459, 1.000, 0.208 ),
             ( 1.000, 0.604, 0.875 ),
             ( 0.396, 0.490, 1.000 ),
             ( 1.000, 0.729, 0.208 ),
             ( 1.000, 0.875, 0.604 ),
             ( 0.969, 1.000, 0.792 ),
             ( 0.906, 0.906, 0.094 ),
             ( 0.396, 1.000, 0.604 ),
             ( 0.475, 0.525, 0.286 ),
             ( 0.824, 0.620, 0.588 ),
             ( 0.604, 0.396, 1.000 ),
             ( 0.729, 0.714, 0.667 ),
             ( 0.714, 0.824, 0.875 ) 
             # this last one was commented out
             #,( 0.700, 0.700, 0.700 )
             ]

    #cmap = mpl.colors.LinearSegmentedColormap.from_list(
    #    'Custom cmap', cmaplist, cmap.N)
    
   # cmap = mpl.colors.ListedColormap(['red',    'green',  'blue', 
   #                                   'cyan', 'red',   'green',  'blue', 
   #                                   'cyan',   'red',    'green',    'blue', 
   #                                   'cyan', 'red',  'green',  'blue', 
   #                                   'cyan',    'red',  'green', 'blue', 
   #                                   'cyan',   'red',  'green',  'blue', 
   #                                   'cyan',  'red',  'green',  'blue', 
   #                                   'cyan'    ])
    cmap = mpl.colors.ListedColormap(colors)
    bounds = np.linspace(0.5, 27.5, 28)
    print(bounds)
    #sys.exit(0)
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    return names, colors, cmap, norm, bounds

def get_data(colors):
    """
    reads in the data and puts it in a array (M, N, 3) with the
    third dimensio being the colors
    """
    cube = iris.load_cube(FILENAME, 'biome')
    cubedata = cube.data
    ny, nx = np.shape(cubedata)
    colordata = np.zeros((ny, nx, 3))

    print(np.shape(cubedata))
    print(np.shape(colordata))

    for index, point in np.ndenumerate(cubedata):
        if point >= 0:
            colordata[index[0], index[1], :] = colors[point-1]
        else:
            colordata[index[0], index[1], :] = (1, 1, 1)

    return cube, colordata
      
def plot_biomes(names, rgbdata, biomecube, cmap, norm, V,):
    """
    plots the biomes
    """
    fig = plt.figure(figsize=(11.0, 11.0))
    ax = plt.axes(projection = ccrs.PlateCarree())
    #ax.set_extent([-180, 180, -65, 90])
    ax.coastlines()

    # turn the iris Cube data structure into numpy arrays
    gridlons = biomecube.coord('longitude').contiguous_bounds()
    gridlats = biomecube.coord('latitude').contiguous_bounds()
    biomedata = biomecube.data

    print(gridlons)
    print(gridlats)
    print(np.shape(biomedata))
    cs = plt.pcolormesh(gridlons, gridlats, biomedata,
                   cmap=cmap, norm=norm)
    plt.title(MODELNAME + ': ' + ABS_ANOM)

    cbar = plt.colorbar(cs, ticks=V+0.5, )
    cbar.ax.set_yticklabels(names)
    cbar.ax.tick_params (labelsize=6)
    cbar.ax.invert_yaxis()
    #ax.imshow(rgbdata, transform=ccrs.PlateCarree())
    if MODELNAME == 'BIOME4':
        midfname = MODELNAME + '/'
    elif MODELNAME == 'BIOME4_NEWPARAMETERS':
        midfname = 'BIOME4/' + MODELNAME + '/'
    else:
        midfname =  MODELNAME + '/biome4/'
    fileout = (FILESTART + midfname + '_biome4out_' + ABS_ANOM + '.eps')
    print(fileout)
    plt.savefig(fileout)
    print(fileout)
    fileout = (FILESTART + midfname + '_biome4out_' + ABS_ANOM + '.png')
    plt.savefig(fileout)
    sys.exit(0)

def get_prism3_biomes():
    """
    get the biomes from prism3 as a cube
    """
    fname = ('/nfs/hera1/earjcti/PRISM/prism3_pliocene/exp2_alternate/' + 
             'biome_veg_v1.2.nc')
    cube = iris.load_cube(fname)

    # change zeros to nan
    cubedata = cube.data
    cubedata2 = np.where(cubedata != 0, cubedata, np.nan)
    cube_prism3 = cube.copy(data = cubedata2)
   
    fname = ('/nfs/hera1/earjcti/PRISM/prism3_pliocene/BAS_Observ_BIOME.nc')
    cube = iris.load_cube(fname)

    # change zeros to nan
    cubedata = cube.data
    cubedata2 = np.where(cubedata != 0, cubedata, np.nan)
    cube_pi = cube.copy(data = cubedata2)
    

    return cube_prism3, cube_pi

def plot_biomes_with_obs(names, rgbdata, modelcube, datacube, cmap, norm, V,
                         model_ind):
    """
    plots the biomes and the observations on the same figure
    """
    fig,ax = plt.subplots(ncols=1,nrows=2,figsize=(11,8),
                      subplot_kw={'projection': ccrs.PlateCarree()})
    ax1 = ax[0]
    ax2 = ax[1]

    ax1.set_extent([-180, 180, -65, 90])
    ax1.coastlines()

    # do observations
    # turn the iris cube data structure into numpy arrays
    gridlons_d = datacube.coord('longitude').contiguous_bounds()
    gridlats_d = datacube.coord('latitude').contiguous_bounds()
    data = datacube.data

    cs = ax1.pcolormesh(gridlons_d, gridlats_d, data,
                   cmap=cmap, norm=norm)
    if model_ind == 'y':
        ax1.title.set_text('reconstructed biomes for mPWP')
    else:
        ax1.title.set_text('biomes for preindustrial')
 

    # do biome cube
    ax2.set_extent([-180, 180, -65, 90])
    ax2.coastlines()

    # turn the iris Cube data structure into numpy arrays
    gridlons = modelcube.coord('longitude').contiguous_bounds()
    gridlats = modelcube.coord('latitude').contiguous_bounds()
    modeldata = modelcube.data

    cs = ax2.pcolormesh(gridlons, gridlats, modeldata,
                   cmap=cmap, norm=norm)
    if model_ind == 'y':
        if MODELNAME == 'BIOME4':
            ax2.title.set_text('simulated biomes from PlioMIP2 multimodel mean')
        else:
            ax2.title.set_text(MODELNAME + ': ' + ABS_ANOM)
    else:
        ax2.title.set_text('reconstructed biomes for mPWP')


    # adjust plots so we have room for colorbar
    fig.subplots_adjust(bottom=0.05, top = 0.95, left = 0.05, right = 0.70)

    # do colorbar
    cbar_ax = fig.add_axes([0.75, 0.05, 0.05, 0.9])
    cbar = fig.colorbar(cs, cax= cbar_ax, ticks=V+0.5, )
    cbar.ax.set_yticklabels(names)
    cbar.ax.tick_params (labelsize=9)
    cbar.ax.invert_yaxis()
 
    if model_ind == 'y':
        if MODELNAME == 'BIOME4':
            midfname = MODELNAME + '/'
        else:
            midfname =  MODELNAME + '/biome4/'
        fileout = (FILESTART + midfname + '_biome4out_' + ABS_ANOM + '_data.eps')
        plt.savefig(fileout)
        print(fileout)
        fileout = (FILESTART + midfname + '_biome4out_' + ABS_ANOM + '_data.png')
        plt.savefig(fileout)
    else:
        fileout = (FILESTART +  'BIOME4/' + 'pi_vs_plio_obs.eps')
        plt.savefig(fileout)
        print(fileout)
        fileout = (FILESTART +  'BIOME4/' + 'pi_vs_plio_obs.png')
        plt.savefig(fileout)

def get_temp_ranges(biome_prism3_cube, plio_mmmT_cube, i):
        """
        get's the minimum and maximum temperature in this cube for Jan/Apr/Jul/Oct
        """

        biome_mean_temps = np.ma.masked_where(np.repeat(biome_prism3_cube.data[np.newaxis,: :],12, axis=0) != i, plio_mmmT_cube.data)
        biome_mean_temp_cube = plio_mmmT_cube.copy(data=biome_mean_temps)
        biome_NHtemp_cube = biome_mean_temp_cube.extract(iris.Constraint(latitude = lambda cell: cell >= 0))

        plio_temp = []
           
        # min and maximum temperatures are
        month1= biome_NHtemp_cube.extract(iris.Constraint(time=1))
        plio_temp.append([np.float(month1.collapsed(['latitude','longitude'], iris.analysis.MEAN).data), np.float(month1.collapsed(['latitude','longitude'], iris.analysis.MAX).data)])
            
        month4 = biome_NHtemp_cube.extract(iris.Constraint(time=4))
        plio_temp.append([np.float(month4.collapsed(['latitude','longitude'], iris.analysis.MEAN).data), np.float(month4.collapsed(['latitude','longitude'], iris.analysis.MAX).data)])

        month7= biome_NHtemp_cube.extract(iris.Constraint(time=7))
        plio_temp.append([np.float(month7.collapsed(['latitude','longitude'], iris.analysis.MEAN).data), np.float(month7.collapsed(['latitude','longitude'], iris.analysis.MAX).data)])
            
        month10 = biome_NHtemp_cube.extract(iris.Constraint(time=10))
        plio_temp.append([np.float(month10.collapsed(['latitude','longitude'], iris.analysis.MEAN).data), np.float(month10.collapsed(['latitude','longitude'], iris.analysis.MAX).data)])

        return np.asarray(plio_temp)
           
def check_seasonal_for_each_biome(biome_pi_cube_lowres, biome_prism3_cube_lowres,
                                  biome_names):
    """
    1. for pliocene find out which biomes are present polewards of 50N
    2. for each of these biomes find the temperature of these biomes in the
       NH for the Pliocene and the PI throughout the annual cycle
    3. Extract Jan/Apr/July/Oct temperature
    4.
    """
  
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
      
    biome_pi_cube = biome_pi_cube_lowres.regrid(cubegrid,iris.analysis.Nearest())
    biome_prism3_cube = biome_prism3_cube_lowres.regrid(cubegrid,iris.analysis.Nearest())

   
    # 1. find out which biomes are present in pliocene polewards of 50N
    present=np.zeros(28,dtype='bool')
    biome_data = biome_prism3_cube.data
    for j,lat in enumerate(biome_prism3_cube.coord('latitude').points):
        if lat >= 50.0:
            for i, lon in enumerate(biome_prism3_cube.coord('latitude').points):
                if np.isfinite(biome_data[j,i]):
                    print(biome_data[j,i])
                    present[np.int(biome_data[j,i])] = True

    # find mean temperature of each biome
    plio_mmmT_cube = iris.load_cube('/nfs/hera1/earjcti/regridded/NearSurfaceTemperature_multimodelmean_month.nc','NearSurfaceTemperaturemean_plio') # load cube
    pi_mmmT_cube = iris.load_cube('/nfs/hera1/earjcti/regridded/NearSurfaceTemperature_multimodelmean_month.nc','NearSurfaceTemperaturemean_pi') # load cube

    allnames = []
    plio_all_range = []
    pi_all_range = []

    # get the ranges of each temperature for months Jan/Apr/July/Oct 
    # where biomes exist
    for i, reqd in enumerate(present):
        if reqd:
           
            allnames.append(biome_names[i-1])
            plio_temps_range = get_temp_ranges(biome_prism3_cube, plio_mmmT_cube, i)
            pi_temps_range = get_temp_ranges(biome_pi_cube, pi_mmmT_cube,  i)

            # note this is a list of arrays
            # each biome corresponding to names, within this each 'month', within this min and max temp
            plio_all_range.append(plio_temps_range)
            pi_all_range.append(pi_temps_range)
            
 
    plio_range = np.asarray(plio_all_range)
    pi_range = np.asarray(pi_all_range)
 

    # plot
    
    fig1 = plt.figure(figsize=[16.0, 20.0])
  

    nbiomes =  len(allnames)
    yarray = np.arange(0,nbiomes,1)
    print(np.shape(plio_range))
#    plt.hlines(y=yarray[0:8], xmin=plio_range[0:8,0,0], xmax=plio_range[0:8,0,1], color='tab:blue', label='January Plio')
#    plt.hlines(y=yarray[0:8]+0.2, xmin=plio_range[0:8,1,0], xmax=plio_range[0:8,1,1], color='tab:green', label='April Plio')
#    plt.hlines(y=yarray[0:8]+0.4, xmin=plio_range[0:8,2,0], xmax=plio_range[0:8,2,1], color='tab:red', label='July Plio')
   
#    plt.hlines(y=yarray[0:8]+0.1, xmin=pi_range[0:8,0,0], xmax=pi_range[0:8,0,1], color='tab:blue', label='January Pi', linestyle='dashed')
#    plt.hlines(y=yarray[0:8]+0.3, xmin=pi_range[0:8,1,0], xmax=pi_range[0:8,1,1], color='tab:green', label='April Pi', linestyle='dashed')
#    plt.hlines(y=yarray[0:8]+0.5, xmin=pi_range[0:8,2,0], xmax=pi_range[0:8,2,1], color='tab:red', label='July Pi', linestyle='dashed')
 
    plt.scatter(plio_range[0:8, 0, 0],yarray[0:8], color='tab:blue', label='January Plio')
    plt.errorbar(plio_range[0:8, 0, 0],yarray[0:8],xerr = plio_range[0:8, 0, 1], color='tab:blue')
    plt.scatter(plio_range[0:8, 1, 0],yarray[0:8], color='tab:green', label='apr Plio')
    plt.scatter(plio_range[0:8, 2, 0],yarray[0:8], color='tab:red', label='Jul Plio')
    plt.scatter(pi_range[0:8, 0, 0],yarray[0:8], color='tab:blue', marker='^',label='Jan Pi')
    plt.scatter(pi_range[0:8, 1, 0],yarray[0:8], color='tab:green', marker='^', label='apr Pi')
    plt.scatter(pi_range[0:8, 2, 0],yarray[0:8], color='tab:red', marker='^',label='jul pi')
  
    for j in range(0, 8):  # just do first 8 biomes, only interested in forest tyeps
        plt.text(-40, yarray[j], allnames[j])
    plt.legend()
    plt.show()

    
            
           
        
    
    

def main():
    """
    driver to get biomes
    """

    print('j1')
    biome_names, colors, cmap, norm, bounds= get_biome_details()
    print('j2')

    cube_model, rgbdata = get_data(colors)
    print('j3')
 
    plot_biomes(biome_names, rgbdata, cube_model, cmap, norm, bounds)
    #print('j4')

    biome_prism3_cube, biome4_pi_cube = get_prism3_biomes()
    plot_biomes_with_obs(biome_names, rgbdata, cube_model, biome_prism3_cube, cmap, norm, bounds,'y')
    #print('j5')
    plot_biomes_with_obs(biome_names, rgbdata, biome_prism3_cube, biome4_pi_cube, cmap, norm, bounds,'n')

    print('j6')
    # look at each biome in turn and find out the Jan / Apr / July/ Oct 
    # temperatures for the PI and the Pliocene
    check_seasonal_for_each_biome(biome4_pi_cube, biome_prism3_cube,
                                  biome_names)

    print('prog finished')
    
 

FILESTART = '/nfs/hera1/earjcti/regridded/'
MODELNAME = 'IPSLCM6A_origgrid' # BIOME4 -  MMM
#MODELNAME = 'xozzb'
ABS_ANOM = 'Anom'
#FILESTART = '/nfs/see-fs-02_users/earjcti/BIOME4/biome4_pliomip2/'
#MODELNAME = ''
#ABS_ANOM = ''
if MODELNAME == 'BIOME4':
    midfname = MODELNAME
elif MODELNAME == 'BIOME4_NEWPARAMETERS':
    midfname = 'BIOME4/BIOME4_NEWPARAMETERS/'
else:
    midfname =  MODELNAME + '/biome4/' 
   
if ABS_ANOM == 'Anom':
    FILENAME = FILESTART + midfname + '/biome4out_anomaly.nc'
if ABS_ANOM == 'Abs':
    FILENAME = FILESTART + midfname + '/biome4out_absolute.nc'
if ABS_ANOM == '':
    FILENAME = FILESTART + midfname + 'biome4out.nc'

main()
::::::::::::::
plot_biome_dmc_by_site.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created February 2021 by Julia

This program will do a DMC of biomes by site at high latitudes.

(I am currently thinking polar stereographic plot, I am also thinking to plot data on one figure and another figure showing only those sites where the model is different).  

; tropical evergreen broadleaf forest                = 1
; tropical semi-evergreen broadleaf forest           = 2
; tropical deciduous broadleaf forest & woodland     = 3
; temperate deciduous broadleaf forest               = 4
; temperate evergreen needleleaf forest              = 5
; warm-temperate evergreen broadleaf & mixed forest  = 6
; cool mixed forest                                  = 7
; cool evergreen needleleaf forest                   = 8
; cool-temperate evergreen needleleaf & mixed forest = 9
; cold evergreen needleleaf forest                   = 10
; cold deciduous forest                              = 11
; tropical savanna                                   = 12
; tropical xerophytic shrubland                      = 13
; temperate xerophytic shrubland                     = 14
; temperate sclerophyll woodland and shrubland       = 15
; temperate deciduous broadleaf savanna              = 16
; temperate evergreen needleleaf open woodland       = 17
; cold parkland                                      = 18
; tropical grassland                                 = 19
; temperate grassland                                = 20
; desert                                             = 21
; graminoid and forb tundra                          = 22
; low and high shrub tundra                          = 23
; erect dwarf-shrub tundra                           = 24
; prostrate dwarf-shrub tundra                       = 25
; cushion-forb tundra                                = 26
; barren                                             = 27
; ice                                                = 28


"""
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
from matplotlib.markers import MarkerStyle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import iris
import iris.plot as iplt
import cartopy.crs as ccrs
import matplotlib.path as mpath
import sys
import math

def make_cmap(colors, position=None, bit=False):
    '''
    I didn't write this I found it on the web.
    make_cmap takes a list of tuples which contain RGB values. The RGB
    values may either be in 8-bit [0 to 255] (in which bit must be set to
    True when called) or arithmetic [0 to 1] (default). make_cmap returns
    a cmap with equally spaced colors.
    Arrange your tuples so that the first color is the lowest value for the
    colorbar and the last is the highest.
    position contains values from 0 to 1 to dictate the location of each color.
    '''
    bit_rgb = np.linspace(0,1,256)
    if position == None:
        position = np.linspace(0,1,len(colors))
    else:
        if len(position) != len(colors):
            sys.exit("position length must be the same as colors")
        elif position[0] != 0 or position[-1] != 1:
            sys.exit("position must start with 0 and end with 1")
    if bit:
        for i in range(len(colors)):
            colors[i] = (bit_rgb[colors[i][0]],
                         bit_rgb[colors[i][1]],
                         bit_rgb[colors[i][2]])
    cdict = {'red':[], 'green':[], 'blue':[]}
    for pos, color in zip(position, colors):
        cdict['red'].append((pos, color[0], color[0]))
        cdict['green'].append((pos, color[1], color[1]))
        cdict['blue'].append((pos, color[2], color[2]))

    cmap = mpl.colors.LinearSegmentedColormap('my_colormap',cdict,256)
    return cmap

def get_biome_details():
    """
    gets the biome names and colormap.  These are hard coded
    """
    
    names = ["Tropical evergreen forest",    
             "Tropical semi-deciduous forest",
             "Tropical decididous forest",
             "Temperate deciduous forest",
             "Temperate conifer forest",
             "warm mixed forest",
             "cool mixed forest",
             "cool conifer forest",  
             "cool-temperate mixed forest",
             "Evergreen taiga/montane forest",                  
             "Deciduous taiga/montane forest",                           
             "Tropical savanna",                            
             "Tropical xerophytic shrubland",                  
             "Temperate xerophytic shrubland",                   
             "Temperate sclerophyll woodland",     
             "Temperate broadleaf savanna",              
             "Open conifer woodland",     
             "Boreal parkland",                                  
             "Tropical grassland",                              
             "Temperate grassland",                              
             "Desert",                                           
             "Steppe tundra",                         
             "Shrub tundra",                         
             "Dwarf-shrub tundra",                          
             "Prostrate shrub tundra",                      
             "Cushion-forb tundra",                               
             "Barren",                                           
             "Land ice"] 

    names_needed = [
             "Temperate deciduous forest",
             "Temperate conifer forest",
             "warm mixed forest",
             "cool mixed forest",
             "cool conifer forest",  
             "cool-temperate mixed forest",
             "Evergreen taiga/montane forest",                  
             "Deciduous taiga/montane forest",                           
             "Tropical savanna",                            
             "Tropical xerophytic shrubland",                  
             "Temperate xerophytic shrubland",                   
             "Temperate sclerophyll woodland",     
             "Temperate broadleaf savanna",              
             "Open conifer woodland",     
             "Boreal parkland",                                  
             "Tropical grassland",                              
             "Temperate grassland",                              
             "Desert",                                           
             "Steppe tundra",                         
             "Shrub tundra",                         
             "Dwarf-shrub tundra",                          
             "Prostrate shrub tundra",                      
             "Cushion-forb tundra",                               
             "Barren",                                           
             "Land ice"]

    colors = [ #( 1.000, 1.000, 1.000), 
            # ( 0.000, 0.000, 0.000 ),
             ( 0.110, 0.333, 0.063 ),
             ( 0.396, 0.573, 0.031 ),
             ( 0.682, 0.490, 0.125 ),
             ( 0.333, 0.922, 0.286 ),
             ( 0.094, 0.510, 0.443 ),
             ( 0.000, 0.000, 0.396 ),
             ( 0.792, 1.000, 0.792 ),
             ( 0.000, 0.604, 0.094 ),
             ( 0.443, 0.141, 0.208 ),
             ( 0.000, 0.125, 0.792 ),
             ( 0.396, 0.698, 1.000 ),
             ( 0.729, 1.000, 0.208 ),
             ( 1.000, 0.729, 0.604 ),
             ( 1.000, 0.875, 0.792 ),
             ( 0.557, 0.635, 0.157 ),
             ( 0.459, 1.000, 0.208 ),
             ( 1.000, 0.604, 0.875 ),
             ( 0.396, 0.490, 1.000 ),
             ( 1.000, 0.729, 0.208 ),
             ( 1.000, 0.875, 0.604 ),
             ( 0.969, 1.000, 0.792 ),
             ( 0.906, 0.906, 0.094 ),
             ( 0.396, 1.000, 0.604 ),
             ( 0.475, 0.525, 0.286 ),
             ( 0.824, 0.620, 0.588 ),
             ( 0.604, 0.396, 1.000 ),
             ( 0.729, 0.714, 0.667 ),
             ( 0.714, 0.824, 0.875 ), 
             #( 0.700, 0.700, 0.700 )
             ]

    #cmap = mpl.colors.LinearSegmentedColormap.from_list(
    #    'Custom cmap', cmaplist, cmap.N)
    
   # cmap = mpl.colors.ListedColormap(['red',    'green',  'blue', 
   #                                   'cyan', 'red',   'green',  'blue', 
   #                                   'cyan',   'red',    'green',    'blue', 
   #                                   'cyan', 'red',  'green',  'blue', 
   #                                   'cyan',    'red',  'green', 'blue', 
   #                                   'cyan',   'red',  'green',  'blue', 
   #                                   'cyan',  'red',  'green',  'blue', 
   #                                   'cyan'    ])
    cmap = mpl.colors.ListedColormap(colors)
    bounds = np.linspace(0.5, 28.5, 29)
   
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    return names, colors, cmap, norm, bounds

def get_site_data():
    """
    This will get the site data from ulrichs spreadsheet
    """

    filein = '/nfs/hera1/earjcti/PLIOMIP2/proxydata/tab_GIS_all_Pliocene_Final.xlsx'
    dataframe = pd.read_excel(filein)
    lats_full = dataframe.loc[:, 'latitude'].to_numpy()
    lons_full = dataframe.loc[:, 'longitude'].to_numpy()
    biome_full = dataframe.loc[:, 'Raster_ID'].to_numpy()
   
    lat = []
    lon = []
    biome = []
    for i, latreq in enumerate(lats_full):
        if latreq > LAT_LIMIT:
            lat.append(latreq)
            lon.append(lons_full[i])
            biome.append(biome_full[i])

    return np.asarray(lat), np.asarray(lon), np.asarray(biome)

def get_MMM_output(latreq, lonreq, biomedata):
    """
    reads in the data and puts it in a array (M, N, 3) with the
    third dimensio being the colors
    """
    cube = iris.load_cube(FILENAME, 'biome')
    cube_lats = cube.coord('latitude').points
    cube_lons = cube.coord('longitude').points
    model_data = []
    model_diff = []

    for i, lat in enumerate(latreq):
        lon = lonreq[i]
        if lon < 0.:
            lon = lon + 360.

        latix = np.abs(cube_lats - lat).argmin()
        lonix = np.abs(cube_lons - lon).argmin()

       # print(i, lat)
        if lat >  LAT_LIMIT and math.isfinite(cube.data[latix,lonix]):
            model_data.append([latreq[i], lonreq[i], cube.data[latix,lonix], 
                                 biomedata[i]])

            if cube.data[latix,lonix] != biomedata[i]:
                model_diff.append([latreq[i], lonreq[i],cube.data[latix,lonix], 
                                   biomedata[i]])
                print('diff',latreq[i],lonreq[i],cube.data[latix,lonix],biomedata[i])

    print('model diff',np.shape(np.asarray(model_diff)),
              ' model data', np.shape(np.asarray(model_data)))
    sys.exit(0)
  
    return cube, np.asarray(model_data), np.asarray(model_diff)
      
def plot_data(mycmap, names, model_results, model_diff,
              model_cube):
    """
    plots the biomes
    model_results is lat, lon, model_data, biome_data
    """
    # set polar stereographic axis
    fig = plt.figure(figsize=(11.0, 11.0))
    ax1 = fig.add_subplot(2,2,1, projection = ccrs.NorthPolarStereo())
    ax1.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax1.coastlines()
    ax1.gridlines()

    # Compute a circle in axes coordinates, which we can use as a boundary
    # for the map. We can pan/zoom as much as we like - the boundary will be
    # permanently circular.
    theta = np.linspace(0, 2*np.pi, 100)
    center, radius = [0.5, 0.5], 0.5
    verts = np.vstack([np.sin(theta), np.cos(theta)]).T
    circle = mpath.Path(verts * radius + center)

    ax1.set_boundary(circle, transform=ax1.transAxes)
    
   
    # plot the data (confusingly this is stored in model_results[:,3}
    V = np.arange(1,29,1)
    print(V)
    norm = colors.BoundaryNorm(boundaries=V, ncolors=mycmap.N)
  
    cs = plt.scatter(model_results[:,1], model_results[:,0], 
                     c=model_results[:,3],  marker='o', s=100,
                     norm = norm , cmap=mycmap, edgecolors='black',
                     transform=ccrs.Geodetic())

    plt.title('a) Biome reconstruction')

    # plot the model results
    ax2 = fig.add_subplot(2,2,3, projection = ccrs.NorthPolarStereo())
    ax2.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax2.coastlines()
    ax2.gridlines()
    ax2.set_boundary(circle, transform=ax2.transAxes)
    cs = plt.scatter(model_results[:,1], model_results[:,0], 
                     c=model_results[:,2],  marker='o', s=100,
                     norm = norm , edgecolors='black',cmap=mycmap, 
                     transform=ccrs.Geodetic())

    plt.title('c) Modelled Biome at sites')

    # plot all of the modelled biomes
    ax3 = fig.add_subplot(2,2,2, projection = ccrs.NorthPolarStereo())
    ax3.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax3.coastlines()
    ax3.gridlines()
    ax3.set_boundary(circle, transform=ax3.transAxes)
    # turn the iris Cube data structure into numpy arrays
    gridlons = model_cube.coord('longitude').contiguous_bounds()
    gridlats = model_cube.coord('latitude').contiguous_bounds()
    modeldata = model_cube.data
    print(modeldata)

    cs = plt.pcolormesh(gridlons, gridlats, modeldata,
                   cmap=mycmap, norm=norm, 
                     transform=ccrs.PlateCarree())
    plt.title('b) Modelled biomes')



    # plot the modelled biome where it is different from data
    #model diff is[lat, lon, model_data[i], biome_data[i]]

    ax4 = fig.add_subplot(2,2,4, projection = ccrs.NorthPolarStereo())
    ax4.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax4.coastlines()
    ax4.gridlines()
    ax4.set_boundary(circle, transform=ax4.transAxes)
    cs = plt.scatter(model_diff[:,1], model_diff[:,0], c=model_diff[:,2], 
                     marker=MarkerStyle('o', fillstyle='left'),
                     edgecolors='black',
                     s=150, 
                     norm = norm , cmap=mycmap, transform=ccrs.Geodetic())
    cs = plt.scatter(model_diff[:,1], model_diff[:,0], c=model_diff[:,3], 
                     marker=MarkerStyle('o', fillstyle='right'),
                     edgecolors='black',
                     s=150, 
                     norm = norm , cmap=mycmap, transform=ccrs.Geodetic())

    plt.title('d) Model-data mismatch at sites')



    # adjust plots so we have room for colorbar
    fig.subplots_adjust(bottom=0.05, top = 0.95, left = 0.05, right = 0.70)

    # do colorbar
    cbar_ax = fig.add_axes([0.75, 0.05, 0.05, 0.9])
    cbar = fig.colorbar(cs, cax= cbar_ax, ticks=V+0.5, )
    cbar.ax.set_yticklabels(names)
    cbar.ax.tick_params (labelsize=9)
    cbar.ax.invert_yaxis()
   
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.eps')
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.png')
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.pdf')
    plt.close()

def main():
    """
    driver to get biomes
    """

    print('j1')
    biome_names, colors, cmap, norm, bounds= get_biome_details()
    print('j2')

    lats_data, lons_data, biomes_data = get_site_data()
    
    (model_cube, biomes_model, 
    biomes_diff) = get_MMM_output(lats_data, lons_data, biomes_data)

    # plot data and model results
    plot_data(cmap, biome_names, 
              biomes_model, biomes_diff, model_cube)
   

    print('prog finished')
    
 

FILESTART = '/nfs/hera1/earjcti/regridded/'
MODELNAME = 'BIOME4' # this will be MMM
ABS_ANOM = 'Anom'
LAT_LIMIT = 55  # only deal with stuff polewards of 55N
#FILESTART = '/nfs/see-fs-02_users/earjcti/BIOME4/biome4_pliomip2/'
#MODELNAME = ''
#ABS_ANOM = ''
if MODELNAME == 'BIOME4':
    midfname = MODELNAME
else:
    midfname =  MODELNAME + '/biome4/' 
   
if ABS_ANOM == 'Anom':
    FILENAME = FILESTART + midfname + '/biome4out_anomaly.nc'
if ABS_ANOM == 'Abs':
    FILENAME = FILESTART + midfname + '/biome4out_absolute.nc'
if ABS_ANOM == '':
    FILENAME = FILESTART + midfname + 'biome4out.nc'

main()
::::::::::::::
plot_toa_insolation_by_lat_and_month.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created Sept 2021 by Julia

This program will plot the TOA insolation for the modern.

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import matplotlib.ticker as ticker
import netCDF4

import sys

FILESTART = '/nfs/hera1/earjcti/um/tenvo/pd/tenvoa@pdt39'
MONTHS = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
FIELD = 'INCOMING SW RAD FLUX (TOA): ALL TSS'
NMONTHS = len(MONTHS)

for i, month in enumerate(MONTHS):
    cube = iris.load_cube(FILESTART + month + '.nc', 
                          'INCOMING SW RAD FLUX (TOA): ALL TSS')
    cube_lat_globe = iris.util.squeeze(cube.collapsed('longitude', iris.analysis.MEAN))
    cube_lat_mean = cube_lat_globe[0:15, :]
    cube_insol_55N = cube_lat_globe.extract(iris.Constraint(latitude=55.0))
    lats = cube_lat_mean.coord('latitude').points
    nlats = len(lats)
    if i == 0:
        toa_incom = np.zeros((nlats, NMONTHS))
        toa_55 = np.zeros(NMONTHS)

    toa_incom[:,i] = cube_lat_mean.data
    toa_55[i] = cube_insol_55N.data
   

# fraction of maximum insolation that occurs in that month
toa_frac = np.zeros((nlats, NMONTHS))  
monthly_mean = np.mean(toa_incom,axis=0)
for j, lat in enumerate(lats):
    toa_frac[j, :] = toa_incom[j, :] / np.sum(toa_incom[j, :])
for i, month in enumerate(MONTHS):
   # toa_frac[:, i] = toa_incom[:, i] / monthly_mean[i]
    toa_frac[:, i] = toa_incom[:, i] / toa_55[i]


print('np.mean axis 0',np.mean(toa_incom,axis=0))
print('np.mean axis 1',np.mean(toa_incom,axis=1))
print(toa_incom[:,0])

# plot
ax = plt.subplot(111)
V = np.arange(0,2.2,0.2)
#im = plt.pcolormesh(MONTHS, lats+1.25, toa_frac, vmin=0, vmax=2 ,cmap='RdYlBu_r')
im = plt.imshow(toa_frac, vmin=0, vmax=1.2, cmap='PuBuGn',aspect='auto')
cbar = plt.colorbar(im,orientation='horizontal')
plt.title('Fraction of 55N insolation occuring at each latitude')
plt.ylabel('latitude')
plt.xlabel('month')
ax.set_xticks(np.arange(0,12,1))
ax.set_xticklabels(MONTHS)
ax.set_yticks(np.arange(0,16,2))
ax.set_yticklabels(['90N','85N','80N','75N','70N','65N','60N','55N'])
#plt.xticks(MONTHS)
#ax.xaxis.set_major_locator(ticker.IndexLocator(base=1.0,offset=0.5))
#ax.yaxis.set_major_locator(ticker.IndexLocator(base=5.0,offset=1.25))
#plt.yticks(lats[:-1]+0.5)
plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/NH_insolation.eps')
plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/NH_insolation.png')
plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/NH_insolation.pdf')
plt.close()
::::::::::::::
seasonal_dmc_alternative_sites.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm



###########################
def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3

def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
   
    return plio_minval_array, plio_maxval_array

 
def get_land_obs():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT CA, max WMMT CA,
    # min CMMT CA, max CMMT CA

    # LP is late pliocene, EP is early pliocene
    # these are late pliocene
    # these are from popova et al 2012 using coexistence approach.
    sitedata.append(['Mirny (LP)', 55, 82, 18.8, 24.6, -0.3, 0.7])
    sitedata.append(['Merkutlinskiy (LP)', 56, 72, 17.3, 23.8, -3.8, 6.2])
    sitedata.append(['Kabinet (LP)', 55, 80, 21.6, 24.4, -4.4, 4.6])
    sitedata.append(['Delyankir (LP)', 63, 133, 18.9, 24.9, -6.9, 1.3])
    sitedata.append(['Chernoluche (LP)', 55, 73, 19.6, 20.3, -5.9, 0.7])
    sitedata.append(['Blizkiy (LP)', 64, 162, 15.6, 23.3, -12.8, 5.2])
    sitedata.append(['42km (LP)', 55, 80, 21.6, 23.3, -4.4, 0.7])
    sitedata.append(['Tnekveem (EP)', 66, 177, 18.9, 25.6, -11.8, 5.8])
    sitedata.append(['Hydzhak (EP)', 63, 147, 18.8, 24.9, -8.7, 1.3])

    # lake baikal is from demske 2002.
    sitedata.append(['Lake Baikal (3.57-3.15Ma)', 56, 108, 13.0, 24.0, -15, 5])
    
   

   
    sites = []
    lats = []
    lons = []
    WMMT_veg_min = []
    WMMT_veg_max = []
    CMMT_veg_min = []
    CMMT_veg_max = []
    
    for site in sitedata:
        sites.append(site[0])
        lats.append(site[1])
        lons.append(site[2])
        WMMT_veg_min.append(site[3])
        WMMT_veg_max.append(site[4])
        CMMT_veg_min.append(site[5])
        CMMT_veg_max.append(site[6])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_veg_min),
             np.asarray(WMMT_veg_max), np.asarray(CMMT_veg_min),
             np.asarray(CMMT_veg_max))


def plot_figure(WMMT_veg_min, WMMT_veg_max, CMMT_veg_min, CMMT_veg_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                labels):

    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    fig1 = plt.figure(figsize=[10.0, 10])
    ax1 = plt.axes(frameon=False)
    ax1.get_xaxis().tick_top()
    ax1.axes.get_yaxis().set_visible(False)

    nsites=len(WMMT_veg_min)
    yarray = np.arange(1, nsites+1, 1)
 
    # plot warm and cold month temperature
    ax1.hlines(y=yarray, xmin=WMMT_veg_min, xmax= WMMT_veg_max,color='red')
    ax1.hlines(y=yarray, xmin=CMMT_veg_min, xmax= CMMT_veg_max,color='blue')
    plt.scatter((WMMT_veg_max + WMMT_veg_min) / 2.0, 
                yarray, color='red', marker='^',
                label='CA WMMT')
    plt.scatter((CMMT_veg_max + CMMT_veg_min) / 2.0, 
                 yarray, color='blue', marker='^',
                label =  'CA CMMT')
  
       
    # try plotting axis
  
    for j in range(0, nsites):
        plt.text(-35.0, yarray[j], labels[j], ha='right')

     

    
    plt.scatter(mmm_WMT, yarray + 0.2, color='black', s=50)
    plt.scatter(mmm_WMT, yarray + 0.2, color='red', 
                s=25, label='MMM WMMT')
    plt.scatter(mmm_CMT, yarray + 0.2, color='black', s=50)
    plt.scatter(mmm_CMT, yarray + 0.2, color='blue', 
                s=25, label='MMM CMMT')
  
    plt.ylim(12, -0.5)

    # plot individual models for pliocene
    for i in range(0, len(MODELNAMES)):
        if i == 0:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='red', 
                        marker = 'x', s=10, label='models WMMT')
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='blue', 
                        marker = 'x', s=10, label='models CMMT')
        else:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='red', 
                        marker = 'x',s=10)
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='blue', 
                        marker = 'x', s=10)
        
    
    
    plt.legend(loc='lower center', ncol=3)

    fig1.suptitle('a) Pliocene DMC', x=0.1, ha='left', fontsize=16)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_alternative_sites.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_alternative_sites.png')
    plt.savefig(fileout)
    plt.close()



   

  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    d) plots change in seasonal cycle at MI, BP and LB
    """

   
    # get land observations and cru temperature at land points 
    (sites, land_lats, land_lons, WMMT_veg_min, WMMT_veg_max, 
     CMMT_veg_min, CMMT_veg_max) =  get_land_obs()
    
    
    
    # get ind models data
    print(land_lons)
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_seas_cyc_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT

        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT

        all_models_seas_cyc_anom[:, i] = (
            (all_models_plio_WMT[:, i] - all_models_plio_CMT[:, i]) -
            (all_models_pi_WMT[:, i] - all_models_pi_CMT[:, i]))
        
        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])



    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)



    # plot data
  
    plot_figure(WMMT_veg_min, WMMT_veg_max, 
                CMMT_veg_min, CMMT_veg_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites)
##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
             ,  'MRI2.3'
              ]

#MODELNAMES = ['CESM2']

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
seasonal_dmc_plot.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm


def get_cru_temp(lats, lons):
    """
    get's the cru temperature at the given latitude and longitude
    """
    
    crufile = ('/nfs/hera1/earjcti/regridded/CRUTEMP/' + 
               'E280.NearSurfaceTemperature.mean_month.nc')
    cube = iris.load_cube(crufile)
    
    
    cru_min_temp = np.zeros(len(lats))
    cru_max_temp = np.zeros(len(lats))
    for i, lat in enumerate(lats):
        if lons[i] > 180.:
            lon = lons[i]-360.
        else:
            lon = lons[i]
        lat_ix = (np.abs(cube.coord('latitude').points - lat)).argmin()
        lon_ix = (np.abs(cube.coord('longitude').points - lon)).argmin()
        
   
        cru_temp = cube.data[:, lat_ix, lon_ix]
        if np.isfinite(cru_temp[0]):
            pass
        else:
            # get an average of surrounding ones
            surround = [cube.data[:, lat_ix + 1, lon_ix],
                        cube.data[:, lat_ix - 1, lon_ix],
                        cube.data[:, lat_ix, lon_ix + 1],
                        cube.data[:, lat_ix, lon_ix -1],
                        ]
            cru_temp = np.ma.mean(surround, axis=0)
            cru_max_temp[i] = np.max(cru_temp)
        cru_min_temp[i] = np.min(cru_temp)
      
     
    return cru_min_temp, cru_max_temp

###########################
def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3

def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
   
    return plio_minval_array, plio_maxval_array

 
def get_land_obs():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle, modern obs WMMT, modern obs CMMT
    #sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
    #                np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, 
    #                 8.0, np.nan])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     np.nan, np.nan, -1.67, 1.07, np.nan, np.nan, 
                     15.3, -17.4])
    sitedata.append(['Lake El\'gygytgyn', 67, 172, -36.8, -30.4,
                    np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, 
                     8.0, np.nan])
    sitedata.append(['Near Meighen Island', 77.5, 261, 19.6, 20.5,
                     11.5, 13.5, -11.6, -11.4,
                     -33.0, -18.5, 4.1, -42.5])
    sitedata.append(['Beaver Pond', 79, 278, 18.4, 20.9,
                     np.nan, np.nan, -12.2, -11.5,
                     np.nan, np.nan,  7.1, -39.7])
    sitedata.append(['Flyes Leaf Bed', 79, 278, 19.7, 21.1,
                     np.nan, np.nan, -12.8, -9.1,
                     np.nan, np.nan,  7.1, -39.7])
    sitedata.append(['Lost Chicken Mine', 64, 218, 12.0, 12.0, 
                     13.5, 16.0, -2.0, -2.0, -27.75, -19.25, 15.3, -25.1])
   

    sites_relaxed_coex = []
    # sitename WMMTmin WMMT max, CMMT min, CMMTmax, BMA WMMTmin, BMA_WMMTmax,
    # BMA_CMMTmin, BMA_CMMTmax
    sites_relaxed_coex.append(['Lake Baikal', np.nan, np.nan, np.nan, np.nan,
                               np.nan, np.nan, np.nan, np.nan])
    sites_relaxed_coex.append(['Lake El\'gygytgyn', np.nan, np.nan, np.nan, np.nan, 15.0, 16.0, -36.8, -30.4 ])
    sites_relaxed_coex.append(['Near Meighen Island', 18.1, 22.8, -21.7, -7.9,
                               np.nan, np.nan, np.nan, np.nan])
    sites_relaxed_coex.append(['Beaver Pond', 18.1, 22.4, -21.7, -8.1,
                               np.nan, np.nan, np.nan, np.nan])
    sites_relaxed_coex.append(['Flyes Leaf Bed', 18.1, 22.7, -16.9, -6.4,
                               np.nan, np.nan, np.nan, np.nan])
    sites_relaxed_coex.append(['Lost Chicken Mine', np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan])
             

    # lcm observations from elias and matthews 2002
    # lake baikal is from what ulrich sent me.  MI and BP and FLBfrom Fletcher
    # Lake E from Brigette-greeme mean july temp of +8 and average winter lows of 35degC
    # Meighen Island is 'upper'
    
    sites = []
    lats = []
    lons = []
    WMMT_veg_min = []
    WMMT_veg_max = []
    WMMT_coex_min = []
    WMMT_coex_max = []
    WMMT_BMA_min = []
    WMMT_BMA_max = []
    WMMT_beetle_min = []
    WMMT_beetle_max = []
    WMMT_modern_obs = []
    CMMT_veg_min = []
    CMMT_veg_max = []
    CMMT_coex_min = []
    CMMT_coex_max = []
    CMMT_BMA_min = []
    CMMT_BMA_max = []
    CMMT_beetle_min = []
    CMMT_beetle_max = []
    CMMT_modern_obs = []
    
    for i, info in enumerate(sitedata):
        info2 = sites_relaxed_coex[i]                          
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_veg_min.append(info[3])
        WMMT_veg_max.append(info[4])
        WMMT_beetle_min.append(info[5])
        WMMT_beetle_max.append(info[6])
        CMMT_veg_min.append(info[7])
        CMMT_veg_max.append(info[8])
        CMMT_beetle_min.append(info[9])
        CMMT_beetle_max.append(info[10])
        WMMT_modern_obs.append(info[11])
        CMMT_modern_obs.append(info[12])
        if info[0] == info2[0]:
           WMMT_coex_min.append(info2[1])
           WMMT_coex_max.append(info2[2])
           CMMT_coex_min.append(info2[3])
           CMMT_coex_max.append(info2[4])
           WMMT_BMA_min.append(info2[5])
           WMMT_BMA_max.append(info2[6])
           CMMT_BMA_min.append(info2[7])
           CMMT_BMA_max.append(info2[8])
        else:
           print,'check names match',info[0],info2[0]
           sys.exit(0)      
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + '\n (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_veg_min),
             np.asarray(WMMT_veg_max), np.asarray(WMMT_beetle_min),
             np.asarray(WMMT_beetle_max), np.asarray(CMMT_veg_min),
             np.asarray(CMMT_veg_max), np.asarray( CMMT_beetle_min),
             np.asarray(CMMT_beetle_max), np.asarray(WMMT_modern_obs),
             np.asarray(CMMT_modern_obs), np.asarray(WMMT_coex_min),
             np.asarray(WMMT_coex_max),np.asarray(CMMT_coex_min),
             np.asarray(CMMT_coex_max),np.asarray(WMMT_BMA_min),
             np.asarray(WMMT_BMA_max),np.asarray(CMMT_BMA_min),
             np.asarray(CMMT_BMA_max))


def plot_figure(WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min, WMMT_beetle_max,
                CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min, CMMT_beetle_max,
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                labels, pi_ind, cru_min, cru_max,WMMT_coex_min,
                WMMT_coex_max,CMMT_coex_min,CMMT_coex_max,WMMT_BMA_min,
                WMMT_BMA_max,CMMT_BMA_min,CMMT_BMA_max):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """


    fig1 = plt.figure(figsize=[10.0, 8.0])
    ax1 = plt.axes(frameon=False)
    ax1.get_xaxis().tick_top()
    ax1.axes.get_yaxis().set_visible(False)

    nsites=len(WMMT_veg_min)
    yarray = np.arange(1, nsites+1, 1)
 
    # plot warm and cold month temperature
    ax1.hlines(y=yarray, xmin=WMMT_veg_min, xmax= WMMT_veg_max,color='red')
    ax1.hlines(y=yarray, xmin=CMMT_veg_min, xmax= CMMT_veg_max,color='blue')
    if pi_ind == 'y': # plot cru temps
        plt.scatter((WMMT_veg_max + WMMT_veg_min) / 2.0, 
                yarray, color='red', marker='^',
                label='modern WMMT at site')
        plt.scatter((CMMT_veg_max + CMMT_veg_min) / 2.0, 
                 yarray, color='blue', marker='^',
                label =  'modern CMMT at site')
  
        plt.scatter(cru_max, yarray, color='red', marker = 'v', label = 'CRU WMMT')
        plt.scatter(cru_min, yarray, color='blue', marker = 'v', label = 'CRU CMMT')   
    else:
        plt.scatter((WMMT_veg_max + WMMT_veg_min) / 2.0, 
                yarray, color='red', marker='^',
                label='paleovegetation WMMT')
        plt.scatter((CMMT_veg_max + CMMT_veg_min) / 2.0, 
                 yarray, color='blue', marker='^',
                label =  'paleovegetation CMMT')
  
        # put an arrow on LCM
        plt.arrow(CMMT_veg_max[5], yarray[5], -10, 0, linestyle='dotted', 
                  color='blue', head_width=0.1, head_length=0.5)
   
    # try plotting axis
  
    for j in range(0, nsites):
        if pi_ind == 'y':
           plt.text(20.0,
                 yarray[j], labels[j], ha='left')
        else:
            plt.text(-35.0,
                 yarray[j], labels[j], ha='right')

     

    
    plt.scatter(mmm_WMT, yarray + 0.2, color='black', s=50)
    plt.scatter(mmm_WMT, yarray + 0.2, color='red', 
                s=25, label='MMM WMMT')
    plt.scatter(mmm_CMT, yarray + 0.2, color='black', s=50)
    plt.scatter(mmm_CMT, yarray + 0.2, color='blue', 
                s=25, label='MMM CMMT')
  
    plt.ylim(8, -0.5)

    # plot individual models for pliocene
    for i in range(0, len(MODELNAMES)):
        if i == 0:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='red', 
                        marker = 'x', s=10, label='models WMMT')
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='blue', 
                        marker = 'x', s=10, label='models CMMT')
        else:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='red', 
                        marker = 'x',s=10)
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='blue', 
                        marker = 'x', s=10)
        
    if pi_ind == 'y':
        plt.xlim(-50, 25)
        plt.hlines(y=-0.45, xmin=-50., xmax=25., linewidth=0.5)
        plt.text(-45.0, 0.0, 'Cold Month Temperature (degC)', ha='left', color='blue')
        plt.text(20.0, 0.0, 'Warm Month Temperature (deg C)', ha='right', color='red') 
    else:
        plt.xlim(-40, 30)
        plt.hlines(y=-0.45, xmin=-40., xmax=30., linewidth=0.5)
        plt.text(-35.0, 0.0, 'Cold Month Temperature (degC)', ha='left', color='blue')
        plt.text(25.0, 0.0, 'Warm Month Temperature (deg C)', ha='right', color='red')
        # plot all beetle assemblage results
        plt.hlines(yarray, xmin=WMMT_beetle_min, 
               xmax=WMMT_beetle_max, color='green',linestyle='dashed',
               label='beetle assemblage data')
        plt.hlines(yarray, xmin=CMMT_beetle_min, 
               xmax=CMMT_beetle_max, color='green', linestyle='dashed')
        # plot coexistence results
        plt.hlines(yarray+0.1, xmin=WMMT_coex_min, 
               xmax=WMMT_coex_max, color='red',linestyle='dotted',
               label='relaxed coexistence approach data')
        plt.hlines(yarray+0.1, xmin=CMMT_coex_min, 
               xmax=CMMT_coex_max, color='blue', linestyle='dotted')
        # plot BMA results
        plt.scatter((WMMT_BMA_max + WMMT_BMA_min) / 2.0, 
                yarray, color='red', marker='v',
                label='WMMT BMA')
        plt.scatter((CMMT_BMA_max + CMMT_BMA_min) / 2.0, 
                yarray, color='blue', marker='v',
                label='WMMT BMA')
        plt.hlines(yarray, xmin=WMMT_BMA_min, 
               xmax=WMMT_BMA_max, color='red')
        plt.hlines(yarray, xmin=CMMT_BMA_min, 
               xmax=CMMT_BMA_max, color='blue')
    
    
    plt.legend(loc='lower center', ncol=3)

    if pi_ind == 'y':
        fig1.suptitle('b) modern/preindustrial DMC', x=0.1, ha='left', fontsize=16)
        fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_pi.eps')
        plt.savefig(fileout)
        fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_pi.png')
        plt.savefig(fileout)
    else:
        fig1.suptitle('a) Pliocene DMC', x=0.1, ha='left', fontsize=16)
        fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_plot.eps')
        plt.savefig(fileout)
        fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot.png')
        plt.savefig(fileout)
    plt.close()



####################################################
def plot_chg_seas_cyc(WMMT_veg,CMMT_veg, all_models_plio_WMT, 
                      all_models_plio_CMT, all_models_pi_WMT,
                      all_models_pi_CMT,
                      sites, mmm_WMT, mmm_CMT, mmm_WMT_pi, mmm_CMT_pi,cru):
    """
    plots the change in the seasonal cycle between pi and mpwp
    """
    colors = {'CESM2' : 'green',
              'HadGEM3': 'green',
              'IPSLCM6A' : 'green', 
              'COSMOS': 'red', 
              'MIROC4m': 'red', 
              'HadCM3': 'green',
              'GISS2.1G' : 'black', 
              'CCSM4' : 'black', 
              'CCSM4-Utr' : 'black', 
              'CCSM4-UoT' : 'purple', 
              'NorESM-L' : 'purple', 
              'NorESM1-F' : 'purple',
              'MRI2.3' : 'red'}

    marker = {'CESM2' : '^',
              'HadGEM3': 'x',
              'IPSLCM6A' : 'o', 
              'COSMOS': '^', 
              'MIROC4m': 'x', 
              'HadCM3': 'o',
              'GISS2.1G' : '^', 
              'CCSM4' : 'x', 
              'CCSM4-Utr' : 'o', 
              'CCSM4-UoT' : '^', 
              'NorESM-L' : 'x', 
              'NorESM1-F' : 'o',
              'MRI2.3' : 'v',
              'EC-Earth3.3' : '^',
              'CESM1.2' : 'o'}

    print('julia')
    fig1 = plt.figure(figsize=[10.0, 8.0])
    ax1 = plt.subplot(211)
   # ax1.get_xaxis().tick_top()
    ax1.axes.get_xaxis().set_visible(False)

    xarray = np.arange(0,len(sites))
    plt.scatter(xarray, np.asarray(WMMT_veg) - np.asarray(CMMT_veg), 
                color='red', marker = 'x', s=20, label='veg data')
    plt.scatter(xarray, np.asarray(cru),color='black',marker = 's',
                label='cru')
    

    for i, model in enumerate(MODELNAMES):
        plt.scatter(xarray+(0.02 * i), np.asarray(all_models_plio_WMT[:,i])
                    -np.asarray(all_models_plio_CMT[:,i]), 
                    color=colors.get(model,'blue'), 
                    marker = marker.get(model,'x'),label=model)
   
    plt.xlim(-1, 8)
    plt.hlines(y=0, xmin=-1., xmax=6., linewidth=0.5)
    plt.vlines(x=-1, ymin=-25, ymax=7, linewidth=0.5)

    plt.legend(loc='right')

    for i in range(0, len(sites)):
        plt.text(xarray[i], 0, sites[i], ha='right',rotation=90)


    # plot change in seasonal cycle
    seas_chg = (np.asarray(all_models_plio_WMT) 
                - np.asarray(all_models_plio_CMT) 
                - np.asarray(all_models_pi_WMT)
                + np.asarray(all_models_pi_CMT))
    ax2 = plt.subplot(212)
    for i, model in enumerate(MODELNAMES):
        plt.scatter(xarray+(0.02 * i),seas_chg[:,i],
                    color=colors.get(model,'blue'), 
                    marker = marker.get(model,'x'),label=model)
        print(model, all_models_plio_WMT[3,i],all_models_plio_CMT[3,i],
              all_models_pi_WMT[3,i],all_models_pi_CMT[3,i])
    sys.exit(0)
    plt.hlines(y=0, xmin=-1., xmax=6., linewidth=0.5)
   

    plt.show()
            
   

  
def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    d) plots change in seasonal cycle at MI, BP and LB
    """

   
    # get land observations and cru temperature at land points 
    (sites, land_lats, land_lons, WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min,
     WMMT_beetle_max, CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min,
     CMMT_beetle_max, WMMT_modern_obs, CMMT_modern_obs,WMMT_coex_min,
     WMMT_coex_max,CMMT_coex_min,CMMT_coex_max,WMMT_BMA_min,
     WMMT_BMA_max,CMMT_BMA_min,CMMT_BMA_max) =  get_land_obs()
    
    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)

    
    
    # get ind models data
    print(land_lons)
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_seas_cyc_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT

        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT

        all_models_seas_cyc_anom[:, i] = (
            (all_models_plio_WMT[:, i] - all_models_plio_CMT[:, i]) -
            (all_models_pi_WMT[:, i] - all_models_pi_CMT[:, i]))
        
        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])



    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)
    mmm_WMT_pi = np.nanmean(all_models_pi_WMT, axis=1)
    mmm_CMT_pi = np.nanmean(all_models_pi_CMT, axis=1)


    print('MMM WMMT avg all sites',np.nanmean(mmm_WMT), 'all',mmm_WMT)
    print('veg data WMMT avg all sites',
          np.nanmean(WMMT_veg_min + WMMT_veg_max) / 2.0, 'all',
          (WMMT_veg_min + WMMT_veg_max) / 2.0)
    print('MMM CMMT avg all sites',np.nanmean(mmm_CMT), 'all',mmm_CMT)
    print('veg data CMMT avg all sites',
          np.nanmean(CMMT_veg_min + CMMT_veg_max) / 2.0, 'all',
          (CMMT_veg_min + CMMT_veg_max) / 2.0)

    # plot data
    dummy = np.zeros(len(WMMT_modern_obs))
    dummy[:] = np.nan
 
    plot_figure(WMMT_veg_min, WMMT_veg_max, WMMT_beetle_min, WMMT_beetle_max,
                CMMT_veg_min, CMMT_veg_max, CMMT_beetle_min, CMMT_beetle_max,
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'n', dummy, dummy,WMMT_coex_min,
                WMMT_coex_max,CMMT_coex_min,CMMT_coex_max,WMMT_BMA_min,
                WMMT_BMA_max,CMMT_BMA_min,CMMT_BMA_max)
    # plot a dmc for the pi
    plot_figure (WMMT_modern_obs, WMMT_modern_obs, dummy, dummy,
                 CMMT_modern_obs, CMMT_modern_obs, dummy, dummy,
                 all_models_pi_WMT, all_models_pi_CMT, mmm_WMT_pi, mmm_CMT_pi,
                 sites,'y', cru_min_temp, cru_max_temp,dummy, dummy,
                 dummy, dummy, dummy, dummy, dummy, dummy)

    # plot change in seasonal cycle
    plot_chg_seas_cyc((WMMT_veg_min + WMMT_veg_max)/2.0, 
                (CMMT_veg_min +  CMMT_veg_max) / 2.0, 
                all_models_plio_WMT, all_models_plio_CMT,
                all_models_pi_WMT, all_models_pi_CMT,
                      sites, mmm_WMT, mmm_CMT, mmm_WMT_pi, mmm_CMT_pi,
                (cru_max_temp - cru_min_temp) / 2.0   )

##########################################################
# main program

LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
           #  ,  'MRI2.3'
              ]

#MODELNAMES = ['CESM2']

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
seasonal_dmc_plot_v2_beetle.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created Sept 2021 by Julia

This program is based on seasonal_dmc_plot_v2  but will plot the DMC for
Beetles instead of paleoveg

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm


def get_cru_temp(lats, lons):
    """
    get's the cru temperature at the given latitude and longitude
    """
    
    crufile = ('/nfs/hera1/earjcti/regridded/CRUTEMP/' + 
               'E280.NearSurfaceTemperature.mean_month.nc')
    cube = iris.load_cube(crufile)
    
    
    cru_min_temp = np.zeros(len(lats))
    cru_max_temp = np.zeros(len(lats))
    for i, lat in enumerate(lats):
        if lons[i] > 180.:
            lon = lons[i]-360.
        else:
            lon = lons[i]
        lat_ix = (np.abs(cube.coord('latitude').points - lat)).argmin()
        lon_ix = (np.abs(cube.coord('longitude').points - lon)).argmin()
        
   
        cru_temp = cube.data[:, lat_ix, lon_ix]
        if np.isfinite(cru_temp[0]):
            pass
        else:
            # get an average of surrounding ones
            surround = [cube.data[:, lat_ix + 1, lon_ix],
                        cube.data[:, lat_ix - 1, lon_ix],
                        cube.data[:, lat_ix, lon_ix + 1],
                        cube.data[:, lat_ix, lon_ix -1],
                        ]
            cru_temp = np.ma.mean(surround, axis=0)
            cru_max_temp[i] = np.max(cru_temp)
        cru_min_temp[i] = np.min(cru_temp)
      
     
    return cru_min_temp, cru_max_temp

###########################
def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3

def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
   
    return plio_minval_array, plio_maxval_array

def land_reformat(sitedata):
    """
    reformats the land data into different arrays
    """
    
    sites = []
    lats = []
    lons = []
    WMMT_data_min = []
    WMMT_data_max = []
    CMMT_data_min = []
    CMMT_data_max = []
    refs = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_data_min.append(info[3])
        WMMT_data_max.append(info[4])
        CMMT_data_min.append(info[5])
        CMMT_data_max.append(info[6])
        refs.append(info[7])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + ' (' +  latstr + ',' +  lonstr + ')'
        labels.append(site)
   
    return  (labels, lats, lons, np.asarray(WMMT_data_min),
             np.asarray(WMMT_data_max),  np.asarray(CMMT_data_min),
             np.asarray(CMMT_data_max), refs)

 
def get_land_beetle_CLA():
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, 
    # min WMMT beetle, max WMMT beetle, 
    # min CMMT beetle, max CMMT beetle


    sitedata.append(['Near Meighen Island', 77.5, 261, [19.8, 12.5], 
                     [21.2, 13.6],
                    [-15.0, -9.4], [-11.6,-6.3], '~3.6Ma: Fletcher et al. 2019'])
    sitedata.append(['Beaver Pond', 79, 278, [13.6, 7.4], [13.9, 7.7],
                     [-23.5, -21.1], [-20.4, -18.3], '3.9 +1.5 / -0.5Ma: Fletcher et al. 2019'])

    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max, refs)

def get_land_beetle_CA():
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, 
    # min WMMT beetle, max WMMT beetle, 
    # min CMMT beetle, max CMMT beetle


    sitedata.append(['Near Meighen Island', 77.5, 261, [19.5, 11.2], 
                     [22.3, 14.9],
                    [-24.0, -15.7], [-13.0,-6.1], '~3.6Ma: Fletcher et al. 2019'])
    sitedata.append(['Beaver Pond', 79, 278, [9.4, 4.6], [16.5, 9.4],
                     [-25.0, -25.0], [-10.4, -4.1], '3.9 +1.5 / -0.5Ma: Fletcher et al. 2019'])

    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max, refs)

 
def get_land_beetle_mcr():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []   
    # site data is
    # sitename, sitelat, sitelon, 
    # min WMMT beetle, max WMMT beetle, 
    # min CMMT beetle, max CMMT beetle

    # all were reported in Elias and Matthews
    # note Pliocene Tmin - modern Tmin varies between 2.3 degC and 20degC

  
    sitedata.append(['Ballast Brook', 74, 237, 
                     14.0, 14.5, -21.0, -19.5,'~3-5Ma: Flyes et al 1994'])
    sitedata.append(['Strathcona Beaver Peat', 79, 278, 
                     11.7, 12.2, -28.7, -27.2, '>3.3Ma: Matthews and Flyes 2000'])
    sitedata.append(['Near Meighen Island', 77.5, 261, 
                     11.5, 13.5, -33.0, -18.5,'~3Ma: Elias and Matthews 2002'])
    sitedata.append(['Lost Chicken Mine', 64, 218,  
                     13.5, 16.0, -27.75, -19.25, '~3Ma: Matthews and Telka 1997'])
    sitedata.append(['Bluefish', 67, 221,  
                     12.7, 15.0, -30.0, -20.5, '~LP: Matthews and Telka 1997'])
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max, refs)


def plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                labels,titleinfo,ystart,refs):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """

    titlename = {'KM5c' : 'Near KM5c',
                 'LPCA' : 'Late Pliocene (Coexistence Approach)',
                 'EPCA' : 'Early Pliocene (Coexistence Approach)',
                 'CLA' : 'Coexistence Likelihood Estimation',
                 'CA' : 'Coexistence Approach',
                 'MCR' : 'Mutual Climatic Range'
        }
    labelname = {0 : 'palaeodata WMMT',
                 1 : 'palaeodata CMMT',
                 2 : 'MMM WMMT',
                 3 : 'MMM CMMT'}

    WMMT_data_mean = (WMMT_data_min + WMMT_data_max) / 2.0
 
    CMMT_data_mean = (CMMT_data_min + CMMT_data_max) / 2.0
    
    ax1 = plt.axes(frameon=False)
     
    if ystart == 0:
        ax1.get_xaxis().tick_top()
        ax1.axes.get_yaxis().set_visible(False)
        ax1.set_ylim([0, 17])
        plt.gca().invert_yaxis()
      

   
    nsites=len(WMMT_data_min)
    yarray = np.arange(ystart+1.5, nsites+ystart+1, 1)
    yend=ystart+nsites
 
    # plot warm and cold month temperature anomalies

    if titleinfo[0:2] == 'MC': # tamara fletchers data was not wmmt
        ax1.hlines(y=yarray, xmin=WMMT_data_min, xmax= WMMT_data_max,color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min, xmax= CMMT_data_max,color='tab:blue')
   
        plt.scatter(WMMT_data_mean, 
                    yarray, color='tab:red', marker='^',
                    label='palaeodata WMMT',s=60)
        plt.scatter(CMMT_data_mean, 
                    yarray, color='tab:blue', marker='^',
                    label='palaeodata CMMT' ,s=60)
    else:
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,0], xmax= WMMT_data_max[:,0],color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,0], xmax= CMMT_data_max[:,0],color='tab:blue')
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,1], xmax= WMMT_data_max[:,1],color='tab:pink',linestyle='dashed')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,1], xmax= CMMT_data_max[:,1],color='tab:cyan',linestyle='dashed')
        if titleinfo == 'CLA':
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',
                        label='max T warmest month',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',
                        label =  'min T coldest month ',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',
                        label='wamest quarter T',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',
                        label =  'coldest quarter T ',s=60)
        else:
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',s=60)

   
    # try plotting axis
  
    for j in range(0, nsites):
        plt.text(-40.0, yarray[j], labels[j], ha='right')
        #if ystart == 0:
        #    plt.text(27.0, yarray[j], refs[j], ha='left')
        #else:
        #    plt.text(35.0, yarray[j], refs[j], ha='left')

     

    
    plt.scatter(mmm_WMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_WMT, yarray + 0.2, color='tab:red', 
                s=25, label=labelname.get(ystart+2,None))
    plt.scatter(mmm_CMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_CMT, yarray + 0.2, color='tab:blue', 
                s=25, label=labelname.get(ystart+3,None))
  
  
    # plot individual models for pliocene
    for i in range(0, len(MODELNAMES)):
        if i == 0 and ystart==0:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x', s=15, label='models WMMT')
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15, label='models CMMT')
        else:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x',s=15)
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15)
        
    plt.hlines(y=ystart, xmin=-50., xmax=30., linewidth=0.5)
    plt.text(-30.0, -1.5, 'Cold Month Temperature (degC)', ha='left', color='tab:blue',fontsize=12)
    plt.text(10.0, -1.5, 'Warm Month Temperature (deg C)', ha='left', color='tab:red',fontsize=12)
    print(titleinfo, titlename.get(titleinfo))
    plt.text(-35.0,ystart+0.5,titlename.get(titleinfo),fontsize=12)
       
    
   # plt.legend(bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=5,
   #                prop = {'size':12})
    if ystart > 4:
       handles, labels = plt.gca().get_legend_handles_labels()
      # order = [2, 3, 4, 5, 0,6,8,1,7,9]
       order = [4,5,6,7,8,0,2,9,1,3]
       print(labels)
       print(ystart)
       plt.legend([handles[idx] for idx in order],
                  [labels[idx] for idx in order],
              bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=3,
              prop = {'size':12})
   
  
   
   
 
    return ax1,yend+2

  
def get_model_data(land_lats, land_lons):
    """
    get the model data for these latitude and longitudes
    """
    
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_seas_cyc_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT

        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT

        all_models_seas_cyc_anom[:, i] = (
            (all_models_plio_WMT[:, i] - all_models_plio_CMT[:, i]) -
            (all_models_pi_WMT[:, i] - all_models_pi_CMT[:, i]))
        
        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])



    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)
    mmm_WMT_pi = np.nanmean(all_models_pi_WMT, axis=1)
    mmm_CMT_pi = np.nanmean(all_models_pi_CMT, axis=1)


    return  (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom, 
     all_models_WMMT_anom, mmm_WMT, mmm_CMT, mmm_WMT_pi, mmm_CMT_pi)

def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    d) plots change in seasonal cycle at MI, BP and LB
    """


    # plot data
    fig1 = plt.figure(figsize=[11.7, 8.7])
  

     ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, refs) =  get_land_beetle_CLA()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

   
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'CLA',0,refs)
    

    ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max,refs) =  get_land_beetle_CA()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'CA',ystart,refs)
   
    
    ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max,refs) =  get_land_beetle_mcr()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_splio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data
    for i,site in enumerate(sites):
        print('warm',site, WMMT_data_min[i], WMMT_data_max[i],mmm_WMT[i])
        print('cold',site, CMMT_data_min[i], CMMT_data_max[i],mmm_CMT[i])
        print(' ')
 #       for j, model in enumerate(MODELNAMES):
 #           print(model, all_models_plio_CMT[i,j], all_models_plio_CMT[i,j] - all_models_plio_CMT[1,j])
    sys.exit(0)

    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'MCR',ystart,refs)
    ax1.set_ylim(None,0)    
    

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_plot_v2_beetle.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2_beetle.pdf')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2_beetle.png')
    plt.savefig(fileout)
    plt.close()

 
##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 
               'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
         #    ,  'MRI2.3'
              ]

#MODELNAMES = ['IPSLCM6A']

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
seasonal_dmc_plot_v2_old.py
::::::::::::::
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet
The difference between this and version 1 is that we will group the data
by dating / proxy

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm


def get_cru_temp(lats, lons):
    """
    get's the cru temperature at the given latitude and longitude
    """
    
    crufile = ('/nfs/hera1/earjcti/regridded/CRUTEMP/' + 
               'E280.NearSurfaceTemperature.mean_month.nc')
    cube = iris.load_cube(crufile)
    
    
    cru_min_temp = np.zeros(len(lats))
    cru_max_temp = np.zeros(len(lats))
    for i, lat in enumerate(lats):
        if lons[i] > 180.:
            lon = lons[i]-360.
        else:
            lon = lons[i]
        lat_ix = (np.abs(cube.coord('latitude').points - lat)).argmin()
        lon_ix = (np.abs(cube.coord('longitude').points - lon)).argmin()
        
   
        cru_temp = cube.data[:, lat_ix, lon_ix]
        if np.isfinite(cru_temp[0]):
            pass
        else:
            # get an average of surrounding ones
            surround = [cube.data[:, lat_ix + 1, lon_ix],
                        cube.data[:, lat_ix - 1, lon_ix],
                        cube.data[:, lat_ix, lon_ix + 1],
                        cube.data[:, lat_ix, lon_ix -1],
                        ]
            cru_temp = np.ma.mean(surround, axis=0)
            cru_max_temp[i] = np.max(cru_temp)
        cru_min_temp[i] = np.min(cru_temp)
      
     
    return cru_min_temp, cru_max_temp

###########################
def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3

def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
   
    return plio_minval_array, plio_maxval_array

def land_reformat(sitedata):
    """
    reformats the land data into different arrays
    """
    
    sites = []
    lats = []
    lons = []
    WMMT_data_min = []
    WMMT_data_max = []
    WMMT_modern_obs = []
    CMMT_data_min = []
    CMMT_data_max = []
    CMMT_modern_obs = []
    refs = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_data_min.append(info[3])
        WMMT_data_max.append(info[4])
        CMMT_data_min.append(info[5])
        CMMT_data_max.append(info[6])
        WMMT_modern_obs.append(info[7])
        CMMT_modern_obs.append(info[8])
        refs.append(info[9])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + ' (' +  latstr + ',' +  lonstr + ')'
        labels.append(label)
   
    return  (labels, lats, lons, np.asarray(WMMT_data_min),
             np.asarray(WMMT_data_max),  np.asarray(CMMT_data_min),
             np.asarray(CMMT_data_max),  np.asarray(WMMT_modern_obs),
             np.asarray(CMMT_modern_obs),refs)

 
def get_land_km5c():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle, modern obs WMMT, modern obs CMMT
    # reference and date

    # lake baikal is from what ulrich sent me.
    # Lake E from Brigette-greeme mean july temp of +8 and average winter lows of 35degC

    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    -36.8, -30.4, 
                     8.0, np.nan,'CMMT 3.199Ma - 3.209Ma; Pavel Tarasov (pers. comm) \n WMMT Brigham-Grette et al. 2013'])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     -1.67, 1.07, 
                     15.3, -17.4,'Km5c - unpublished \n (Method of Klage et al 2020)'])
    
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_LP():
    """
    these have been obtained from various sources so I am just typing them in
    LP means late pliocene
    """
    sitedata = []
    # lake baikal is from demske 2002.
    sitedata.append(['Lake Baikal', 56, 108, 13.0, 24.0, -15, 5,
                     np.nan, np.nan,'Prior to 3.5Ma (Demske et al 2002)'])
    # these are from popova et al 2012 using coexistence approach.
  
    sitedata.append(['Mirny', 55, 82, 18.8, 24.6, -0.3, 0.7,
                     np.nan, np.nan,'Popova et al 2012'])
    sitedata.append(['Merkutlinskiy', 56, 72, 17.3, 23.8, -3.8, 6.2,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Kabinet', 55, 80, 21.6, 24.4, -4.4, 4.6,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Delyankir', 63, 133, 18.9, 24.9, -6.9, 1.3,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Chernoluche', 55, 73, 19.6, 20.3, -5.9, 0.7,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Blizkiy', 64, 162, 15.6, 23.3, -12.8, 5.2,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['42km', 55, 80, 21.6, 23.3, -4.4, 0.7,
                     np.nan, np.nan,' --"--'])
  
    sitedata.append(['Lost Chicken Mine', 64, 218, 12.0, 12.0, 
                     -2.0, -2.0, 15.3, -25.1, '2.9 +/- 0.4Ma: Ager et al. 1994'])
  
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_EP():
    """
    these have been obtained from various sources so I am just typing them in
    EP means early pliocene
    """
    sitedata = []
    # these are from popova et al 2012 using coexistence approach.
  
    sitedata.append(['Tnekveem', 66, 177, 18.9, 25.6, -11.8, 5.8, 
                     np.nan, np.nan,'Popova et al 2012'])
    sitedata.append(['Hydzhak', 63, 147, 18.8, 24.9, -8.7, 1.3,
                     np.nan, np.nan,' --"--'])

   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_fletcher():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT data, max WMMT data,
    # min CMMT data, max CMMT data
    # modern obs WMMT, modern obs CMMT
    # we think FLB is 3.8Ma, BP originally was 3.4 but has been redated
   
    # for TF data we are reporting here temperature of warmest month
    # and temperature of warmest quater
    
    sitedata.append(['Meighen Island', 77.5, 261, [19.6, 12.8], 
                     [20.5, 13.3],
                    [-11.6, -6.8], [-11.4, -6.2],
                     4.1, -42.5, 'Fletcher et al. 2017'])
    sitedata.append(['Beaver Pond', 79, 278, [18.4, 12.4], [20.9, 13.1],
                     [-12.2, -7.3], [-11.5, -6.8],
                      7.1, -39.7, '3.9 +1.5 / -0.5Ma: Fletcher et al. 2017'])
    sitedata.append(['Fyles Leaf Beds', 79, 277, [19.7, 12.6], [21.1, 13.4],
                     [-12.8, -7.2], [-9.1, -5.5],
                      np.nan, np.nan, '3.8 +1/-0.7Ma: Fletcher et al. 2017'])
     
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)

def get_land_fletcher_ca():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT data, max WMMT data,
    # min CMMT data, max CMMT data
    # modern obs WMMT, modern obs CMMT
    # we think FLB is 3.8Ma, BP originally was 3.4 but has been redated
   
    # for tf data we are reporting hwere temp of warmest month and
    # warmest quater
    
    sitedata.append(['Near Meighen Island', 77.5, 261, [18.1, 10.6], 
                     [22.8, 16.2],
                    [-21.7,-16.3,], [-7.9, -2.7],
                     4.1, -42.5,'Fletcher et al. 2017'])
    sitedata.append(['Beaver Pond', 79, 278, [18.1, 11.3],[22.4, 16.3],
                     [-21.7, -15.0], [-8.1, -3.5],
                      7.1, -39.7,'3.9 +1.5 / -0.5Ma: Fletcher et al. 2017'])
    sitedata.append(['Fyles Leaf Beds', 79, 277, [18.1, 10.9], [22.7, 15.0],
                     [-16.9, -12.4], [-6.4, -2.3],
                      np.nan, np.nan,'3.8 +1/-0.7Ma: Fletcher et al. 2017'])
     
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)

def get_land_beetle():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle, modern obs WMMT, modern obs CMMT

    # all were reported in Elias and Matthews
    # note Pliocene Tmin - modern Tmin varies between 2.3 degC and 20degC

    sitedata.append(['Ballast Brook', 74, 237, 
                     14.0, 14.5, -21.0, -19.5, 2.4, -41.4,'~3-5Ma: Flyes et al 1994'])
    sitedata.append(['Strathcona Beaver Peat', 79, 278, 
                     11.7, 12.2, -28.7, -27.2, 2.4, -41.4,'>3.3Ma: Matthews and Flyes 2000'])
    sitedata.append(['Near Meighen Island', 77.5, 261, 
                     11.5, 13.5, -33.0, -18.5, 4.1, -42.5,'~3Ma: Elias and Matthews 2002'])
    sitedata.append(['Lost Chicken Mine', 64, 218,  
                     13.5, 16.0, -27.75, -19.25, 15.3, -25.1,'~3Ma: Matthews and Telka 1997'])
    sitedata.append(['Bluefish', 67, 221,  
                     12.7, 15.0, -30.0, -20.5, 16.0, -29.0,'~LP: Matthews and Telka 1997'])
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)


def plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                labels,titleinfo,ystart,refs):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """

    titlename = {'KM5c' : 'Near KM5c',
                 'LPCA' : 'Late Pliocene (Coexistence Approach)',
                 'EPCA' : 'Early Pliocene (Coexistence Approach)',
                 'TF-CRACLE' : '< 3.9Ma (Coexistence Likelihood Estimation)',
                 'TF-CA' : '<3.9Ma (Coexistence Approach)',
                 'BA' : 'Beetle Assemblage data'
        }
    labelname = {0 : 'palaeodata WMMT',
                 1 : 'palaeodata CMMT',
                 2 : 'MMM WMMT',
                 3 : 'MMM CMMT'}

    WMMT_data_mean = (WMMT_data_min + WMMT_data_max) / 2.0
 
    CMMT_data_mean = (CMMT_data_min + CMMT_data_max) / 2.0
    
    ax1 = plt.axes(frameon=False)
     
    if ystart == 0:
        ax1.get_xaxis().tick_top()
        ax1.axes.get_yaxis().set_visible(False)
        ax1.set_ylim([0, 32])
        plt.gca().invert_yaxis()
        #ax.set_xlim([xmin, xmax])
      

   
    nsites=len(WMMT_data_min)
    yarray = np.arange(ystart+1.5, nsites+ystart+1, 1)
    yend=ystart+nsites
 
    # plot warm and cold month temperature anomalies

    if titleinfo[0:2] != 'TF': # tamara fletchers data was not wmmt
        ax1.hlines(y=yarray, xmin=WMMT_data_min, xmax= WMMT_data_max,color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min, xmax= CMMT_data_max,color='tab:blue')
   
        plt.scatter(WMMT_data_mean, 
                    yarray, color='tab:red', marker='^',
                    label=labelname.get(ystart,None),s=60)
        plt.scatter(CMMT_data_mean, 
                    yarray, color='tab:blue', marker='^',
                    label = labelname.get(ystart+1,None) ,s=60)
    else:
        print(WMMT_data_mean)
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,0], xmax= WMMT_data_max[:,0],color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,0], xmax= CMMT_data_max[:,0],color='tab:blue')
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,1], xmax= WMMT_data_max[:,1],color='tab:pink',linestyle='dashed')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,1], xmax= CMMT_data_max[:,1],color='tab:cyan',linestyle='dashed')
        if titleinfo == 'TF-CRACLE':
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',
                        label='max T warmest month',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',
                        label =  'min T coldest month ',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',
                        label='wamest quarter T',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',
                        label =  'coldest quarter T ',s=60)
        else:
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',s=60)

    # put an arrow on LCM
    for i, label in enumerate(labels):
        if label[0:4] == 'Lost' and i > 4:
            plt.arrow(CMMT_data_max[i], yarray[i], -10, 0, linestyle='dotted', 
                  color='tab:blue', head_width=0.2, head_length=1.0)
   
    # try plotting axis
  
    for j in range(0, nsites):
        plt.text(-35.0, yarray[j], labels[j], ha='right')
        if ystart == 0:
            plt.text(27.0, yarray[j], refs[j], ha='left')
        else:
            plt.text(35.0, yarray[j], refs[j], ha='left')

     

    
    plt.scatter(mmm_WMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_WMT, yarray + 0.2, color='tab:red', 
                s=25, label=labelname.get(ystart+2,None))
    plt.scatter(mmm_CMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_CMT, yarray + 0.2, color='tab:blue', 
                s=25, label=labelname.get(ystart+3,None))
  
  
    # plot individual models for pliocene
    for i in range(0, len(MODELNAMES)):
        if i == 0 and ystart==0:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x', s=15, label='models WMMT')
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15, label='models CMMT')
        else:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x',s=15)
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15)
        
    plt.hlines(y=ystart, xmin=-40., xmax=40., linewidth=0.5)
    plt.text(-30.0, -1.75, 'Cold Month Temperature (degC)', ha='left', color='tab:blue',fontsize=12)
    plt.text(10.0, -1.75, 'Warm Month Temperature (deg C)', ha='left', color='tab:red',fontsize=12)
    plt.text(-35.0,ystart+0.5,titlename.get(titleinfo),fontsize=12)
       
    
    #plt.legend(bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=3,
    #               prop = {'size':12})
    if ystart > 23:
        handles, labels = plt.gca().get_legend_handles_labels()
        order = [2, 3, 4, 5, 0,6,8,1,7,9]
        print(labels)
        print(ystart)
        plt.legend([handles[idx] for idx in order],
                   [labels[idx] for idx in order],
               bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=3,
               prop = {'size':12})
   
   
 
    return ax1,yend+2

  
def get_model_data(land_lats, land_lons):
    """
    get the model data for these latitude and longitudes
    """
    
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_seas_cyc_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT

        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT

        all_models_seas_cyc_anom[:, i] = (
            (all_models_plio_WMT[:, i] - all_models_plio_CMT[:, i]) -
            (all_models_pi_WMT[:, i] - all_models_pi_CMT[:, i]))
        
        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])



    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)
    mmm_WMT_pi = np.nanmean(all_models_pi_WMT, axis=1)
    mmm_CMT_pi = np.nanmean(all_models_pi_CMT, axis=1)


    return  (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom, 
     all_models_WMMT_anom, mmm_WMT, mmm_CMT, mmm_WMT_pi, mmm_CMT_pi)

def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    d) plots change in seasonal cycle at MI, BP and LB
    """

   
    # get land observations and cru temperature at km5c points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_km5c()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)


 #   for i,site in enumerate(sites):
 #       print(site, CMMT_data_min[i], CMMT_data_max[i],mmm_CMT[i])
 #       for j, model in enumerate(MODELNAMES):
 #           print(model, all_models_plio_CMT[i,j], all_models_plio_CMT[i,j] - all_models_plio_CMT[1,j])

    # plot data
    fig1 = plt.figure(figsize=[11.7, 11.7])
  
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'KM5c',0,refs)
   
    #####################################################################
    # get land observations and cru temperature at lp points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_LP()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'LPCA',ystart,refs)
   
   
    #####################################################################
    # get land observations and cru temperature at ep points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_EP()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'EPCA',ystart,refs)
   

    ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_fletcher()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'TF-CRACLE',ystart,refs)

     ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_fletcher_ca()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'TF-CA',ystart,refs)



     ####################################################################
    # get land observations and cru temperature at early pliocene points 
#    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
#     CMMT_data_min, CMMT_data_max, 
#     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_beetle()

#    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
#    (all_models_plio_WMT, all_models_plio_CMT,
#     all_models_pi_WMT, all_models_pi_CMT, 
#     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
#     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

#    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
#                CMMT_data_min, CMMT_data_max, 
#                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
#                sites,'BA',ystart,refs)
#    ax1.set_ylim(None,0)    
    

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_plot_v2.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2.pdf')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2.png')
    plt.savefig(fileout)
    plt.close()

 
##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 
               'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
           #  ,  'MRI2.3'
              ]

#MODELNAMES = ['IPSLCM6A']

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
seasonal_dmc_plot_v2.py
::::::::::::::

#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will produce a lat /lon dmc plot from Ulrichs spreadsheet
The difference between this and version 1 is that we will group the data
by dating / proxy

"""

import numpy as np
import pandas as pd
import iris
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import iris.quickplot as qplt
import iris.plot as iplt
import cartopy.crs as ccrs
import netCDF4

import sys



def get_MMM_data(latreq, lonreq):
    """
    read in MMM data from the pliocene and the preindustrial 
    return the temperature at the list of sites
    """

    plio_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_mPWP')
    pi_cube = iris.load_cube(NSAT_MMM_FILE,
                              'NearSurfaceTemperaturemean_pi')
   
    nsites = len(latreq)
    plio_mmm_array = np.zeros(nsites)
    pi_mmm_array = np.zeros(nsites)

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.


        lat_ix = ((np.abs(plio_cube.coord('latitude').points 
                         - latreq[i])).argmin())
        lon_ix = ((np.abs(plio_cube.coord('longitude').points 
                         - modlon)).argmin())
    
        plio_mmm_array[i] = plio_cube.data[lat_ix, lon_ix]
        pi_mmm_array[i] = pi_cube.data[lat_ix, lon_ix]
   
    return plio_mmm_array, pi_mmm_array

def get_lsm_names(model, period):
    """
    gets the names for each of the land sea masks
    period 0 =e280, period 1 = eoi400
    """
    if model == 'CESM2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e21.B1850.f09_g17.PMIP4-midPliocene-eoi400.001.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'COSMOS':
        lsm = ["/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/E280_et_al/E280.slf.atm.nc", "/nfs/hera1/pliomip2/data/AWI/COSMOS/land_sea_masks/Eoi400_et_al/Eoi400.slf.atm.nc"]
        fieldlsm = "SLF"

    if model == 'EC-Earth3.3':
        lsm =  [DATABASE + 'EC-Earth3.3/EC-Earth3.3_PI_LSM.nc',
                DATABASE + 'EC-Earth3.3/EC-Earth3.3_mPlio_LSM.nc']
        fieldlsm = 'Land/sea mask'

    if model == 'CESM1.2':
        lsm = [DATABASE + 'NCAR/b.e12.B1850.f09_g16.preind.cam.h0.LANDFRAC.0701.0800.nc', DATABASE + 'NCAR/b.e12.B1850.f09_g16.PMIP4-pliomip2.cam.h0.LANDFRAC.1101.1200.nc']
        fieldlsm = 'Fraction of sfc area covered by land'       
  
    if model   ==  'MIROC4m':
        lsm = [DATABASE + 'MIROC4m/sftlf/MIROC4m_Exxx_fx_sftlf.nc', 
               DATABASE + 'MIROC4m/sftlf/MIROC4m_Eoixxx_fx_sftlf.nc']
        fieldlsm = "sftlf"

    if model  == 'HadCM3':
        lsm = [DATABASE+'LEEDS/HadCM3/e280/qrparm.mask.nc',
               DATABASE+'LEEDS/HadCM3/eoi400/P4_enh_qrparm.mask.nc']
        fieldlsm = 'LAND MASK (LOGICAL: LAND=TRUE)'

    if model == 'CCSM4':
        lsm = [DATABASE + 'NCAR/b40.B1850.f09_g16.preind.cam.h0.LANDFRAC.0081.0180.nc', DATABASE + 'NCAR/b40.B1850.f09_g16.PMIP4-pliomip2.LANDFRAC.1001.1100.nc']
        fieldlsm = 'Fraction of sfc area covered by land'

    if model == 'CCSM4-Utr':
        lsm = [DATABASE + 'Utrecht/CESM1.0.5/E280/land_sea_mask_Amon_CESM1.0.5_b.PI_1pic_f19g16_NESSC_control_r1i1p1f1_gn.nc', DATABASE + 'Utrecht/CESM1.0.5/Eoi400/land_sea_mask_Amon_CESM1.0.5_b.PLIO_5Ma_Eoi400_f19g16_NESSC_control_r1i1p1f1_gn.nc']
        fieldlsm = 'LANDMASK[D=1]'
  
    if model == 'CCSM4-UoT':
        start = DATABASE + 'UofT/UofT-CCSM4/'
        lsm = [start + 'for_julia/E_mask.nc', start + 'for_julia/Eoi_mask.nc']
        fieldlsm = 'gridbox land fraction'
      
    if model == 'NorESM-L':
       lsm = [DATABASE + 'NorESM-L/NorESM-L_E280_land_sea_mask.nc',
              DATABASE + 'NorESM-L/NorESM-L_Eoi400_land_sea_mask.nc']
       fieldlsm = 'Fraction of sfc area covered by land'


    if model  == 'MRI2.3':
        lsm = [DATABASE + 'MRI-CGCM2.3/sftlf.nc', 
               DATABASE + 'MRI-CGCM2.3/sftlf.nc']
        fieldlsm = 'landsea mask [0 - 1]'


    if model  == 'GISS2.1G':
        start = '/nfs/hera1/earjcti/PLIOMIP2/GISS2.1G/'
        lsm = [start + 'e280/NASA-GISS_PIctrl_all_fland.nc',
               start + 'eoi400/NASA-GISS_PlioMIP2_all_fland.nc']
        fieldlsm = 'fland'

    if model == 'NorESM1-F':
        lsm = [DATABASE + 'NorESM1-F/NorESM1-F_E280_land_sea_mask.nc',
               DATABASE + 'NorESM1-F/NorESM1-F_Eoi400_land_sea_mask.nc']
        fieldlsm =  'Fraction of sfc area covered by land'

        
    if model == 'IPSLCM6A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM6A/'
        lsm = [start + 'sftlf_fx_IPSL-CM6A-LR_piControl_r1i1p1f1_gr.nc',
              start + 'sftlf_fx_IPSL-CM6A-LR_midPliocene-eoi400_r1i1p1f1_gr.nc']
        fieldlsm = 'land_area_fraction'

    if model == 'IPSLCM5A':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']
   

    if model == 'IPSLCM5A2':
        start = '/nfs/hera1/earjcti/PLIOMIP2/IPSLCM5A/'
        lsm = [start + 'E280_LSM_IPSLCM5A.nc',
               start + 'Eoi400_LSM_IPSLCM5A.nc']
        fieldlsm = ['Fraction ter', 'Fraction lic']

    if model == 'HadGEM3':
        start = '/nfs/hera1/pliomip2/data/HadGEM3_new/'
        lsm = [start + 'hadgem3.mask.nc', start + 'hadgem3.mask.nc']
        fieldlsm = 'land_binary_mask'
            
            
    return lsm[period], fieldlsm


def get_cru_temp(lats, lons):
    """
    get's the cru temperature at the given latitude and longitude
    """
    
    crufile = ('/nfs/hera1/earjcti/regridded/CRUTEMP/' + 
               'E280.NearSurfaceTemperature.mean_month.nc')
    cube = iris.load_cube(crufile)
    
    
    cru_min_temp = np.zeros(len(lats))
    cru_max_temp = np.zeros(len(lats))
    for i, lat in enumerate(lats):
        if lons[i] > 180.:
            lon = lons[i]-360.
        else:
            lon = lons[i]
        lat_ix = (np.abs(cube.coord('latitude').points - lat)).argmin()
        lon_ix = (np.abs(cube.coord('longitude').points - lon)).argmin()
        
   
        cru_temp = cube.data[:, lat_ix, lon_ix]
        if np.isfinite(cru_temp[0]):
            pass
        else:
            # get an average of surrounding ones
            surround = [cube.data[:, lat_ix + 1, lon_ix],
                        cube.data[:, lat_ix - 1, lon_ix],
                        cube.data[:, lat_ix, lon_ix + 1],
                        cube.data[:, lat_ix, lon_ix -1],
                        ]
            cru_temp = np.ma.mean(surround, axis=0)
            cru_max_temp[i] = np.max(cru_temp)
        cru_min_temp[i] = np.min(cru_temp)
      
     
    return cru_min_temp, cru_max_temp

###########################
def get_land_sea_mask(model, period):
    """
    the land mask is where the land_frac = 100% in both pliocene & pi
    the sea mask is where the sea_frac = 100% in both pliocene & pi
    returns land_mask and sea_mask as a cube
    """

    def get_ipsl_lsm(file, fieldnames):
        # get's the ipsl lsm which is sum of terrestrial and land ice
        cubes = iris.load(file, fieldnames)
        cube = cubes[0] + cubes[1]
        lsm_cube = cube.collapsed('time_counter', iris.analysis.MEAN)
        return lsm_cube

    def change_to_2d(cube):
        # if cube is 3d then extract the first time dimension only
        if cube.ndim == 2:
            cube_2d = cube
        else:
            cube_2d = cube[0, :, :]
       
        return cube_2d


    lsm, fieldlsm = get_lsm_names(model,period)

    ############################################
    if model == 'IPSLCM5A' or model == 'IPSLCM5A2':
        lsm_cube = get_ipsl_lsm(lsm, fieldlsm)
    elif model == 'HadGEM3':
        f = netCDF4.Dataset(lsm, "r")
        print(f.variables['longitude'])
        longitude = iris.coords.DimCoord(f.variables['longitude'], 
                             standard_name = 'longitude', units='degrees')
        latitude = iris.coords.DimCoord(f.variables['latitude'], 
                             standard_name = 'latitude', units='degrees')
        lsm_cube = iris.cube.Cube(np.squeeze(f.variables['lsm'][:]),
                             long_name='lsm', var_name='lsm', units=None, 
                             attributes=None, cell_methods=None, 
                             dim_coords_and_dims=[(latitude,0), (longitude,1)])
     
    else:
        lsm_cube = iris.util.squeeze(iris.load_cube(lsm, fieldlsm))
     
    lsm_cube2 = change_to_2d(lsm_cube)
   
   
    if model == 'IPSLCM6A':
        lsm_cube2.data = lsm_cube2.data / 100.0
       

    # regrid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsm_cube3 = lsm_cube2.regrid(cubegrid, iris.analysis.Linear())
   

    lsm_cube3.var_name = 'land_mask'
    lsm_cube3.long_name = 'land_mask'
    
    return lsm_cube3

def check_lsm(lsm_lons, lsm_lats, lsm_data, latrq, lonrq):
    """
    if our model is a sea point then set index to nan
    """

    lat_ix = (np.abs(lsm_lats - latrq)).argmin()
    lon_ix = (np.abs(lsm_lons - lonrq)).argmin()
       
    if lsm_data[lat_ix, lon_ix] <  0.5:
        # check to south, north, east, west
#        print(lsm_data[lat_ix - 1, lon_ix],lsm_data[lat_ix + 1, lon_ix],lsm_data[lat_ix, lon_ix-1],lsm_data[lat_ix, lon_ix+1], lsm_data[lat_ix - 1, lon_ix - 1],lsm_data[lat_ix + 1, lon_ix+1 ],lsm_data[lat_ix + 1, lon_ix-1],lsm_data[lat_ix-1, lon_ix+1])
#        if lsm_data[lat_ix - 1, lon_ix] >  0.5:
#            lat_ix = lat_ix -1
#        elif lsm_data[lat_ix + 1, lon_ix] >  0.5:
#            lat_ix = lat_ix + 1
#        elif lsm_data[lat_ix, lon_ix - 1] > 0.5:
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix, lon_ix + 1] > 0.5:
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix - 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix -1
#            lon_ix = lon_ix - 1
#        elif lsm_data[lat_ix + 1, lon_ix + 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix + 1
#        elif lsm_data[lat_ix + 1, lon_ix - 1] > 0.5:
#            lat_ix = lat_ix +1
#            lon_ix = lon_ix - 1
       # elif lsm_data[lat_ix, lon_ix - 2] > 0.5:
       #     lon_ix = lon_ix - 2
       # elif lsm_data[lat_ix, lon_ix + 2] > 0.5:
       #     lon_ix = lon_ix + 2
       # elif lsm_data[lat_ix, lon_ix - 3] > 0.5:
       #     lon_ix = lon_ix - 3
       # elif lsm_data[lat_ix, lon_ix + 3] > 0.5:
       #     lon_ix = lon_ix + 3
       # elif lsm_data[lat_ix - 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix -2
       # elif lsm_data[lat_ix + 2, lon_ix] > 0.5:
       #     lat_ix = lat_ix + 2
      
       
  #      else:
            lat_ix = np.nan
            lon_ix = np.nan
            
       # print('new',lsm_data[lat_ix, lon_ix], lat_ix, lon_ix, latrq, lonrq, lsm_lons[lon_ix], lsm_lats[lat_ix])
       # sys.exit(0)

            
        

    return lat_ix, lon_ix

def get_single_model(model, latreq, lonreq, period):
    """
    read in the pliocene data from 'model'  return the temperatures
    at the list of sites
    """
    # get lsm
    if period == 'E280':
        lsm_cube  = get_land_sea_mask(model, 0)
    if period == 'EOI400':
        lsm_cube  = get_land_sea_mask(model, 1)

    filename = ('/nfs/hera1/earjcti/regridded100/' + model +
                '/' + period + '.NearSurfaceTemperature.mean_month.nc')
  
    print(filename)
    plio_cube = iris.load_cube(filename)
   
    nsites = len(latreq)
    plio_minval_array = np.zeros(nsites)
    plio_maxval_array = np.zeros(nsites)

    plio_cube_lats = plio_cube.coord('latitude').points
    plio_cube_lons = plio_cube.coord('longitude').points

    lsm_cube_lats = lsm_cube.coord('latitude').points
    lsm_cube_lons = lsm_cube.coord('longitude').points
    lsm_cube_data = lsm_cube.data
   
  
    if plio_cube_lats.any() != lsm_cube_lats.any():
        print('data cube does not match lsm lat')
    if plio_cube_lats.any() != lsm_cube_lons.any():
        print('data cube does not match lsm lat')

    for i in range(0,nsites):
        # modellon is whole numbers from 0-360
        # lat is half numbers from -89.5 to 89.5

        modlon = np.around(lonreq[i])
        if modlon < 0: modlon = modlon + 360.

        (lat_ix, 
         lon_ix) = check_lsm(lsm_cube_lons, lsm_cube_lats, 
                                    lsm_cube_data, latreq[i], modlon)

        if np.isfinite(lat_ix):
            plio_array = plio_cube.data[:, lat_ix, lon_ix]
        else:
            plio_array = np.zeros(12)
            plio_array[:] = np.nan
        plio_minval_array[i] = np.min(plio_array)
        plio_maxval_array[i] = np.max(plio_array)
   
    return plio_minval_array, plio_maxval_array

def land_reformat(sitedata):
    """
    reformats the land data into different arrays
    """
    
    sites = []
    lats = []
    lons = []
    WMMT_data_min = []
    WMMT_data_max = []
    WMMT_modern_obs = []
    CMMT_data_min = []
    CMMT_data_max = []
    CMMT_modern_obs = []
    refs = []
    
    for info in sitedata:
        sites.append(info[0])
        lats.append(info[1])
        lons.append(info[2])
        WMMT_data_min.append(info[3])
        WMMT_data_max.append(info[4])
        CMMT_data_min.append(info[5])
        CMMT_data_max.append(info[6])
        WMMT_modern_obs.append(info[7])
        CMMT_modern_obs.append(info[8])
        refs.append(info[9])
   
    labels = []
    deg= u'\N{DEGREE SIGN}'
    for i, site in enumerate(sites):
  #     label = ''.join([c for c in site if c.isupper()])
        latstr = np.str(lats[i]) + deg + 'N'
        if lons[i] >180:
           lonstr = np.str((lons[i] - 360.) * -1.0) + deg +  'W'
        else:
           lonstr = np.str(lons[i]) + deg + 'E'
         
        label = site + ' (' +  latstr + ',' +  lonstr + ')'
        labels.append(site)
   
    return  (labels, lats, lons, np.asarray(WMMT_data_min),
             np.asarray(WMMT_data_max),  np.asarray(CMMT_data_min),
             np.asarray(CMMT_data_max),  np.asarray(WMMT_modern_obs),
             np.asarray(CMMT_modern_obs),refs)

 
def get_land_km5c():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle, modern obs WMMT, modern obs CMMT
    # reference and date

    # lake baikal is from what ulrich sent me.
    # Lake E from Brigette-greeme mean july temp of +8 and average winter lows of 35degC

    sitedata.append(['Lake El\'gygytgyn', 67, 172, 15.0, 16.0,
                    -36.8, -30.4, 
                     8.0, np.nan,'CMMT 3.199Ma - 3.209Ma; Pavel Tarasov (pers. comm) \n WMMT Brigham-Grette et al. 2013'])
    sitedata.append(['Lake Baikal', 56, 108, 15.28, 17.52,
                     -1.67, 1.07, 
                     15.3, -17.4,'Km5c - unpublished \n (Method of Klage et al 2020)'])
    
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_LP():
    """
    these have been obtained from various sources so I am just typing them in
    LP means late pliocene
    """
    sitedata = []
    # lake baikal is from demske 2002.
    sitedata.append(['Lake Baikal', 56, 108, 13.0, 24.0, -15, 5,
                     np.nan, np.nan,'Prior to 3.5Ma (Demske et al 2002)'])
    # these are from popova et al 2012 using coexistence approach.
  
    sitedata.append(['Mirny', 55, 82, 18.8, 24.6, -0.3, 0.7,
                     np.nan, np.nan,'Popova et al 2012'])
    sitedata.append(['Merkutlinskiy', 56, 72, 17.3, 23.8, -3.8, 6.2,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Kabinet', 55, 80, 21.6, 24.4, -4.4, 4.6,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Delyankir', 63, 133, 18.9, 24.9, -6.9, 1.3,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Chernoluche', 55, 73, 19.6, 20.3, -5.9, 0.7,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['Blizkiy', 64, 162, 15.6, 23.3, -12.8, 5.2,
                     np.nan, np.nan,' --"--'])
    sitedata.append(['42km', 55, 80, 21.6, 23.3, -4.4, 0.7,
                     np.nan, np.nan,' --"--'])
  
    sitedata.append(['Lost Chicken Mine', 64, 218, 12.0, 12.0, 
                     -2.0, -2.0, 15.3, -25.1, '2.9 +/- 0.4Ma: Ager et al. 1994'])
  
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_EP():
    """
    these have been obtained from various sources so I am just typing them in
    EP means early pliocene
    """
    sitedata = []
    # these are from popova et al 2012 using coexistence approach.
  
    sitedata.append(['Tnekveem', 66, 177, 18.9, 25.6, -11.8, 5.8, 
                     np.nan, np.nan,'Popova et al 2012'])
    sitedata.append(['Hydzhak', 63, 147, 18.8, 24.9, -8.7, 1.3,
                     np.nan, np.nan,' --"--'])

   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)

    return (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs)

def get_land_fletcher():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT data, max WMMT data,
    # min CMMT data, max CMMT data
    # modern obs WMMT, modern obs CMMT
    # we think FLB is 3.8Ma, BP originally was 3.4 but has been redated
   
    # for TF data we are reporting here temperature of warmest month
    # and temperature of warmest quater
    
    sitedata.append(['Near Meighen Island', 77.5, 261, [19.6, 12.8], 
                     [20.5, 13.3],
                    [-11.6, -6.8], [-11.4, -6.2],
                     4.1, -42.5, 'Fletcher et al. 2017'])
    sitedata.append(['Beaver Pond', 79, 278, [18.4, 12.4], [20.9, 13.1],
                     [-12.2, -7.3], [-11.5, -6.8],
                      7.1, -39.7, '3.9 +1.5 / -0.5Ma: Fletcher et al. 2017'])
    sitedata.append(['Fyles Leaf Beds', 79, 277, [19.7, 12.6], [21.1, 13.4],
                     [-12.8, -7.2], [-9.1, -5.5],
                      np.nan, np.nan, '3.8 +1/-0.7Ma: Fletcher et al. 2017'])
     
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)

def get_land_fletcher_ca():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT data, max WMMT data,
    # min CMMT data, max CMMT data
    # modern obs WMMT, modern obs CMMT
    # we think FLB is 3.8Ma, BP originally was 3.4 but has been redated
   
    # for tf data we are reporting hwere temp of warmest month and
    # warmest quater
    
    sitedata.append(['Near Meighen Island', 77.5, 261, [18.1, 10.6], 
                     [22.8, 16.2],
                    [-21.7,-16.3,], [-7.9, -2.7],
                     4.1, -42.5,'Fletcher et al. 2017'])
    sitedata.append(['Beaver Pond', 79, 278, [18.1, 11.3],[22.4, 16.3],
                     [-21.7, -15.0], [-8.1, -3.5],
                      7.1, -39.7,'3.9 +1.5 / -0.5Ma: Fletcher et al. 2017'])
    sitedata.append(['Fyles Leaf Beds', 79, 277, [18.1, 10.9], [22.7, 15.0],
                     [-16.9, -12.4], [-6.4, -2.3],
                      np.nan, np.nan,'3.8 +1/-0.7Ma: Fletcher et al. 2017'])
     
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)

def get_land_beetle():
    """
    these have been obtained from various sources so I am just typing them in
    """
    sitedata = []
    # site data is
    # sitename, sitelat, sitelon, min WMMT veg, max WMMT veg,
    # min WMMT beetle, max WMMT beetle, min CMMT veg, max CMMT veg
    # min CMMT beetle, max CMMT beetle, modern obs WMMT, modern obs CMMT

    # all were reported in Elias and Matthews
    # note Pliocene Tmin - modern Tmin varies between 2.3 degC and 20degC

    sitedata.append(['Ballast Brook', 74, 237, 
                     14.0, 14.5, -21.0, -19.5, 2.4, -41.4,'~3-5Ma: Flyes et al 1994'])
    sitedata.append(['Strathcona Beaver Peat', 79, 278, 
                     11.7, 12.2, -28.7, -27.2, 2.4, -41.4,'>3.3Ma: Matthews and Flyes 2000'])
    sitedata.append(['Near Meighen Island', 77.5, 261, 
                     11.5, 13.5, -33.0, -18.5, 4.1, -42.5,'~3Ma: Elias and Matthews 2002'])
    sitedata.append(['Lost Chicken Mine', 64, 218,  
                     13.5, 16.0, -27.75, -19.25, 15.3, -25.1,'~3Ma: Matthews and Telka 1997'])
    sitedata.append(['Bluefish', 67, 221,  
                     12.7, 15.0, -30.0, -20.5, 16.0, -29.0,'~LP: Matthews and Telka 1997'])
   
    (labels, lats, lons, WMMT_data_min, WMMT_data_max,  
     CMMT_data_min, CMMT_data_max, WMMT_modern_obs,
     CMMT_modern_obs,refs) = land_reformat(sitedata)


    
   
    return  (labels, lats, lons, WMMT_data_min,
             WMMT_data_max,  CMMT_data_min,
             CMMT_data_max,  WMMT_modern_obs,
             CMMT_modern_obs,refs)


def plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                labels,titleinfo,ystart,refs):
    """
    this subroutine tries to plot the figure for the paper which shows a nice
    DMC 
    """

    titlename = {'KM5c' : 'Near KM5c',
                 'LPCA' : 'Late Pliocene',
                 'EPCA' : 'Early Pliocene',
                 'TF-CRACLE' : 'Pliocene (Coexistence Likelihood Estimation)',
                 'TF-CA' : 'Pliocene (Coexistence Approach)',
                 'BA' : 'Beetle Assemblage data'
        }
    labelname = {0 : 'palaeodata WMMT',
                 1 : 'palaeodata CMMT',
                 2 : 'MMM WMMT',
                 3 : 'MMM CMMT'}

    WMMT_data_mean = (WMMT_data_min + WMMT_data_max) / 2.0
 
    CMMT_data_mean = (CMMT_data_min + CMMT_data_max) / 2.0
    
    ax1 = plt.axes(frameon=False)
     
    if ystart == 0:
        ax1.get_xaxis().tick_top()
        ax1.axes.get_yaxis().set_visible(False)
        ax1.set_ylim([0, 32])
        plt.gca().invert_yaxis()
        #ax.set_xlim([xmin, xmax])
      

   
    nsites=len(WMMT_data_min)
    yarray = np.arange(ystart+1.5, nsites+ystart+1, 1)
    yend=ystart+nsites
 
    # plot warm and cold month temperature anomalies

    if titleinfo[0:2] != 'TF': # tamara fletchers data was not wmmt
        ax1.hlines(y=yarray, xmin=WMMT_data_min, xmax= WMMT_data_max,color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min, xmax= CMMT_data_max,color='tab:blue')
   
        plt.scatter(WMMT_data_mean, 
                    yarray, color='tab:red', marker='^',
                    label=labelname.get(ystart,None),s=60)
        plt.scatter(CMMT_data_mean, 
                    yarray, color='tab:blue', marker='^',
                    label = labelname.get(ystart+1,None) ,s=60)
    else:
        print(WMMT_data_mean)
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,0], xmax= WMMT_data_max[:,0],color='tab:red')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,0], xmax= CMMT_data_max[:,0],color='tab:blue')
        ax1.hlines(y=yarray, xmin=WMMT_data_min[:,1], xmax= WMMT_data_max[:,1],color='tab:pink',linestyle='dashed')
        ax1.hlines(y=yarray, xmin=CMMT_data_min[:,1], xmax= CMMT_data_max[:,1],color='tab:cyan',linestyle='dashed')
        if titleinfo == 'TF-CRACLE':
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',
                        label='max T warmest month',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',
                        label =  'min T coldest month ',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',
                        label='wamest quarter T',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',
                        label =  'coldest quarter T ',s=60)
        else:
            plt.scatter(WMMT_data_mean[:,0], 
                        yarray, color='tab:red', marker='v',s=60)
            plt.scatter(CMMT_data_mean[:,0], 
                        yarray, color='tab:blue', marker='v',s=60)
            plt.scatter(WMMT_data_mean[:,1], 
                        yarray, color='tab:pink', marker='^',s=60)
            plt.scatter(CMMT_data_mean[:,1], 
                        yarray, color='tab:cyan', marker='^',s=60)

    # put an arrow on LCM
    for i, label in enumerate(labels):
        if label[0:4] == 'Lost' and i > 4:
            plt.arrow(CMMT_data_max[i], yarray[i], -10, 0, linestyle='dotted', 
                  color='tab:blue', head_width=0.2, head_length=1.0)
   
    # try plotting axis
  
    for j in range(0, nsites):
        plt.text(-40.0, yarray[j], labels[j], ha='right')
#        if ystart == 0:
#            plt.text(27.0, yarray[j], refs[j], ha='left')
#        else:
#            plt.text(35.0, yarray[j], refs[j], ha='left')

     

    
    plt.scatter(mmm_WMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_WMT, yarray + 0.2, color='tab:red', 
                s=25, label=labelname.get(ystart+2,None))
    plt.scatter(mmm_CMT, yarray + 0.2, color='black', s=60)
    plt.scatter(mmm_CMT, yarray + 0.2, color='tab:blue', 
                s=25, label=labelname.get(ystart+3,None))
  
  
    # plot individual models for pliocene
    for i in range(0, len(MODELNAMES)):
        if i == 0 and ystart==0:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x', s=15, label='models WMMT')
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15, label='models CMMT')
        else:
            plt.scatter(all_models_plio_WMT[:, i], yarray+0.2, color='tab:red', 
                        marker = 'x',s=15)
            plt.scatter(all_models_plio_CMT[:, i], yarray+0.2, color='tab:blue', 
                        marker = 'x', s=15)
        
    plt.hlines(y=ystart, xmin=-50., xmax=30., linewidth=0.5)
    plt.text(-30.0, -1.75, 'Cold Month Temperature (degC)', ha='left', color='tab:blue',fontsize=12)
    plt.text(5.0, -1.75, 'Warm Month Temperature (deg C)', ha='left', color='tab:red',fontsize=12)
    plt.text(-35.0,ystart+0.5,titlename.get(titleinfo),fontsize=12)
       
    
    #plt.legend(bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=3,
    #               prop = {'size':12})
    if ystart > 23:
        handles, labels = plt.gca().get_legend_handles_labels()
        order = [2, 3, 4, 5, 0,6,8,1,7,9]
        print(labels)
        print(ystart)
        plt.legend([handles[idx] for idx in order],
                   [labels[idx] for idx in order],
               bbox_to_anchor=(0.5, -0.04), loc='lower center', ncol=3,
               prop = {'size':12})
   
   
 
    return ax1,yend+2

  
def get_model_data(land_lats, land_lons):
    """
    get the model data for these latitude and longitudes
    """
    
    all_models_plio_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_plio_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_WMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_pi_CMT = np.zeros((len(land_lons), len(MODELNAMES)))
    all_models_seas_cyc_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_CMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    all_models_WMMT_anom = np.zeros((len(land_lons),len(MODELNAMES)))
    for i, model in enumerate(MODELNAMES):
        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'EOI400')
        all_models_plio_WMT[:, i] = ind_WMT
        all_models_plio_CMT[:, i] = ind_CMT

        (ind_CMT, ind_WMT) = get_single_model(model, land_lats, 
                                              land_lons, 'E280')
        all_models_pi_WMT[:, i] = ind_WMT
        all_models_pi_CMT[:, i] = ind_CMT

        all_models_seas_cyc_anom[:, i] = (
            (all_models_plio_WMT[:, i] - all_models_plio_CMT[:, i]) -
            (all_models_pi_WMT[:, i] - all_models_pi_CMT[:, i]))
        
        all_models_CMMT_anom[:, i] = (all_models_plio_CMT[:, i] -
                                      all_models_pi_CMT[:, i])

        all_models_WMMT_anom[:, i] = (all_models_plio_WMT[:, i] -
                                      all_models_pi_WMT[:, i])



    mmm_WMT = np.nanmean(all_models_plio_WMT, axis=1)
    mmm_CMT = np.nanmean(all_models_plio_CMT, axis=1)
    mmm_WMT_pi = np.nanmean(all_models_pi_WMT, axis=1)
    mmm_CMT_pi = np.nanmean(all_models_pi_CMT, axis=1)


    return  (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom, 
     all_models_WMMT_anom, mmm_WMT, mmm_CMT, mmm_WMT_pi, mmm_CMT_pi)

def main():
    """
    calling structure
    a) get's model data
    b) get's proxy data
    c) plots model data with proxy data on top
    d) plots change in seasonal cycle at MI, BP and LB
    """

   
    # get land observations and cru temperature at km5c points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_km5c()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)


   
    fig1 = plt.figure(figsize=[11.7, 11.7])
  
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'KM5c',0,refs)

   
    #####################################################################
    # get land observations and cru temperature at lp points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_LP()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'LPCA',ystart,refs)
   
   
    #####################################################################
    # get land observations and cru temperature at ep points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_EP()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)


   

    # plot data
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'EPCA',ystart,refs)
   

    ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_fletcher()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'TF-CRACLE',ystart,refs)

     ####################################################################
    # get land observations and cru temperature at early pliocene points 
    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
     CMMT_data_min, CMMT_data_max, 
     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_fletcher_ca()

    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
    (all_models_plio_WMT, all_models_plio_CMT,
     all_models_pi_WMT, all_models_pi_CMT, 
     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

    for i,site in enumerate(sites):
        print('warm',site, WMMT_data_min[i], WMMT_data_max[i],mmm_WMT[i])
        print('cold',site, CMMT_data_min[i], CMMT_data_max[i],mmm_CMT[i])
        print(' ')
 #       for j, model in enumerate(MODELNAMES):
 #           print(model, all_models_plio_CMT[i,j], all_models_plio_CMT[i,j] - all_models_plio_CMT[1,j])
  #  sys.exit(0)

  
    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
                CMMT_data_min, CMMT_data_max, 
                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
                sites,'TF-CA',ystart,refs)



     ####################################################################
    # get land observations and cru temperature at early pliocene points 
#    (sites, land_lats, land_lons, WMMT_data_min, WMMT_data_max,
#     CMMT_data_min, CMMT_data_max, 
#     WMMT_modern_obs, CMMT_modern_obs,refs) =  get_land_beetle()

#    cru_min_temp, cru_max_temp = get_cru_temp(land_lats, land_lons)
#    (all_models_plio_WMT, all_models_plio_CMT,
#     all_models_pi_WMT, all_models_pi_CMT, 
#     all_models_CMMT_anom,  all_models_WMMT_anom,  mmm_WMT, mmm_CMT, 
#     mmm_WMT_pi, mmm_CMT_pi) = get_model_data(land_lats, land_lons)

    # plot data

#    ax1,ystart = plot_figure(WMMT_data_min, WMMT_data_max, 
#                CMMT_data_min, CMMT_data_max, 
#                all_models_plio_WMT, all_models_plio_CMT, mmm_WMT, mmm_CMT,
#                sites,'BA',ystart,refs)
#    ax1.set_ylim(None,0)    
    

    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
               'vegetation/seasonal_dmc_plot_v2.eps')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2.pdf')
    plt.savefig(fileout)
    fileout = ('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/' + 
                   'vegetation/seasonal_dmc_plot_v2.png')
    plt.savefig(fileout)
    plt.close()

 
##########################################################
# main program


LINUX_WIN = 'l'
FILESTART = '/nfs/hera1/earjcti/'
DATABASE = '/nfs/hera1/pliomip2/data/'

MODELNAMES = [
               'HadGEM3', 'CESM2',
              'IPSLCM6A', 
              'COSMOS', 
              'EC-Earth3.3', 'CESM1.2', 'IPSLCM5A',
              'MIROC4m', 'IPSLCM5A2', 'HadCM3',
              'GISS2.1G', 
               'CCSM4', 
              'CCSM4-Utr', 'CCSM4-UoT', 
              'NorESM-L',  'NorESM1-F'
           #  ,  'MRI2.3'
              ]

#MODELNAMES = ['IPSLCM6A']

NSAT_MMM_FILE = (FILESTART + 
                 'regridded100/NearSurfaceTemperature_multimodelmean.nc')

LAND_DATAFILE = ('/nfs/hera1/earjcti/PLIOMIP2/proxydata/' + 
                 'PlioceneTerrestrial_IPCCAR6.xlsx')

main()

#sys.exit(0)
::::::::::::::
setup_biome4_inputfiles_HadCM3_pre2023.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will create the input files for biome4 for each 'regridded' model or the multimodel mean

This was altered in November 2021 to do BIOME4 for a HadCM3 sensitivity study

"""

import numpy as np
import iris
import iris.quickplot as qplt
import matplotlib.pyplot as plt
import sys
import warnings
warnings.filterwarnings("ignore")



def get_cube_avg(expt, long_name, units, long_name_req):
    """
    loads in renames and reformats that cube
    """
    monthnames = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
#    monthnames = ['ja','fb']

    allmonths_cubes = iris.cube.CubeList([])
    for i, month in enumerate(monthnames):
        cubes = iris.cube.CubeList([])

        for year in range(STARTYEAR,ENDYEAR):
            filename = (FILESTART + expt + '/netcdf/' + expt + 
                        'a@pdk' + np.str(year) + month + '.nc')
            indcube = iris.load_cube(filename, long_name)
            indcube.coord('t').points = year
           
            cubes.append(indcube)
        iris.util.equalise_attributes(cubes)
        iris.util.unify_time_units(cubes)
        cube = cubes.concatenate_cube()
        monthcube = cube.collapsed('t', iris.analysis.MEAN)
        
        if monthcube.coord('t') != None:
            monthcube.remove_coord('t')
        nmoncube = iris.util.new_axis(monthcube)
        nmoncube.add_dim_coord(iris.coords.DimCoord(i+1, 
                standard_name='time', long_name='t', 
                var_name='t', 
                units=None,
                bounds=None,
                coord_system=None, circular=False),0)
       
        nmoncube.cell_methods=None
       
        allmonths_cubes.append(nmoncube)

    iris.util.equalise_attributes(allmonths_cubes)
    iris.util.unify_time_units(allmonths_cubes)
  
    monthscube = allmonths_cubes.concatenate_cube()
    monthscube.coord('longitude').rename('lon')
    monthscube.coord('latitude').rename('lat')
    #'monthscube.coord('t').rename('time')
    monthscube.long_name = long_name_req
    monthscube.units = units
  
    return monthscube

def get_anom(field, plio_cube, pi_cube):
    """
    gets the standard data from biome 4 and regrids it onto our grid
    """
    filename = ('/nfs/see-fs-02_users/earjcti/BIOME4/'+
                'biome4_pliomip2/inputdata.nc')
    cube = iris.load_cube(filename, field)
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
    
    biomecube = cube.regrid(cubegrid, iris.analysis.Nearest())
    iris.util.squeeze(biomecube)
    sq_plio = iris.util.squeeze(plio_cube)
    sq_pi = iris.util.squeeze(pi_cube)
    biomecube_data = biomecube.data
    
    anomdata = sq_plio.data - sq_pi.data + biomecube_data  
    if field[0:4] != 'soil':
        anom_data = np.ma.masked_array(anomdata, biomecube.data.mask) 
    else:
        print('here')
        cubes = iris.load(filename)
        print(cubes)
        cubetemp = iris.load_cube(filename, 
                                  'annual absolute mimimum temperature')
        biomecube2 = cubetemp.regrid(cubegrid, iris.analysis.Nearest())
        biomearr3 = np.zeros((2,) +  np.shape(biomecube2.data))
        biomearr3[0, :, :] = biomecube2.data.mask
        biomearr3[1, :, :] = biomecube2.data.mask
        anom_datat = np.where(biomecube_data >= 0, anomdata, sq_plio.data)
        anom_data = np.ma.masked_array(anom_datat, biomearr3)          
    

    
    if (field == 'monthly total precipitation'
        or field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.ma.where(anom_data > 0, anom_data, 0.0)
    if (field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.ma.where(anom_data < 1000, anom_data, 1000.0)
   
    mpwp_anomcube = sq_plio.copy(data=anom_data)
    
    return mpwp_anomcube

    

def get_temp_precip():
    """
    get temperature and precipitation data in correct units
    plio_cube is from pliocene data
    anom_cube is model_plio - model_pi + observed_pi
    """
    allcubes_plio = iris.cube.CubeList([])
    allcubes_anom = iris.cube.CubeList([])

    # temperature
    cube = get_cube_avg(EXPTNAME, 'TEMPERATURE AT 1.5M', 'degC', 
                        'monthly mean temperature')
       
    cube.data = cube.data * 10.0
    allcubes_plio.append(cube)

    pi_cube = get_cube_avg(PI_EXPT, 'TEMPERATURE AT 1.5M', 'degC', 
                           'monthly mean temperature')
    pi_cube.data = pi_cube.data * 10.0

    anom_cube = get_anom('monthly mean temperature', cube, pi_cube)
    allcubes_anom.append(anom_cube)
  
    # get minimum temperature from the pliocene and the anomaly method
    print(cube)
    mintemp = cube.collapsed('time', iris.analysis.MIN)
    mintemp.long_name = 'annual absolute minimum temperature'
    mintemp.short_name = 'tmin'
    mintemp.units = 'degC'
    mintemp.remove_coord('time')
    #mintemp.remove_coord('surface')

    mintemp_anom = anom_cube.collapsed('time', iris.analysis.MIN)
    mintemp_anom.long_name = 'annual absolute minimum temperature'
    mintemp_anom.short_name = 'tmin'
    mintemp_anom.units = 'degC'
    mintemp_anom.remove_coord('time')
    #mintemp_anom.remove_coord('surface')
   


    # precipitation
    cube = get_cube_avg(EXPTNAME,'TOTAL PRECIPITATION RATE     KG/M2/S', 'mm',
                         'monthly total precipitation')
    cube.data = cube.data * 30.0
    allcubes_plio.append(cube)

    pi_cube = get_cube_avg(PI_EXPT,'TOTAL PRECIPITATION RATE     KG/M2/S', 'mm',
                         'monthly total precipitation')
    pi_cube.data = pi_cube.data * 30.0

    anom_cube = get_anom('monthly total precipitation', cube, pi_cube)
    allcubes_anom.append(anom_cube)

       
    return allcubes_plio, mintemp, allcubes_anom, mintemp_anom
    
def get_sunshine():
    """
    gets mean monthly percent of possible sunshine.  Steve P and James did
    this by:
    1. get pd total cloud (this is field30)
    2. multiplies this by -1 to get negative total cloud
    3. adds 1 to get total sun.
    4. multiplies by 1000 to get biome units.
    """

    # mPWP
    cube_mPWP = get_cube_avg(EXPTNAME, 'TOTAL CLOUD AMOUNT - RANDOM OVERLAP',
                             'percent', 
                             'mean monthly percent of possible sunshine')
    cube_mPWP.short_name = 'sun'
    cube_mPWP.data = cube_mPWP.data / 100.
    cube_mPWP.data = (cube_mPWP.data * (-1.0) + 1.0) * 1000.

    # PI
    cube_PI = get_cube_avg(PI_EXPT, 'TOTAL CLOUD AMOUNT - RANDOM OVERLAP',
                           'percent', 
                           'mean monthly percent of possible sunshine')
    cube_PI.data = cube_PI.data / 100.
  
    cube_PI.short_name = 'sun'
    cube_PI.data = (cube_PI.data * (-1.0) + 1.0) * 1000.

    # find anomaly from observations
    cube_anom = get_anom('mean monthly percent of possible sunshine',
                         cube_mPWP, cube_PI)
    
  
    return cube_mPWP, cube_anom
  
    

def get_soils():
    """
    gets the soils for input to biome4
    input cubegrid: the grid to put the soils on
    """

    def process_soils(filename):
        """
        processes each file for the soils
        """

        cube = iris.load_cube(filename)
        cube.attributes["missing_value"] = -9999

        # temporarily change sea points to average because we
        # will be adding a lsm later

        cube_data = cube.data
        avg_data = np.mean(cube_data)
        newcube_data = np.where(cube_data.mask, avg_data, cube_data)
        cube_full = cube.copy(data = newcube_data) 

        return cube_full

    
    # get grid
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
    

    # get mPWP

    file_soils_mPWP = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                       'PRISM3_soil_alternative_whc.nc')
    soil_whc_cube_mPWP = process_soils(file_soils_mPWP)

    file_perc_mPWP = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                      'PRISM3_soil_alternative_perc.nc')
    soil_perc_cube_mPWP = process_soils(file_perc_mPWP)
  


    # get PI

    file_soils_PI = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                       'MODERN_soil_alternative_whc.nc')
    soil_whc_cube_PI = process_soils(file_soils_mPWP)

    file_perc_PI = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                      'MODERN_soil_alternative_perc.nc')
    soil_perc_cube_PI = process_soils(file_perc_mPWP)
  
    # get anomaly

  
    whc_anom_cube = get_anom('soil water holding capacity',
                         soil_whc_cube_mPWP, soil_whc_cube_PI)
    
    perc_anom_cube = get_anom('soil water percolation index',
                         soil_perc_cube_mPWP, soil_perc_cube_PI)

 
    return (soil_whc_cube_mPWP, soil_perc_cube_mPWP, 
            whc_anom_cube, perc_anom_cube)

def apply_lsm(cubelist):
    """
    apply a lsm to the cubes
    """

# NOTE THE MASK IS NOT ON THE SAME GRID AS THE DATA

    masked_cubelist = iris.cube.CubeList([])
    lsm = '/nfs/hera1/earjcti/PlioMIP2_Boundary_conds/Plio_enh/Plio_enh/Plio_enh_LSM_v1.0.nc'
    lsmcube_temp = iris.load_cube(lsm)
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
   

    lsmcube = lsmcube_temp.regrid(cubegrid, iris.analysis.Linear())

    
    for cube in cubelist:
        print(np.shape(cube.data),np.shape(lsmcube.data))
        newcube_data = np.ma.where(lsmcube.data == 0, -9999, cube.data)
        newcube = cube.copy(data = newcube_data)
        masked_cubelist.append(newcube)
        print(newcube.data)
            
   
    return masked_cubelist


def main():
    """
    driver for program to get biome4 intput field
    """

    print('GETTING TEMP AND PRECIP')
    (allcubes_plio, abs_min_cube_plio,
     allcubes_anom, abs_min_cube_anom) = get_temp_precip()

    print('GETTING SUNSHINE')
    suncube_plio, suncube_anom = get_sunshine()
    allcubes_plio.append(suncube_plio)
    allcubes_anom.append(suncube_anom)

    print('GETTING SOIL')
    (soil_whc_plio, soil_perc_plio,
     soil_whc_anom, soil_perc_anom)= get_soils()

    allcubes_plio.append(soil_whc_plio)
    allcubes_plio.append(soil_perc_plio)
    allcubes_anom.append(soil_whc_anom)
    allcubes_anom.append(soil_perc_anom)

    allcubes_plio.append(abs_min_cube_plio)
    allcubes_anom.append(abs_min_cube_anom)
                                  # following SPickering this is monthly
                                  # mean minimum not absolute minimum
                                  # best to run in anomaly mode.
#    allcubes_land_plio = apply_lsm(allcubes_plio)
  
    print('saving',OUTFILE)
    iris.save(allcubes_plio,OUTFILE + 'absolute.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  


    allcubes_land_anom = apply_lsm(allcubes_anom)
    iris.save(allcubes_anom,OUTFILE + 'anomaly.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    #iris.save(allcubes_anom,OUTFILE + 'allanomaly.nc', 
    #          netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    
 

FILESTART = '/nfs/hera1/earjcti/um/'
EXPTNAME = 'xozzh'
PI_EXPT = 'xozza'
STARTYEAR = 40
ENDYEAR=60
OUTFILE = FILESTART + EXPTNAME + '/biome4/inputdata_'

main()
::::::::::::::
setup_biome4_inputfiles_HadCM3.py
::::::::::::::
!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will create the input files for biome4 for each 'regridded' model or the multimodel mean

This was altered in November 2021 to do BIOME4 for a HadCM3 sensitivity study

"""

import numpy as np
import iris
import iris.quickplot as qplt
import matplotlib.pyplot as plt
import sys
import warnings
warnings.filterwarnings("ignore")


def get_cube_avg(expt, long_name, units, long_name_req):
    """
    loads in renames and reformats that cube
    """
    monthnames = ['ja','fb','mr','ar','my','jn','jl','ag','sp','ot','nv','dc']
#    monthnames = ['ja','fb']

    allmonths_cubes = iris.cube.CubeList([])
    for i, month in enumerate(monthnames):
        cubes = iris.cube.CubeList([])

        for year in range(STARTYEAR,ENDYEAR):
            filename = (FILESTART + expt + '/pd/' + expt + 
                        'a@pdp' + np.str(year) + month + '.nc')
            indcube = iris.load_cube(filename, long_name)
            indcube.coord('t').points = year
           
            cubes.append(indcube)

        iris.util.equalise_attributes(cubes)
        iris.util.unify_time_units(cubes)
        cube = cubes.concatenate_cube()
        
        monthcube = cube.collapsed('t', iris.analysis.MEAN)
        
        if monthcube.coord('t') != None:
            monthcube.remove_coord('t')
        nmoncube = iris.util.new_axis(monthcube)
        nmoncube.add_dim_coord(iris.coords.DimCoord(i+1, 
                standard_name='time', long_name='t', 
                var_name='t', 
                units=None,
                bounds=None,
                coord_system=None, circular=False),0)
       
        nmoncube.cell_methods=None
       
        allmonths_cubes.append(nmoncube)

    iris.util.equalise_attributes(allmonths_cubes)
    iris.util.unify_time_units(allmonths_cubes)
  
    monthscube = allmonths_cubes.concatenate_cube()
    monthscube.coord('longitude').rename('lon')
    monthscube.coord('latitude').rename('lat')
    try:
        monthscube.coord('t').rename('time')
    except:
        pass
    monthscube.long_name = long_name_req
    monthscube.units = units
    print(monthscube)

    # setup missing data attribute
    monthscube.attributes["missing_value"] = -9999.
    #monthscube.attributes["scale_factor"] = "0.0"
    #monthscube.attributes["add_offset"] = "0.0"
    print(monthscube)

    # get rid of superflous dimensions
    outcube = iris.util.squeeze(monthscube)

    return outcube

def get_anom(field, plio_cube, pi_cube):
    """
    gets the standard data from biome 4 and regrids it onto our grid
    """
    filename = ('/nfs/see-fs-02_users/earjcti/BIOME4/'+
                'biome4_pliomip2/inputdata.nc')
    cube = iris.load_cube(filename, field)

    if (field == 'monthly mean temperature'
    or field == 'mean monthly percent of possible sunshine'):
     # divide by 10 because it was in the wrong units in the original file
        cube = cube / 10.


    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
    
    biomecube = cube.regrid(cubegrid, iris.analysis.Nearest())
    iris.util.squeeze(biomecube)
    sq_plio = iris.util.squeeze(plio_cube)
    sq_pi = iris.util.squeeze(pi_cube)
    biomecube_data = biomecube.data
    
    anomdata = sq_plio.data - sq_pi.data + biomecube_data  
    if field[0:4] != 'soil':
        anom_data = np.ma.masked_array(anomdata, biomecube.data.mask) 
    else:
        print('here')
        cubes = iris.load(filename)
        print(cubes)
        cubetemp = iris.load_cube(filename, 
                                  'annual absolute mimimum temperature')
        biomecube2 = cubetemp.regrid(cubegrid, iris.analysis.Nearest())
        biomearr3 = np.zeros((2,) +  np.shape(biomecube2.data))
        biomearr3[0, :, :] = biomecube2.data.mask
        biomearr3[1, :, :] = biomecube2.data.mask
        anom_datat = np.where(biomecube_data >= 0, anomdata, sq_plio.data)
        anom_data = np.ma.masked_array(anom_datat, biomearr3)          
    

    
    if (field == 'monthly total precipitation'
        or field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.ma.where(anom_data > 0, anom_data, 0.0)
    if (field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.ma.where(anom_data < 100, anom_data, 100.0)
   
    mpwp_anomcube = sq_plio.copy(data=anom_data)
    
    return mpwp_anomcube

    

def get_temp_precip():
    """
    get temperature and precipitation data in correct units
    plio_cube is from pliocene data
    anom_cube is model_plio - model_pi + observed_pi
    """
    allcubes_plio = iris.cube.CubeList([])
    allcubes_anom = iris.cube.CubeList([])

    # temperature
    cube = get_cube_avg(EXPTNAME, 'TEMPERATURE AT 1.5M', 'degC', 
                        'monthly mean temperature')
    cube.data = cube.data - 273.15 # convert to celcius
    allcubes_plio.append(cube)

    pi_cube = get_cube_avg(PI_EXPT, 'TEMPERATURE AT 1.5M', 'degC', 
                           'monthly mean temperature')
    pi_cube.data = pi_cube.data - 273.15
    anom_cube = get_anom('monthly mean temperature', cube, pi_cube)
    allcubes_anom.append(anom_cube)
  
    # get minimum temperature from the pliocene and the anomaly method
    print(cube)
    mintemp = cube.collapsed('time', iris.analysis.MIN)
    mintemp.long_name = 'annual absolute minimum temperature'
    mintemp.short_name = 'tmin'
    mintemp.units = 'degC'
    mintemp.remove_coord('time')
    #mintemp.remove_coord('surface')

    mintemp_anom = anom_cube.collapsed('time', iris.analysis.MIN)
    mintemp_anom.long_name = 'annual absolute minimum temperature'
    mintemp_anom.short_name = 'tmin'
    mintemp_anom.units = 'degC'
    mintemp_anom.remove_coord('time')
    #mintemp_anom.remove_coord('surface')
   


    # precipitation
    cube = get_cube_avg(EXPTNAME,'TOTAL PRECIPITATION RATE     KG/M2/S', 'mm',
                         'monthly total precipitation')
    # convert to mm/month multiply by (60. * 60. * 24. * 30)
    cube.data = cube.data * 60. * 60. * 24. * 30.
    allcubes_plio.append(cube)

    pi_cube = get_cube_avg(PI_EXPT,'TOTAL PRECIPITATION RATE     KG/M2/S', 'mm',
                         'monthly total precipitation')
    pi_cube.data = pi_cube.data * 60. * 60. * 24. * 30.

    anom_cube = get_anom('monthly total precipitation', cube, pi_cube)
    allcubes_anom.append(anom_cube)

       
    return allcubes_plio, mintemp, allcubes_anom, mintemp_anom
    
def get_sunshine():
    """
    gets mean monthly percent of possible sunshine.  Steve P and James did
    this by:
    1. get pd total cloud (this is field30)
    2. multiplies this by -1 to get negative total cloud
    3. adds 1 to get total sun.
    4. multiplies by 100 to get percentage
    """

    # mPWP
    cube_mPWP = get_cube_avg(EXPTNAME, 'TOTAL CLOUD AMOUNT - RANDOM OVERLAP',
                             'percent', 
                             'mean monthly percent of possible sunshine')
    cube_mPWP.attributes["name"] = 'sun'
    cube_mPWP.long_name = 'cloud amount (inverse)'
    cube_mPWP.rename('sun')
    cube_mPWP.data = (cube_mPWP.data * (-1.0) + 1.0) * 100.
    print(cube_mPWP.data)
    #sys.exit(0)

    # PI
    cube_PI = get_cube_avg(PI_EXPT, 'TOTAL CLOUD AMOUNT - RANDOM OVERLAP',
                           'percent', 
                           'mean monthly percent of possible sunshine')
    cube_PI.data = (cube_PI.data * (-1.0) + 1.0) * 100.
    cube_PI.attributes["name"] = 'cld'
    cube_PI.long_name = 'cloud amount (inverse)'  
    cube_PI.attributes["name"] = 'cld'  

    # find anomaly from observations
    cube_anom = get_anom('mean monthly percent of possible sunshine',
                         cube_mPWP, cube_PI)
    
  
    return cube_mPWP, cube_anom
  
    

def get_soils():
    """
    gets the soils for input to biome4
    input cubegrid: the grid to put the soils on
    """

    def process_soils(filename):
        """
        processes each file for the soils
        """

        cube = iris.load_cube(filename)
        cube.attributes["missing_value"] = -9999

        # temporarily change sea points to average because we
        # will be adding a lsm later

        cube_data = cube.data
        avg_data = np.mean(cube_data)
        newcube_data = np.where(cube_data.mask, avg_data, cube_data)
        cube_full = cube.copy(data = newcube_data) 

        return cube_full

    
    # get grid
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
    

    # get mPWP

    file_soils_mPWP = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                       'PRISM3_soil_alternative_whc.nc')
    soil_whc_cube_mPWP = process_soils(file_soils_mPWP)

    file_perc_mPWP = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                      'PRISM3_soil_alternative_perc.nc')
    soil_perc_cube_mPWP = process_soils(file_perc_mPWP)
  


    # get PI

    file_soils_PI = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                       'MODERN_soil_alternative_whc.nc')
    soil_whc_cube_PI = process_soils(file_soils_mPWP)

    file_perc_PI = ('/nfs/hera2/scripts/BIOME4/reference/' + 
                      'MODERN_soil_alternative_perc.nc')
    soil_perc_cube_PI = process_soils(file_perc_mPWP)
  
    # get anomaly

  
    whc_anom_cube = get_anom('soil water holding capacity',
                         soil_whc_cube_mPWP, soil_whc_cube_PI)
    
    perc_anom_cube = get_anom('soil water percolation index',
                         soil_perc_cube_mPWP, soil_perc_cube_PI)

 
    return (soil_whc_cube_mPWP, soil_perc_cube_mPWP, 
            whc_anom_cube, perc_anom_cube)

def apply_lsm(cubelist):
    """
    apply a lsm to the cubes
    """

# NOTE THE MASK IS NOT ON THE SAME GRID AS THE DATA

    masked_cubelist = iris.cube.CubeList([])
    lsm = '/nfs/hera1/earjcti/PlioMIP2_Boundary_conds/Plio_enh/Plio_enh/Plio_enh_LSM_v1.0.nc'
    lsmcube_temp = iris.load_cube(lsm)
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/ancil/P4_enh/P4_enh_qrparm.mask.nc', 'LAND MASK (LOGICAL: LAND=TRUE)')
   

    lsmcube = lsmcube_temp.regrid(cubegrid, iris.analysis.Linear())

    
    for cube in cubelist:
        print(np.shape(cube.data),np.shape(lsmcube.data))
        newcube_data = np.ma.where(lsmcube.data == 0, -9999, cube.data)
        newcube = cube.copy(data = newcube_data)
        masked_cubelist.append(newcube)
        print(newcube.data)
            
   
    return masked_cubelist


def main():
    """
    driver for program to get biome4 intput field
    """

    print('GETTING TEMP AND PRECIP')
    (allcubes_plio, abs_min_cube_plio,
     allcubes_anom, abs_min_cube_anom) = get_temp_precip()

    print('GETTING SUNSHINE')
    suncube_plio, suncube_anom = get_sunshine()
    allcubes_plio.append(suncube_plio)
    allcubes_anom.append(suncube_anom)

    print('GETTING SOIL')
    (soil_whc_plio, soil_perc_plio,
     soil_whc_anom, soil_perc_anom)= get_soils()

    allcubes_plio.append(soil_whc_plio)
    allcubes_plio.append(soil_perc_plio)
    allcubes_anom.append(soil_whc_anom)
    allcubes_anom.append(soil_perc_anom)

    #allcubes_plio.append(abs_min_cube_plio)
    #allcubes_anom.append(abs_min_cube_anom)
                                  # following SPickering this is monthly
                                  # mean minimum not absolute minimum
                                  # best to run in anomaly mode.
#    allcubes_land_plio = apply_lsm(allcubes_plio)
  
    print('saving',OUTFILE)
    allcubes_plio_land = apply_lsm(allcubes_plio)
    iris.save(allcubes_plio_land,OUTFILE + 'absolute.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  


    allcubes_land_anom = apply_lsm(allcubes_anom)
    iris.save(allcubes_anom,OUTFILE + 'anomaly.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    #iris.save(allcubes_anom,OUTFILE + 'allanomaly.nc', 
    #          netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    
 

#####################################################################

FILESTART = '/nfs/hera1/earjcti/um/'
EXPTNAME = 'xozzb'
PI_EXPT = 'xozza'
STARTYEAR = 70
ENDYEAR=100
OUTFILE = FILESTART + EXPTNAME + '/biome4/inputdata_'

main()
::::::::::::::
setup_biome4_inputfiles_MMM.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will create the input files for biome4 for each 'regridded' model or the multimodel mean

"""

import numpy as np
from iris.experimental.equalise_cubes import equalise_attributes
import iris
import sys


def cube_reformat(fileend, field, long_name, units):
    """
    loads in renames and reformats that cube
    """
    print(FILESTART, fileend)
    filename = (FILESTART + fileend)
    print(filename, field)
    cube = iris.load_cube(filename, field)
    #cube.remove_coord('time')
    #cube.remove_coord('year')
    cube.coord('longitude').rename('lon')
    cube.coord('latitude').rename('lat')
    #cube.coord('month').rename('time')
    cube.long_name = long_name
    cube.short_name = None
    cube.var_name = None
    cube.standard_name = None
    cube.units = units
    return cube


def cube_cloud(modelnames, fileend,long_name, units):
    """
    loads in renames and reformats that cube
    """

  
    for i, model in enumerate(modelnames):
        filename = (FILESTART + model + fileend)
        cube = iris.load_cube(filename)
        cube.remove_coord('time')
        cube.remove_coord('year')
        cube.coord('longitude').rename('lon')
        cube.coord('latitude').rename('lat')
        cube.coord('month').rename('time')

        for coord in cube.coords():
            coord.points = coord.points.astype('float32')
            coord.bounds = None
            coord.attributes = None
        cube.data = cube.data.astype('float32')

        cube.long_name = long_name
        cube.var_name = None
        cube.standard_name = None
        cube.cell_methods = None
   
        cube.units = units
        if model != 'HadCM3':
            cube.data = cube.data / 100.
        cube.data = (cube.data * (-1.0) + 1.0) * 1000.
        cube.attributes = None

        if i==0:
            cubedata = cube.data
            count = 1
        else:
            cubedata = cubedata + cube.data
            count = count + 1
        
  
    meandata = cubedata / count
   
    meancube = cube.copy(data = meandata)
    meancube.short_name = 'sun'
      

    return meancube

def get_anom(field, plio_cube, pi_cube):
    """
    gets the standard data from biome 4 and regrids it onto our grid
    """
    filename = ('/nfs/see-fs-02_users/earjcti/BIOME4/'+
                'biome4_pliomip2/inputdata.nc')
    cube = iris.load_cube(filename, field)
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    
    biomecube = cube.regrid(cubegrid, iris.analysis.Linear())
    biomecube_data = biomecube.data
    
    anom_data = np.where(biomecube_data.mask, 
                         plio_cube.data,
                         plio_cube.data - pi_cube.data + biomecube.data)

    if (field == 'monthly total precipitation'
        or field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.where(anom_data > 0, anom_data, 0.0)
    if (field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.where(anom_data < 1000, anom_data, 1000.0)
   
    mpwp_anomcube = plio_cube.copy(data=anom_data)
   
    return mpwp_anomcube

    

def get_temp_precip():
    """
    get temperature and precipitation data in correct units
    plio_cube is from pliocene data
    anom_cube is model_plio - model_pi + observed_pi
    everything is from the multimodel mean
    """
    allcubes_plio = iris.cube.CubeList([])
    allcubes_anom = iris.cube.CubeList([])

    # temperature
    cube = cube_reformat('/NearSurfaceTemperature_multimodelmean_month.nc',
                         'NearSurfaceTemperaturemean_plio', 
                         'monthly mean temperature','degC')
    cube.data = cube.data * 10.0
    cube.var_name = 'tas'
   
    allcubes_plio.append(cube)

    pi_cube = cube_reformat('/NearSurfaceTemperature_multimodelmean_month.nc',
                         'NearSurfaceTemperaturemean_pi', 
                          'monthly mean temperature','degC')
    pi_cube.data = pi_cube.data * 10.0
    pi_cube.var_name = 'tas'

    anom_cube = get_anom('monthly mean temperature', cube, pi_cube)
    allcubes_anom.append(anom_cube)


    # get minimum temperature from the pliocene and the anomaly method
    mintemp = cube.collapsed('time', iris.analysis.MIN)
    mintemp.long_name = 'annual absolute minimum temperature'
    mintemp.var_name = 'tas_0'
    mintemp.units = 'degC'
    mintemp.remove_coord('time')
    #mintemp.remove_coord('surface')

    mintemp_anom = anom_cube.collapsed('time', iris.analysis.MIN)
    mintemp_anom.long_name = 'annual absolute minimum temperature'
    mintemp_anom.var_name = 'tas_0'
    mintemp_anom.units = 'degC'
    mintemp_anom.remove_coord('time')
    #mintemp_anom.remove_coord('surface')
   


    # precipitation
    cube = cube_reformat('TotalPrecipitation_multimodelmean_month.nc',
                         'TotalPrecipitationmean_plio',
                         'monthly total precipitation', 'mm')
    cube.data = cube.data * 30.0
    cube.var_name = 'pr'
    allcubes_plio.append(cube)

    pi_cube = cube_reformat('TotalPrecipitation_multimodelmean_month.nc',
                         'TotalPrecipitationmean_pi',
                         'monthly total precipitation', 'mm')
    pi_cube.data = pi_cube.data * 30.0
    pi_cube.var_name = 'pr'

    anom_cube = get_anom('monthly total precipitation', cube, pi_cube)
    allcubes_anom.append(anom_cube)

       
    return allcubes_plio, mintemp, allcubes_anom, mintemp_anom
    
def get_sunshine():
    """
    gets mean monthly percent of possible sunshine.  Steve P and James did
    this by:
    1. get pd total cloud (this is field30)
    2. multiplies this by -1 to get negative total cloud
    3. adds 1 to get total sun.
    4. multiplies by 1000 to get biome units.
    """
    modelnames = ['CESM2', 'CCSM4-UoT', 'CCSM4-Utr', 'HadCM3',
                  'IPSLCM6A','MRI2.3']

    # mPWP
    cube_mPWP = cube_cloud(modelnames, '/EOI400.totcloud.mean_month.nc',
                           'mean monthly percent of possible sunshine',
                           'percent')
    cube_mPWP.var_name = 'clt'

   
    # PI
    cube_PI = cube_cloud(modelnames, '/E280.totcloud.mean_month.nc',
                            'mean monthly percent of possible sunshine',
                            'percent')
    cube_PI.var_name = 'clt'
 
    # find anomaly from observations
    cube_anom = get_anom('mean monthly percent of possible sunshine',
                         cube_mPWP, cube_PI)
   

    return cube_mPWP, cube_anom
  
    

def get_soils():
    """
    gets the soils for input to biome4
    input cubegrid: the grid to put the soils on
    """

    def process_soils(filename):
        """
        processes each file for the soils
        """

        cube1 = iris.load_cube(filename)
        cube = cube1.regrid(cubegrid, iris.analysis.Linear())
        cube.attributes["missing_value"] = -9999

        # temporarily change sea points to average because we
        # will be adding a lsm later

        cube_data = cube.data
        avg_data = np.mean(cube_data)
        newcube_data = np.where(cube_data.mask, avg_data, cube_data)
        cube_full = cube.copy(data = newcube_data) 

        return cube_full

    
    # get grid
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')

    # get mPWP

    file_soils_mPWP = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                       'PRISM3_soil_alternative_whc.nc')
    soil_whc_cube_mPWP = process_soils(file_soils_mPWP)

    file_perc_mPWP = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                      'PRISM3_soil_alternative_perc.nc')
    soil_perc_cube_mPWP = process_soils(file_perc_mPWP)
  

    # get PI

    file_soils_PI = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                       'MODERN_soil_alternative_whc.nc')
    soil_whc_cube_PI = process_soils(file_soils_mPWP)

    file_perc_PI = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                      'MODERN_soil_alternative_perc.nc')
    soil_perc_cube_PI = process_soils(file_perc_mPWP)
  
    # get anomaly

    whc_anom_cube = get_anom('soil water holding capacity',
                         soil_whc_cube_mPWP, soil_whc_cube_PI)
    
    perc_anom_cube = get_anom('soil water percolation index',
                         soil_perc_cube_mPWP, soil_perc_cube_PI)

    return (soil_whc_cube_mPWP, soil_perc_cube_mPWP, 
            whc_anom_cube, perc_anom_cube)

def apply_lsm(cubelist):
    """
    apply a lsm to the cubes
    """

# NOTE THE MASK IS NOT ON THE SAME GRID AS THE DATA

    masked_cubelist = iris.cube.CubeList([])
    lsm = '/nfs/hera1/earjcti/PlioMIP2_Boundary_conds/Plio_enh/Plio_enh/Plio_enh_LSM_v1.0.nc'
    lsmcube_temp = iris.load_cube(lsm)
    cubegrid = iris.load_cube('/nfs/see-fs-02_users/earjcti/PYTHON/PROGRAMS/CEMAC/PLIOMIP2/one_lev_one_deg.nc')
    lsmcube = lsmcube_temp.regrid(cubegrid, iris.analysis.Linear())


   
    for cube in cubelist:
        newcube_data = np.ma.where(lsmcube.data == 0, -9999, cube.data)
        newcube = cube.copy(data = newcube_data)
        masked_cubelist.append(newcube)
        print(newcube.data)
            
   
    return masked_cubelist


def main():
    """
    driver for program to get biome4 intput field
    """

    
    (allcubes_plio, abs_min_cube_plio,
     allcubes_anom, abs_min_cube_anom) = get_temp_precip()
    
    suncube_plio, suncube_anom = get_sunshine()
    allcubes_plio.append(suncube_plio)
    allcubes_anom.append(suncube_anom)
    
    (soil_whc_plio, soil_perc_plio,
     soil_whc_anom, soil_perc_anom)= get_soils()

    allcubes_plio.append(soil_whc_plio)
    allcubes_plio.append(soil_perc_plio)
    allcubes_anom.append(soil_whc_anom)
    allcubes_anom.append(soil_perc_anom)

    allcubes_plio.append(abs_min_cube_plio)
    allcubes_anom.append(abs_min_cube_anom)
                                  # following SPickering this is monthly
                                  # mean minimum not absolute minimum
                                  # best to run in anomaly mode.
    allcubes_land_plio = apply_lsm(allcubes_plio)
  
    iris.save(allcubes_land_plio,OUTFILE + 'absolute.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  


    allcubes_land_anom = apply_lsm(allcubes_anom)
    iris.save(allcubes_land_anom,OUTFILE + 'anomaly.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    
 

FILESTART = '/nfs/hera1/earjcti/regridded/'
OUTFILE = FILESTART +  'BIOME4/inputdataMMM_'

main()
::::::::::::::
setup_biome4_inputfiles.py
::::::::::::::
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created January 2021 by Julia

This program will create the input files for biome4 for each 'regridded' model or the multimodel mean

"""

import numpy as np
import iris
from iris.cube import CubeList
import sys


def cube_reformat(fileend, long_name, units):
    """
    loads in renames and reformats that cube
    """
    filename = (FILESTART + MODELNAME + fileend)
    cube = iris.load_cube(filename)
    cube.remove_coord('time')
    cube.remove_coord('year')
    cube.coord('longitude').rename('lon')
    cube.coord('latitude').rename('lat')
    cube.coord('month').rename('time')
    cube.long_name = long_name
    cube.units = units
    return cube

def get_anom(field, plio_cube, pi_cube):
    """
    gets the standard data from biome 4 and regrids it onto our grid
    """
    filename = ('/nfs/see-fs-02_users/earjcti/BIOME4/'+
                'biome4_pliomip2/inputdata.nc')
    cube = iris.load_cube(filename, field)
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/regridded/IPSLCM6A_origgrid/E280.NearSurfaceTemperature.allmean.nc')
    
    biomecube = cube.regrid(cubegrid, iris.analysis.Linear())
    biomecube_data = biomecube.data

    
    anom_data = np.where(biomecube_data.mask, 
                         plio_cube.data,
                         plio_cube.data - pi_cube.data + biomecube.data)

    if (field == 'monthly total precipitation'
        or field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.where(anom_data > 0, anom_data, 0.0)
    if (field ==  'mean monthly percent of possible sunshine'):
        anom_data = np.where(anom_data < 1000, anom_data, 1000.0)
   
    mpwp_anomcube = plio_cube.copy(data=anom_data)
   
    return mpwp_anomcube

    

def get_temp_precip():
    """
    get temperature and precipitation data in correct units
    plio_cube is from pliocene data
    anom_cube is model_plio - model_pi + observed_pi
    """
    allcubes_plio = CubeList([])
    allcubes_anom = CubeList([])

    # temperature
    cube = cube_reformat('/EOI400.NearSurfaceTemperature.mean_month.nc',
                         'monthly mean temperature', 'degC')
    cube.data = cube.data * 10.0
    allcubes_plio.append(cube)

    pi_cube = cube_reformat('/E280.NearSurfaceTemperature.mean_month.nc',
                         'monthly mean temperature', 'degC')
    pi_cube.data = pi_cube.data * 10.0

    anom_cube = get_anom('monthly mean temperature', cube, pi_cube)
    allcubes_anom.append(anom_cube)


    # get minimum temperature from the pliocene and the anomaly method
    mintemp = cube.collapsed('time', iris.analysis.MIN)
    mintemp.long_name = 'annual absolute minimum temperature'
    mintemp.short_name = 'tmin'
    mintemp.units = 'degC'
    mintemp.remove_coord('time')
    #mintemp.remove_coord('surface')

    mintemp_anom = anom_cube.collapsed('time', iris.analysis.MIN)
    mintemp_anom.long_name = 'annual absolute minimum temperature'
    mintemp_anom.short_name = 'tmin'
    mintemp_anom.units = 'degC'
    mintemp_anom.remove_coord('time')
    #mintemp_anom.remove_coord('surface')
   


    # precipitation
    cube = cube_reformat('/EOI400.TotalPrecipitation.mean_month.nc',
                         'monthly total precipitation', 'mm')
    cube.data = cube.data * 30.0
    allcubes_plio.append(cube)

    pi_cube = cube_reformat('/E280.TotalPrecipitation.mean_month.nc',
                         'monthly total precipitation', 'degC')
    pi_cube.data = pi_cube.data * 30.0

    anom_cube = get_anom('monthly total precipitation', cube, pi_cube)
    allcubes_anom.append(anom_cube)

       
    return allcubes_plio, mintemp, allcubes_anom, mintemp_anom
    
def get_sunshine():
    """
    gets mean monthly percent of possible sunshine.  Steve P and James did
    this by:
    1. get pd total cloud (this is field30)
    2. multiplies this by -1 to get negative total cloud
    3. adds 1 to get total sun.
    4. multiplies by 1000 to get biome units.
    """

    # mPWP
    cube_mPWP = cube_reformat('/EOI400.totcloud.mean_month.nc',
                              'mean monthly percent of possible sunshine',
                              'percent')
    cube_mPWP.short_name = 'sun'
    if MODELNAME != 'HadCM3':
        cube_mPWP.data = cube_mPWP.data / 100.
    cube_mPWP.data = (cube_mPWP.data * (-1.0) + 1.0) * 1000.

    # PI
    cube_PI = cube_reformat('/E280.totcloud.mean_month.nc',
                              'mean monthly percent of possible sunshine',
                              'percent')
    if MODELNAME != 'HadCM3':
        cube_PI.data = cube_PI.data / 100.
  
    cube_PI.short_name = 'sun'
    cube_PI.data = (cube_PI.data * (-1.0) + 1.0) * 1000.

    # find anomaly from observations
    cube_anom = get_anom('mean monthly percent of possible sunshine',
                         cube_mPWP, cube_PI)
   

    return cube_mPWP, cube_anom
  
    

def get_soils():
    """
    gets the soils for input to biome4
    input cubegrid: the grid to put the soils on
    """

    def process_soils(filename):
        """
        processes each file for the soils
        """

        cube1 = iris.load_cube(filename)
        cube = cube1.regrid(cubegrid, iris.analysis.Linear())
        cube.attributes["missing_value"] = -9999

        # temporarily change sea points to average because we
        # will be adding a lsm later

        cube_data = cube.data
        avg_data = np.mean(cube_data)
        newcube_data = np.where(cube_data.mask, avg_data, cube_data)
        cube_full = cube.copy(data = newcube_data) 

        return cube_full

    
    # get grid
    cubegrid = iris.load_cube('/nfs/hera1/earjcti/regridded/IPSLCM6A_origgrid/E280.NearSurfaceTemperature.allmean.nc')
   
    # get mPWP

    file_soils_mPWP = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                       'PRISM3_soil_alternative_whc.nc')
    soil_whc_cube_mPWP = process_soils(file_soils_mPWP)

    file_perc_mPWP = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                      'PRISM3_soil_alternative_perc.nc')
    soil_perc_cube_mPWP = process_soils(file_perc_mPWP)
  

    # get PI

    file_soils_PI = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                       'MODERN_soil_alternative_whc.nc')
    soil_whc_cube_PI = process_soils(file_soils_mPWP)

    file_perc_PI = ('/nfs/hera2/scripts/BIOME4/reference_HadGEM/' + 
                      'MODERN_soil_alternative_perc.nc')
    soil_perc_cube_PI = process_soils(file_perc_mPWP)
  
    # get anomaly

    whc_anom_cube = get_anom('soil water holding capacity',
                         soil_whc_cube_mPWP, soil_whc_cube_PI)
    
    perc_anom_cube = get_anom('soil water percolation index',
                         soil_perc_cube_mPWP, soil_perc_cube_PI)

    return (soil_whc_cube_mPWP, soil_perc_cube_mPWP, 
            whc_anom_cube, perc_anom_cube)

def apply_lsm(cubelist):
    """
    apply a lsm to the cubes
    """

# NOTE THE MASK IS NOT ON THE SAME GRID AS THE DATA

    masked_cubelist = CubeList([])
    lsm = '/nfs/hera1/earjcti/PlioMIP2_Boundary_conds/Plio_enh/Plio_enh/Plio_enh_LSM_v1.0.nc'
    lsmcube_temp = iris.load_cube(lsm)
    

    cubegrid = iris.load_cube('/nfs/hera1/earjcti/regridded/IPSLCM6A_origgrid/E280.NearSurfaceTemperature.allmean.nc')
 
    lsmcube = lsmcube_temp.regrid(cubegrid, iris.analysis.Linear())


   
    for cube in cubelist:
        newcube_data = np.ma.where(lsmcube.data == 0, -9999, cube.data)
        newcube = cube.copy(data = newcube_data)
        masked_cubelist.append(newcube)
        print(newcube.data)
            
   
    return masked_cubelist


def main():
    """
    driver for program to get biome4 intput field
    """

    
    (allcubes_plio, abs_min_cube_plio,
     allcubes_anom, abs_min_cube_anom) = get_temp_precip()
    
    suncube_plio, suncube_anom = get_sunshine()
    allcubes_plio.append(suncube_plio)
    allcubes_anom.append(suncube_anom)
    
    (soil_whc_plio, soil_perc_plio,
     soil_whc_anom, soil_perc_anom)= get_soils()

    allcubes_plio.append(soil_whc_plio)
    allcubes_plio.append(soil_perc_plio)
    allcubes_anom.append(soil_whc_anom)
    allcubes_anom.append(soil_perc_anom)

    allcubes_plio.append(abs_min_cube_plio)
    allcubes_anom.append(abs_min_cube_anom)
                                  # following SPickering this is monthly
                                  # mean minimum not absolute minimum
                                  # best to run in anomaly mode.
    allcubes_land_plio = apply_lsm(allcubes_plio)
  
    iris.save(allcubes_land_plio,OUTFILE + 'absolute.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  


    allcubes_land_anom = apply_lsm(allcubes_anom)
    iris.save(allcubes_land_anom,OUTFILE + 'anomaly.nc', 
              netcdf_format="NETCDF3_CLASSIC", fill_value = -9999)  
    
  
 
FILESTART = '/nfs/hera1/earjcti/regridded/'
MODELNAME = 'IPSLCM6A_origgrid'
OUTFILE = FILESTART + MODELNAME + '/biome4/inputdata_'

main()
