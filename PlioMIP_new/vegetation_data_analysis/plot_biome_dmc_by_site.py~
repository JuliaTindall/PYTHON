#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created February 2021 by Julia

This program will do a DMC of biomes by site at high latitudes.

(I am currently thinking polar stereographic plot, I am also thinking to plot data on one figure and another figure showing only those sites where the model is different).  

; tropical evergreen broadleaf forest                = 1
; tropical semi-evergreen broadleaf forest           = 2
; tropical deciduous broadleaf forest & woodland     = 3
; temperate deciduous broadleaf forest               = 4
; temperate evergreen needleleaf forest              = 5
; warm-temperate evergreen broadleaf & mixed forest  = 6
; cool mixed forest                                  = 7
; cool evergreen needleleaf forest                   = 8
; cool-temperate evergreen needleleaf & mixed forest = 9
; cold evergreen needleleaf forest                   = 10
; cold deciduous forest                              = 11
; tropical savanna                                   = 12
; tropical xerophytic shrubland                      = 13
; temperate xerophytic shrubland                     = 14
; temperate sclerophyll woodland and shrubland       = 15
; temperate deciduous broadleaf savanna              = 16
; temperate evergreen needleleaf open woodland       = 17
; cold parkland                                      = 18
; tropical grassland                                 = 19
; temperate grassland                                = 20
; desert                                             = 21
; graminoid and forb tundra                          = 22
; low and high shrub tundra                          = 23
; erect dwarf-shrub tundra                           = 24
; prostrate dwarf-shrub tundra                       = 25
; cushion-forb tundra                                = 26
; barren                                             = 27
; ice                                                = 28


"""
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
from matplotlib.markers import MarkerStyle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import iris
import iris.plot as iplt
import cartopy.crs as ccrs
import matplotlib.path as mpath
import sys
import math

def make_cmap(colors, position=None, bit=False):
    '''
    I didn't write this I found it on the web.
    make_cmap takes a list of tuples which contain RGB values. The RGB
    values may either be in 8-bit [0 to 255] (in which bit must be set to
    True when called) or arithmetic [0 to 1] (default). make_cmap returns
    a cmap with equally spaced colors.
    Arrange your tuples so that the first color is the lowest value for the
    colorbar and the last is the highest.
    position contains values from 0 to 1 to dictate the location of each color.
    '''
    bit_rgb = np.linspace(0,1,256)
    if position == None:
        position = np.linspace(0,1,len(colors))
    else:
        if len(position) != len(colors):
            sys.exit("position length must be the same as colors")
        elif position[0] != 0 or position[-1] != 1:
            sys.exit("position must start with 0 and end with 1")
    if bit:
        for i in range(len(colors)):
            colors[i] = (bit_rgb[colors[i][0]],
                         bit_rgb[colors[i][1]],
                         bit_rgb[colors[i][2]])
    cdict = {'red':[], 'green':[], 'blue':[]}
    for pos, color in zip(position, colors):
        cdict['red'].append((pos, color[0], color[0]))
        cdict['green'].append((pos, color[1], color[1]))
        cdict['blue'].append((pos, color[2], color[2]))

    cmap = mpl.colors.LinearSegmentedColormap('my_colormap',cdict,256)
    return cmap

def get_biome_details():
    """
    gets the biome names and colormap.  These are hard coded
    """
    
    names = ["Tropical evergreen forest",    
             "Tropical semi-deciduous forest",
             "Tropical decididous forest",
             "Temperate deciduous forest",
             "Temperate conifer forest",
             "warm mixed forest",
             "cool mixed forest",
             "cool conifer forest",  
             "cool-temperate mixed forest",
             "Evergreen taiga/montane forest",                  
             "Deciduous taiga/montane forest",                           
             "Tropical savanna",                            
             "Tropical xerophytic shrubland",                  
             "Temperate xerophytic shrubland",                   
             "Temperate sclerophyll woodland",     
             "Temperate broadleaf savanna",              
             "Open conifer woodland",     
             "Boreal parkland",                                  
             "Tropical grassland",                              
             "Temperate grassland",                              
             "Desert",                                           
             "Steppe tundra",                         
             "Shrub tundra",                         
             "Dwarf-shrub tundra",                          
             "Prostrate shrub tundra",                      
             "Cushion-forb tundra",                               
             "Barren",                                           
             "Land ice"] 

    names_needed = [
             "Temperate deciduous forest",
             "Temperate conifer forest",
             "warm mixed forest",
             "cool mixed forest",
             "cool conifer forest",  
             "cool-temperate mixed forest",
             "Evergreen taiga/montane forest",                  
             "Deciduous taiga/montane forest",                           
             "Tropical savanna",                            
             "Tropical xerophytic shrubland",                  
             "Temperate xerophytic shrubland",                   
             "Temperate sclerophyll woodland",     
             "Temperate broadleaf savanna",              
             "Open conifer woodland",     
             "Boreal parkland",                                  
             "Tropical grassland",                              
             "Temperate grassland",                              
             "Desert",                                           
             "Steppe tundra",                         
             "Shrub tundra",                         
             "Dwarf-shrub tundra",                          
             "Prostrate shrub tundra",                      
             "Cushion-forb tundra",                               
             "Barren",                                           
             "Land ice"]

    colors = [ #( 1.000, 1.000, 1.000), 
            # ( 0.000, 0.000, 0.000 ),
             ( 0.110, 0.333, 0.063 ),
             ( 0.396, 0.573, 0.031 ),
             ( 0.682, 0.490, 0.125 ),
             ( 0.333, 0.922, 0.286 ),
             ( 0.094, 0.510, 0.443 ),
             ( 0.000, 0.000, 0.396 ),
             ( 0.792, 1.000, 0.792 ),
             ( 0.000, 0.604, 0.094 ),
             ( 0.443, 0.141, 0.208 ),
             ( 0.000, 0.125, 0.792 ),
             ( 0.396, 0.698, 1.000 ),
             ( 0.729, 1.000, 0.208 ),
             ( 1.000, 0.729, 0.604 ),
             ( 1.000, 0.875, 0.792 ),
             ( 0.557, 0.635, 0.157 ),
             ( 0.459, 1.000, 0.208 ),
             ( 1.000, 0.604, 0.875 ),
             ( 0.396, 0.490, 1.000 ),
             ( 1.000, 0.729, 0.208 ),
             ( 1.000, 0.875, 0.604 ),
             ( 0.969, 1.000, 0.792 ),
             ( 0.906, 0.906, 0.094 ),
             ( 0.396, 1.000, 0.604 ),
             ( 0.475, 0.525, 0.286 ),
             ( 0.824, 0.620, 0.588 ),
             ( 0.604, 0.396, 1.000 ),
             ( 0.729, 0.714, 0.667 ),
             ( 0.714, 0.824, 0.875 ), 
             #( 0.700, 0.700, 0.700 )
             ]

    #cmap = mpl.colors.LinearSegmentedColormap.from_list(
    #    'Custom cmap', cmaplist, cmap.N)
    
   # cmap = mpl.colors.ListedColormap(['red',    'green',  'blue', 
   #                                   'cyan', 'red',   'green',  'blue', 
   #                                   'cyan',   'red',    'green',    'blue', 
   #                                   'cyan', 'red',  'green',  'blue', 
   #                                   'cyan',    'red',  'green', 'blue', 
   #                                   'cyan',   'red',  'green',  'blue', 
   #                                   'cyan',  'red',  'green',  'blue', 
   #                                   'cyan'    ])
    cmap = mpl.colors.ListedColormap(colors)
    bounds = np.linspace(0.5, 28.5, 29)
   
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    return names, colors, cmap, norm, bounds

def get_site_data():
    """
    This will get the site data from ulrichs spreadsheet
    """

    filein = '/nfs/hera1/earjcti/PLIOMIP2/proxydata/tab_GIS_all_Pliocene_Final.xlsx'
    dataframe = pd.read_excel(filein)
    lats_full = dataframe.loc[:, 'latitude'].to_numpy()
    lons_full = dataframe.loc[:, 'longitude'].to_numpy()
    biome_full = dataframe.loc[:, 'Raster_ID'].to_numpy()
   
    lat = []
    lon = []
    biome = []
    for i, latreq in enumerate(lats_full):
        if latreq > LAT_LIMIT:
            lat.append(latreq)
            lon.append(lons_full[i])
            biome.append(biome_full[i])

    return np.asarray(lat), np.asarray(lon), np.asarray(biome)

def get_MMM_output(latreq, lonreq, biomedata):
    """
    reads in the data and puts it in a array (M, N, 3) with the
    third dimensio being the colors
    """
    cube = iris.load_cube(FILENAME, 'biome')
    cube_lats = cube.coord('latitude').points
    cube_lons = cube.coord('longitude').points
    model_data = []
    model_diff = []

    for i, lat in enumerate(latreq):
        lon = lonreq[i]
        if lon < 0.:
            lon = lon + 360.

        latix = np.abs(cube_lats - lat).argmin()
        lonix = np.abs(cube_lons - lon).argmin()

        print(i, lat)
        if lat >  LAT_LIMIT and math.isfinite(cube.data[latix,lonix]):
            model_data.append([latreq[i], lonreq[i], cube.data[latix,lonix], 
                                 biomedata[i]])

            if cube.data[latix,lonix] != biomedata[i]:
                model_diff.append([latreq[i], lonreq[i],cube.data[latix,lonix], 
                                   biomedata[i]])

    print('model diff',np.shape(np.asarray(model_diff)),
              ' model data', np.shape(np.asarray(model_data)))
  
    return cube, np.asarray(model_data), np.asarray(model_diff)
      
def plot_data(mycmap, names, model_results, model_diff,
              model_cube):
    """
    plots the biomes
    model_results is lat, lon, model_data, biome_data
    """
    # set polar stereographic axis
    fig = plt.figure(figsize=(11.0, 11.0))
    ax1 = fig.add_subplot(2,2,1, projection = ccrs.NorthPolarStereo())
    ax1.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax1.coastlines()
    ax1.gridlines()

    # Compute a circle in axes coordinates, which we can use as a boundary
    # for the map. We can pan/zoom as much as we like - the boundary will be
    # permanently circular.
    theta = np.linspace(0, 2*np.pi, 100)
    center, radius = [0.5, 0.5], 0.5
    verts = np.vstack([np.sin(theta), np.cos(theta)]).T
    circle = mpath.Path(verts * radius + center)

    ax1.set_boundary(circle, transform=ax1.transAxes)
    
   
    # plot the data (confusingly this is stored in model_results[:,3}
    V = np.arange(1,29,1)
    print(V)
    norm = colors.BoundaryNorm(boundaries=V, ncolors=mycmap.N)
  
    cs = plt.scatter(model_results[:,1], model_results[:,0], 
                     c=model_results[:,3],  marker='o', s=100,
                     norm = norm , cmap=mycmap, edgecolors='black',
                     transform=ccrs.Geodetic())

    plt.title('a) Biome reconstruction')

    # plot the model results
    ax2 = fig.add_subplot(2,2,3, projection = ccrs.NorthPolarStereo())
    ax2.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax2.coastlines()
    ax2.gridlines()
    ax2.set_boundary(circle, transform=ax2.transAxes)
    cs = plt.scatter(model_results[:,1], model_results[:,0], 
                     c=model_results[:,2],  marker='o', s=100,
                     norm = norm , edgecolors='black',cmap=mycmap, 
                     transform=ccrs.Geodetic())

    plt.title('c) Modelled Biome at sites')

    # plot all of the modelled biomes
    ax3 = fig.add_subplot(2,2,2, projection = ccrs.NorthPolarStereo())
    ax3.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax3.coastlines()
    ax3.gridlines()
    ax3.set_boundary(circle, transform=ax3.transAxes)
    # turn the iris Cube data structure into numpy arrays
    gridlons = model_cube.coord('longitude').contiguous_bounds()
    gridlats = model_cube.coord('latitude').contiguous_bounds()
    modeldata = model_cube.data
    print(modeldata)

    cs = plt.pcolormesh(gridlons, gridlats, modeldata,
                   cmap=mycmap, norm=norm, 
                     transform=ccrs.PlateCarree())
    plt.title('b) Modelled biomes')



    # plot the modelled biome where it is different from data
    #model diff is[lat, lon, model_data[i], biome_data[i]]

    ax4 = fig.add_subplot(2,2,4, projection = ccrs.NorthPolarStereo())
    ax4.set_extent([-180, 180, 50, 90], ccrs.PlateCarree())
    ax4.coastlines()
    ax4.gridlines()
    ax4.set_boundary(circle, transform=ax4.transAxes)
    cs = plt.scatter(model_diff[:,1], model_diff[:,0], c=model_diff[:,2], 
                     marker=MarkerStyle('o', fillstyle='left'),
                     edgecolors='black',
                     s=150, 
                     norm = norm , cmap=mycmap, transform=ccrs.Geodetic())
    cs = plt.scatter(model_diff[:,1], model_diff[:,0], c=model_diff[:,3], 
                     marker=MarkerStyle('o', fillstyle='right'),
                     edgecolors='black',
                     s=150, 
                     norm = norm , cmap=mycmap, transform=ccrs.Geodetic())

    plt.title('d) Model-data mismatch at sites')



    # adjust plots so we have room for colorbar
    fig.subplots_adjust(bottom=0.05, top = 0.95, left = 0.05, right = 0.70)

    # do colorbar
    cbar_ax = fig.add_axes([0.75, 0.05, 0.05, 0.9])
    cbar = fig.colorbar(cs, cax= cbar_ax, ticks=V+0.5, )
    cbar.ax.set_yticklabels(names)
    cbar.ax.tick_params (labelsize=9)
    cbar.ax.invert_yaxis()
   
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.eps')
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.png')
    plt.savefig('/nfs/see-fs-02_users/earjcti/PYTHON/PLOTS/PLIOMIP2/vegetation/biome_dmc_by_site_'+ ABS_ANOM + '.pdf')
    plt.close()

def main():
    """
    driver to get biomes
    """

    print('j1')
    biome_names, colors, cmap, norm, bounds= get_biome_details()
    print('j2')

    lats_data, lons_data, biomes_data = get_site_data()
    
    (model_cube, biomes_model, 
    biomes_diff) = get_MMM_output(lats_data, lons_data, biomes_data)

    # plot data and model results
    plot_data(cmap, biome_names, 
              biomes_model, biomes_diff, model_cube)
   

    print('prog finished')
    
 

FILESTART = '/nfs/hera1/earjcti/regridded/'
MODELNAME = 'BIOME4' # this will be MMM
ABS_ANOM = 'Abs'
LAT_LIMIT = 55  # only deal with stuff polewards of 55N
#FILESTART = '/nfs/see-fs-02_users/earjcti/BIOME4/biome4_pliomip2/'
#MODELNAME = ''
#ABS_ANOM = ''
if MODELNAME == 'BIOME4':
    midfname = MODELNAME
else:
    midfname =  MODELNAME + '/biome4/' 
   
if ABS_ANOM == 'Anom':
    FILENAME = FILESTART + midfname + '/biome4out_anomaly.nc'
if ABS_ANOM == 'Abs':
    FILENAME = FILESTART + midfname + '/biome4out_absolute.nc'
if ABS_ANOM == '':
    FILENAME = FILESTART + midfname + 'biome4out.nc'

main()
