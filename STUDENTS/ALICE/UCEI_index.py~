#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on 08/09/2020

@author: earjcti

This will plot the UCEI index 

"""


import sys
import iris
import iris.quickplot as qplt
import iris.plot as iplt
import numpy as np
import matplotlib.pyplot as plt
import iris.analysis.cartography
import xarray as xr

def low_pass_weights(window, cutoff):
    """
    # calculate weights for a running mean filter

    """
    # window: int -  The length of the filter window.

    # cutoff: float - The cutoff frequency in inverse time steps.

    order = ((window - 1) // 2) + 1
    nwts = 2 * order + 1
    w = np.zeros([nwts])
    n = nwts // 2
    w[n] = 2 * cutoff
    k = np.arange(1., n)
    sigma = np.sin(np.pi * k / n) * n / (np.pi * k)
    firstfactor = np.sin(2. * np.pi * cutoff * k) / (np.pi * k)
    w[n-1:0:-1] = firstfactor * sigma
    w[n+1:-1] = firstfactor * sigma
    return w[1:-1]


def get_nino_timeseries(cube, latmin, latmax, lonmin, lonmax):
   """
   gets the average timeseries from 'cube' in the region and apply a low pass filter
   """

   nino_slice = cube.extract(iris.Constraint(latitude = lambda cell: latmin <= cell <= latmax,
                                         longitude = lambda cell: lonmin <= cell <= lonmax,))
   nino_slice.coord('latitude').guess_bounds()
   nino_slice.coord('longitude').guess_bounds()
   grid_areas = iris.analysis.cartography.area_weights(nino4_slice)

   nino_mean = nino_slice.collapsed(['longitude','latitude'], 
                                    iris.analysis.MEAN, weights = grid_areas)

   # apply running mean
   window = 5
   # Construct 5 month low pass filters for the monthly mean sst data
   wgts5 = low_pass_weights(window, 1. / 5.)
   # Apply  filter
   Nino = nino_mean.rolling_window('time', iris.analysis.SUM, len(wgts5), weights = wgts5)

   # sort out x axis
   nino_sst = Nino4.data
   nmonths = len(nino_sst)
   nino_plio = np.zeros(nmonths)

   for i in range(1, nmonths-1):
        nino_plio[i] = (nino4_sst[i-1] + nino4_sst[i] + nino4_sst[i+1]) / 3.0


 
   return nino_plio




# define where to find data
#FILESTART = 'C:\\Users\\Team Knowhow\\OneDrive\\PlioMIP data\\CCSM4\\timeseries'
FILESTART = '/nfs/hera1/earjcti/regridded/HadCM3/timeseries/'
PERIOD = 'EOI400'
FIELDNAME = 'SST'
MODELNAME = 'HadCM3'
# define filename
FILENAME = (FILESTART + '/' + MODELNAME + '_' + 'EOI400.SST.timeseries_no_ann_cycle.nc')

# load cube
cube = iris.load_cube(filename)

## need nino3 nino34 and nino4 timeseries

# limit domain to nino4 region
nino4_oni = get_nino_timeseries(-5.5, 5.5, 160, 210)
nino3_oni = get_nino_timeseries(-5.5, 5.5, 210. 270)
nino34_oni = get_nino_timeseries(-5.5, 5.5, 190. 240)

print(nino34_oni)
sys.exit(0)

# sort out x axis
nmonths = len(nino4_oni)
years = np.arange(0, nmonths, 1) / 12


# normalise by standard deviation
mean_plio4 = np.mean(nino4_plio)
std_plio4 = np.std(nino4_plio)
standard_nino4_plio = ((nino4_plio - mean_plio4)/ std_plio4)

## nino3 timeseries

# limit domain to nino3 region
nino3_slice = cube.extract(iris.Constraint(latitude = lambda cell: -5.5 <= cell <= 5.5,
                                         longitude = lambda cell: 210 <= cell <= 270,))
# generate area-weights array
nino3_slice.coord('latitude').guess_bounds()
nino3_slice.coord('longitude').guess_bounds()
grid_areas = iris.analysis.cartography.area_weights(nino3_slice)

# generate area-weighted mean
nino3_mean = nino3_slice.collapsed(['longitude','latitude'], iris.analysis.MEAN, weights = grid_areas)

# apply running mean
window = 5
# Construct 5 month low pass filters for the monthly mean sst data
wgts5 = low_pass_weights(window, 1. / 5.)
# Apply  filter
Nino3 = nino3_mean.rolling_window('time', iris.analysis.SUM, len(wgts5), weights = wgts5)

nino3_plio = np.zeros(nmonths3)

for i in range(1, nmonths3-1):
        nino3_plio[i] = (nino3_sst[i-1] + nino3_sst[i] + nino3_sst[i+1]) / 3.0

# normalise by standard deviation
mean_plio3 = np.mean(nino3_plio)
std_plio3 = np.std(nino3_plio)
standard_nino3_plio = ((nino3_plio - mean_plio3)/ std_plio3)

  # UCEI calculation

import math as math

plio_N3 = standard_nino3_plio.data
plio_N4 = standard_nino4_plio.data

plio_N3_sq = np.square(plio_N3)
plio_N4_sq = np.square(plio_N4)

plio_r = np.sqrt( 2 * (plio_N3_sq + plio_N4_sq))
 
plio_real = np.add(plio_N3, plio_N4)
plio_imagine = np.subtract(plio_N3, plio_N4)
           
plio_var = np.divide(plio_imagine, plio_real)

plio_theta = np.zeros(np.shape(plio_var))

for i, x in enumerate(plio_real):
    if x >= 0:
         plio_theta[i] = np.arctan(plio_var[i])
    else:
         plio_theta[i] = np.arctan(plio_var[i]) - math.pi
       
plio_theta_deg = np.rad2deg(plio_theta)

## plot pliocene UCEI

plt.figure(figsize=(10,5))
plt.scatter(plio_theta_deg, plio_r, c ='k', s =1.5, marker = 'o')

plt.plot([-280, 100], [0.5, 0.5], c ='k', linestyle='--', linewidth=1.0)
plt.plot([-280, 100], [1.0, 1.0], c ='k', linestyle='--', linewidth=1.0)
plt.plot([-280, 100], [2.0, 2.0], c ='k', linestyle='--', linewidth=1.0)
plt.plot([-195, -195], [-0.0, 8.5], c ='k', linestyle='--', linewidth=1.0)
plt.plot([-165, -165], [-0.0, 8.5], c ='k', linestyle='--', linewidth=1.0)
plt.plot([-90, -90], [-0.0, 8.5], c ='k', linestyle='-', linewidth=1.0)
plt.plot([-15, -15], [-0.0, 8.5], c ='k', linestyle='--', linewidth=1.0)
plt.plot([15, 15], [-0.0, 8.5], c ='k', linestyle='--', linewidth=1.0)

plt.xlim(-270,90)
plt.ylim(0,8)

plt.title('Pliocene', fontsize = 14)
plt.xlabel('θ', fontsize = 12)
plt.ylabel('ENSO Strength', fontsize = 12)

